<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title></title><link rel="stylesheet" href="style_cache/github-fff66249e57e12b5b264967f6a4d21f8923d59247f86c4419d1e3092660fe54b.css" />
  <link rel="stylesheet" href="style_cache/github2-27099ff875724b3da49fac6911968f783aa96ed08970c77185d963ce6c21af75.css" />
  <style>
    .file-box {
      margin: 64px auto;
      width: 920px;
    }
	body {
		font-size: 14px;
		line-height: 22px;
		<!--font-family: "adelle",Georgia,"Times New Roman",serif;-->
		color: #4e443c;
		background: #f0efe7;
	}

	.book-toc {

	}
	a {
		color: #0388a6;
		text-decoration: none;
	}
	a:hover {
		color: #04b1d8;
		text-decoration: none;
	}
	ol.book-toc li.chapter{
		margin-bottom:0.6em
	}
	ol.book-toc, ol{
		list-style-type: disc
	}
	ol.book-toc{
		margin:30px 36px
	}
	ol.book-toc a{
		padding-left:4px
	}
	li {
		line-height: 22px;
	}
	h1, h2, h3, h4, h5, h6, li, p, a, ol, div{
		margin: 0;
		padding: 0;
		border: 0;
		vertical-align: baseline;
	}
	ul, ol {
		padding: 0;
		margin: 0 0 11px 25px;
	}
	h1 {
		font-size: 36px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	h2 {
		font-size: 18px;
		color: #f14e32;
		font-weight: bold;
	}
	h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h1{
		font-size: 22px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	ol.book-toc h2 {
		font-size: 16px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	p {
		margin: 0 0 11px;
		font-size: 14px;
		line-height: 22px;
	}
	div {
		display: block;
	}
	div#nav{
		padding: 30px
	}
  </style>
</head>
<body>
  <div class="page">
    <div class="file-box">
	<div class="file">
		<div id="readme" class="blob instapaper_body announce md">
		  <article class="markdown-body entry-content" itemprop="mainContentOfPage">
			<html>
 <body>
  <h1>
   <a aria-hidden="true" class="anchor" href="#%E6%95%99%E4%BD%A0%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0sift%E7%AE%97%E6%B3%95%E4%B8%8B" id="user-content-教你一步一步用c语言实现sift算法下">
    <span class="octicon octicon-link">
    </span>
   </a>
   教你一步一步用c语言实现sift算法、下
  </h1>
  <p>
   本文接上，
   <a href="10.01.02.html">
    教你一步一步用c语言实现sift算法、上
   </a>
   而来：
  </p>
  <h3>
   <a aria-hidden="true" class="anchor" href="#%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99" id="user-content-函数编写">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    函数编写
   </strong>
  </h3>
  <p>
   ok，接上文，咱们一个一个的来编写main函数中所涉及到所有函数，这也是本文的关键部分：
  </p>
  <div class="highlight highlight-c">
   <pre><span class="pl-c">//下采样原来的图像，返回缩小2倍尺寸的图像  </span>
CvMat * <span class="pl-en">halfSizeImage</span>(CvMat * im)   
{  
    <span class="pl-st">unsigned</span> <span class="pl-st">int</span> i,j;  
    <span class="pl-st">int</span> w = im-&gt;cols/<span class="pl-c1">2</span>;  
    <span class="pl-st">int</span> h = im-&gt;rows/<span class="pl-c1">2</span>;   
    CvMat *imnew = <span class="pl-s3">cvCreateMat</span>(h, w, CV_32FC1);  

#<span class="pl-k">define</span> <span class="pl-en">Im</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(im-&gt;data.fl + im-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
#<span class="pl-k">define</span> <span class="pl-en">Imnew</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(imnew-&gt;data.fl + imnew-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-k">for</span> ( j = <span class="pl-c1">0</span>; j &lt; h; j++)   
        <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; w; i++)   
            <span class="pl-s3">Imnew</span>(j,i)=<span class="pl-s3">Im</span>(j*<span class="pl-c1">2</span>, i*<span class="pl-c1">2</span>);  
    <span class="pl-k">return</span> imnew;  
}  

<span class="pl-c">//上采样原来的图像，返回放大2倍尺寸的图像  </span>
CvMat * <span class="pl-en">doubleSizeImage</span>(CvMat * im)   
{  
    <span class="pl-st">unsigned</span> <span class="pl-st">int</span> i,j;  
    <span class="pl-st">int</span> w = im-&gt;cols*<span class="pl-c1">2</span>;  
    <span class="pl-st">int</span> h = im-&gt;rows*<span class="pl-c1">2</span>;   
    CvMat *imnew = <span class="pl-s3">cvCreateMat</span>(h, w, CV_32FC1);  

#<span class="pl-k">define</span> <span class="pl-en">Im</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(im-&gt;data.fl + im-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
#<span class="pl-k">define</span> <span class="pl-en">Imnew</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(imnew-&gt;data.fl + imnew-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  

    <span class="pl-k">for</span> ( j = <span class="pl-c1">0</span>; j &lt; h; j++)   
        <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; w; i++)   
            <span class="pl-s3">Imnew</span>(j,i)=<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>, i/<span class="pl-c1">2</span>);  

    <span class="pl-k">return</span> imnew;  
}  

<span class="pl-c">//上采样原来的图像，返回放大2倍尺寸的线性插值图像  </span>
CvMat * <span class="pl-en">doubleSizeImage2</span>(CvMat * im)   
{  
    <span class="pl-st">unsigned</span> <span class="pl-st">int</span> i,j;  
    <span class="pl-st">int</span> w = im-&gt;cols*<span class="pl-c1">2</span>;  
    <span class="pl-st">int</span> h = im-&gt;rows*<span class="pl-c1">2</span>;   
    CvMat *imnew = <span class="pl-s3">cvCreateMat</span>(h, w, CV_32FC1);  

#<span class="pl-k">define</span> <span class="pl-en">Im</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(im-&gt;data.fl + im-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
#<span class="pl-k">define</span> <span class="pl-en">Imnew</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(imnew-&gt;data.fl + imnew-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  

    <span class="pl-c">// fill every pixel so we don't have to worry about skipping pixels later  </span>
    <span class="pl-k">for</span> ( j = <span class="pl-c1">0</span>; j &lt; h; j++)   
    {  
        <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; w; i++)   
        {  
            <span class="pl-s3">Imnew</span>(j,i)=<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>, i/<span class="pl-c1">2</span>);  
        }  
    }  
    <span class="pl-c">/* </span>
<span class="pl-c">    A B C </span>
<span class="pl-c">    E F G </span>
<span class="pl-c">    H I J </span>
<span class="pl-c">    pixels A C H J are pixels from original image </span>
<span class="pl-c">    pixels B E G I F are interpolated pixels </span>
<span class="pl-c">    */</span>  
    <span class="pl-c">// interpolate pixels B and I  </span>
    <span class="pl-k">for</span> ( j = <span class="pl-c1">0</span>; j &lt; h; j += <span class="pl-c1">2</span>)  
        <span class="pl-k">for</span> ( i = <span class="pl-c1">1</span>; i &lt; w - <span class="pl-c1">1</span>; i += <span class="pl-c1">2</span>)  
            <span class="pl-s3">Imnew</span>(j,i)=<span class="pl-c1">0.5</span>*(<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>, i/<span class="pl-c1">2</span>)+<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>, i/<span class="pl-c1">2</span>+<span class="pl-c1">1</span>));  
    <span class="pl-c">// interpolate pixels E and G  </span>
    <span class="pl-k">for</span> ( j = <span class="pl-c1">1</span>; j &lt; h - <span class="pl-c1">1</span>; j += <span class="pl-c1">2</span>)  
        <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; w; i += <span class="pl-c1">2</span>)  
            <span class="pl-s3">Imnew</span>(j,i)=<span class="pl-c1">0.5</span>*(<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>, i/<span class="pl-c1">2</span>)+<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>+<span class="pl-c1">1</span>, i/<span class="pl-c1">2</span>));  
    <span class="pl-c">// interpolate pixel F  </span>
    <span class="pl-k">for</span> ( j = <span class="pl-c1">1</span>; j &lt; h - <span class="pl-c1">1</span>; j += <span class="pl-c1">2</span>)  
        <span class="pl-k">for</span> ( i = <span class="pl-c1">1</span>; i &lt; w - <span class="pl-c1">1</span>; i += <span class="pl-c1">2</span>)  
            <span class="pl-s3">Imnew</span>(j,i)=<span class="pl-c1">0.25</span>*(<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>, i/<span class="pl-c1">2</span>)+<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>+<span class="pl-c1">1</span>, i/<span class="pl-c1">2</span>)+<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>, i/<span class="pl-c1">2</span>+<span class="pl-c1">1</span>)+<span class="pl-s3">Im</span>(j/<span class="pl-c1">2</span>+<span class="pl-c1">1</span>, i/<span class="pl-c1">2</span>+<span class="pl-c1">1</span>));  
    <span class="pl-k">return</span> imnew;  
}  

<span class="pl-c">//双线性插值，返回像素间的灰度值  </span>
<span class="pl-st">float</span> <span class="pl-en">getPixelBI</span>(CvMat * im, <span class="pl-st">float</span> col, <span class="pl-st">float</span> row)   
{  
    <span class="pl-st">int</span> irow, icol;  
    <span class="pl-st">float</span> rfrac, cfrac;  
    <span class="pl-st">float</span> row1 = <span class="pl-c1">0</span>, row2 = <span class="pl-c1">0</span>;  
    <span class="pl-st">int</span> width=im-&gt;cols;  
    <span class="pl-st">int</span> height=im-&gt;rows;  
#<span class="pl-k">define</span> <span class="pl-en">ImMat</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(im-&gt;data.fl + im-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  

    irow = (<span class="pl-st">int</span>) row;  
    icol = (<span class="pl-st">int</span>) col;  

    <span class="pl-k">if</span> (irow &lt; <span class="pl-c1">0</span> || irow &gt;= height  
        || icol &lt; <span class="pl-c1">0</span> || icol &gt;= width)  
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;  
    <span class="pl-k">if</span> (row &gt; height - <span class="pl-c1">1</span>)  
        row = height - <span class="pl-c1">1</span>;  
    <span class="pl-k">if</span> (col &gt; width - <span class="pl-c1">1</span>)  
        col = width - <span class="pl-c1">1</span>;  
    rfrac = <span class="pl-c1">1.0</span> - (row - (<span class="pl-st">float</span>) irow);  
    cfrac = <span class="pl-c1">1.0</span> - (col - (<span class="pl-st">float</span>) icol);  
    <span class="pl-k">if</span> (cfrac &lt; <span class="pl-c1">1</span>)   
    {  
        row1 = cfrac * <span class="pl-s3">ImMat</span>(irow,icol) + (<span class="pl-c1">1.0</span> - cfrac) * <span class="pl-s3">ImMat</span>(irow,icol+<span class="pl-c1">1</span>);  
    }   
    <span class="pl-k">else</span>   
    {  
        row1 = <span class="pl-s3">ImMat</span>(irow,icol);  
    }  
    <span class="pl-k">if</span> (rfrac &lt; <span class="pl-c1">1</span>)   
    {  
        <span class="pl-k">if</span> (cfrac &lt; <span class="pl-c1">1</span>)   
        {  
            row2 = cfrac * <span class="pl-s3">ImMat</span>(irow+<span class="pl-c1">1</span>,icol) + (<span class="pl-c1">1.0</span> - cfrac) * <span class="pl-s3">ImMat</span>(irow+<span class="pl-c1">1</span>,icol+<span class="pl-c1">1</span>);  
        } <span class="pl-k">else</span>   
        {  
            row2 = <span class="pl-s3">ImMat</span>(irow+<span class="pl-c1">1</span>,icol);  
        }  
    }  
    <span class="pl-k">return</span> rfrac * row1 + (<span class="pl-c1">1.0</span> - rfrac) * row2;  
}  

<span class="pl-c">//矩阵归一化  </span>
<span class="pl-st">void</span> <span class="pl-en">normalizeMat</span>(CvMat* mat)   
{  
#<span class="pl-k">define</span> <span class="pl-en">Mat</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(mat-&gt;data.fl + mat-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-st">float</span> sum = <span class="pl-c1">0</span>;  

    <span class="pl-k">for</span> (<span class="pl-st">unsigned</span> <span class="pl-st">int</span> j = <span class="pl-c1">0</span>; j &lt; mat-&gt;rows; j++)   
        <span class="pl-k">for</span> (<span class="pl-st">unsigned</span> <span class="pl-st">int</span> i = <span class="pl-c1">0</span>; i &lt; mat-&gt;cols; i++)   
            sum += <span class="pl-s3">Mat</span>(j,i);  
    <span class="pl-k">for</span> ( j = <span class="pl-c1">0</span>; j &lt; mat-&gt;rows; j++)   
        <span class="pl-k">for</span> (<span class="pl-st">unsigned</span> <span class="pl-st">int</span> i = <span class="pl-c1">0</span>; i &lt; mat-&gt;rows; i++)   
            <span class="pl-s3">Mat</span>(j,i) /= sum;  
}  

<span class="pl-c">//向量归一化  </span>
<span class="pl-st">void</span> <span class="pl-en">normalizeVec</span>(<span class="pl-st">float</span>* vec, <span class="pl-st">int</span> dim)   
{  
    <span class="pl-st">unsigned</span> <span class="pl-st">int</span> i;  
    <span class="pl-st">float</span> sum = <span class="pl-c1">0</span>;  
    <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; dim; i++)  
        sum += vec[i];  
    <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; dim; i++)  
        vec[i] /= sum;  
}  

<span class="pl-c">//得到向量的欧式长度，2-范数  </span>
<span class="pl-st">float</span> <span class="pl-en">GetVecNorm</span>( <span class="pl-st">float</span>* vec, <span class="pl-st">int</span> dim )  
{  
    <span class="pl-st">float</span> sum=<span class="pl-c1">0.0</span>;  
    <span class="pl-k">for</span> (<span class="pl-st">unsigned</span> <span class="pl-st">int</span> i=<span class="pl-c1">0</span>;i&lt;dim;i++)  
        sum+=vec[i]*vec[i];  
    <span class="pl-k">return</span> <span class="pl-s3">sqrt</span>(sum);  
}  

<span class="pl-c">//产生1D高斯核  </span>
<span class="pl-st">float</span>* <span class="pl-en">GaussianKernel1D</span>(<span class="pl-st">float</span> sigma, <span class="pl-st">int</span> dim)   
{  

    <span class="pl-st">unsigned</span> <span class="pl-st">int</span> i;  
    <span class="pl-c">//printf("GaussianKernel1D(): Creating 1x%d vector for sigma=%.3f gaussian kernel/n", dim, sigma);  </span>

    <span class="pl-st">float</span> *kern=(<span class="pl-st">float</span>*)<span class="pl-s3">malloc</span>( dim*<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) );  
    <span class="pl-st">float</span> s2 = sigma * sigma;  
    <span class="pl-st">int</span> c = dim / <span class="pl-c1">2</span>;  
    <span class="pl-st">float</span> m= <span class="pl-c1">1.0</span>/(<span class="pl-s3">sqrt</span>(<span class="pl-c1">2.0</span> * CV_PI) * sigma);  
    <span class="pl-st">double</span> v;   
    <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; (dim + <span class="pl-c1">1</span>) / <span class="pl-c1">2</span>; i++)   
    {  
        v = m * <span class="pl-s3">exp</span>(-(<span class="pl-c1">1.0</span>*i*i)/(<span class="pl-c1">2.0</span> * s2)) ;  
        kern[c+i] = v;  
        kern[c-i] = v;  
    }  
    <span class="pl-c">//   normalizeVec(kern, dim);  </span>
    <span class="pl-c">// for ( i = 0; i &lt; dim; i++)  </span>
    <span class="pl-c">//  printf("%f  ", kern[i]);  </span>
    <span class="pl-c">//  printf("/n");  </span>
    <span class="pl-k">return</span> kern;  
}  

<span class="pl-c">//产生2D高斯核矩阵  </span>
CvMat* <span class="pl-en">GaussianKernel2D</span>(<span class="pl-st">float</span> sigma)   
{  
    <span class="pl-c">// int dim = (int) max(3.0f, GAUSSKERN * sigma);  </span>
    <span class="pl-st">int</span> dim = (<span class="pl-st">int</span>) <span class="pl-s3">max</span>(<span class="pl-c1">3</span>.<span class="pl-c1">0f</span>, <span class="pl-c1">2.0</span> * GAUSSKERN *sigma + <span class="pl-c1">1</span>.<span class="pl-c1">0f</span>);  
    <span class="pl-c">// make dim odd  </span>
    <span class="pl-k">if</span> (dim % <span class="pl-c1">2</span> == <span class="pl-c1">0</span>)  
        dim++;  
    <span class="pl-c">//printf("GaussianKernel(): Creating %dx%d matrix for sigma=%.3f gaussian/n", dim, dim, sigma);  </span>
    CvMat* mat=<span class="pl-s3">cvCreateMat</span>(dim, dim, CV_32FC1);  
#<span class="pl-k">define</span> <span class="pl-en">Mat</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(mat-&gt;data.fl + mat-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-st">float</span> s2 = sigma * sigma;  
    <span class="pl-st">int</span> c = dim / <span class="pl-c1">2</span>;  
    <span class="pl-c">//printf("%d %d/n", mat.size(), mat[0].size());  </span>
    <span class="pl-st">float</span> m= <span class="pl-c1">1.0</span>/(<span class="pl-s3">sqrt</span>(<span class="pl-c1">2.0</span> * CV_PI) * sigma);  
    <span class="pl-k">for</span> (<span class="pl-st">int</span> i = <span class="pl-c1">0</span>; i &lt; (dim + <span class="pl-c1">1</span>) / <span class="pl-c1">2</span>; i++)   
    {  
        <span class="pl-k">for</span> (<span class="pl-st">int</span> j = <span class="pl-c1">0</span>; j &lt; (dim + <span class="pl-c1">1</span>) / <span class="pl-c1">2</span>; j++)   
        {  
            <span class="pl-c">//printf("%d %d %d/n", c, i, j);  </span>
            <span class="pl-st">float</span> v = m * <span class="pl-s3">exp</span>(-(<span class="pl-c1">1.0</span>*i*i + <span class="pl-c1">1.0</span>*j*j) / (<span class="pl-c1">2.0</span> * s2));  
            <span class="pl-s3">Mat</span>(c+i,c+j) =v;  
            <span class="pl-s3">Mat</span>(c-i,c+j) =v;  
            <span class="pl-s3">Mat</span>(c+i,c-j) =v;  
            <span class="pl-s3">Mat</span>(c-i,c-j) =v;  
        }  
    }  
    <span class="pl-c">// normalizeMat(mat);  </span>
    <span class="pl-k">return</span> mat;  
}  

<span class="pl-c">//x方向像素处作卷积  </span>
<span class="pl-st">float</span> <span class="pl-en">ConvolveLocWidth</span>(<span class="pl-st">float</span>* kernel, <span class="pl-st">int</span> dim, CvMat * src, <span class="pl-st">int</span> x, <span class="pl-st">int</span> y)   
{  
#<span class="pl-k">define</span> <span class="pl-en">Src</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(src-&gt;data.fl + src-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-st">unsigned</span> <span class="pl-st">int</span> i;  
    <span class="pl-st">float</span> pixel = <span class="pl-c1">0</span>;  
    <span class="pl-st">int</span> col;  
    <span class="pl-st">int</span> cen = dim / <span class="pl-c1">2</span>;  
    <span class="pl-c">//printf("ConvolveLoc(): Applying convoluation at location (%d, %d)/n", x, y);  </span>
    <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; dim; i++)   
    {  
        col = x + (i - cen);  
        <span class="pl-k">if</span> (col &lt; <span class="pl-c1">0</span>)  
            col = <span class="pl-c1">0</span>;  
        <span class="pl-k">if</span> (col &gt;= src-&gt;cols)  
            col = src-&gt;cols - <span class="pl-c1">1</span>;  
        pixel += kernel[i] * <span class="pl-s3">Src</span>(y,col);  
    }  
    <span class="pl-k">if</span> (pixel &gt; <span class="pl-c1">1</span>)  
        pixel = <span class="pl-c1">1</span>;  
    <span class="pl-k">return</span> pixel;  
}  

<span class="pl-c">//x方向作卷积  </span>
<span class="pl-st">void</span> <span class="pl-en">Convolve1DWidth</span>(<span class="pl-st">float</span>* kern, <span class="pl-st">int</span> dim, CvMat * src, CvMat * dst)   
{  
#<span class="pl-k">define</span> <span class="pl-en">DST</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(dst-&gt;data.fl + dst-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-st">unsigned</span> <span class="pl-st">int</span> i,j;  

    <span class="pl-k">for</span> ( j = <span class="pl-c1">0</span>; j &lt; src-&gt;rows; j++)   
    {  
        <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; src-&gt;cols; i++)   
        {  
            <span class="pl-c">//printf("%d, %d/n", i, j);  </span>
            <span class="pl-s3">DST</span>(j,i) = <span class="pl-s3">ConvolveLocWidth</span>(kern, dim, src, i, j);  
        }  
    }  
}  

<span class="pl-c">//y方向像素处作卷积  </span>
<span class="pl-st">float</span> <span class="pl-en">ConvolveLocHeight</span>(<span class="pl-st">float</span>* kernel, <span class="pl-st">int</span> dim, CvMat * src, <span class="pl-st">int</span> x, <span class="pl-st">int</span> y)   
{  
#<span class="pl-k">define</span> <span class="pl-en">Src</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(src-&gt;data.fl + src-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-st">unsigned</span> <span class="pl-st">int</span> j;  
    <span class="pl-st">float</span> pixel = <span class="pl-c1">0</span>;  
    <span class="pl-st">int</span> cen = dim / <span class="pl-c1">2</span>;  
    <span class="pl-c">//printf("ConvolveLoc(): Applying convoluation at location (%d, %d)/n", x, y);  </span>
    <span class="pl-k">for</span> ( j = <span class="pl-c1">0</span>; j &lt; dim; j++)   
    {  
        <span class="pl-st">int</span> row = y + (j - cen);  
        <span class="pl-k">if</span> (row &lt; <span class="pl-c1">0</span>)  
            row = <span class="pl-c1">0</span>;  
        <span class="pl-k">if</span> (row &gt;= src-&gt;rows)  
            row = src-&gt;rows - <span class="pl-c1">1</span>;  
        pixel += kernel[j] * <span class="pl-s3">Src</span>(row,x);  
    }  
    <span class="pl-k">if</span> (pixel &gt; <span class="pl-c1">1</span>)  
        pixel = <span class="pl-c1">1</span>;  
    <span class="pl-k">return</span> pixel;  
}  

<span class="pl-c">//y方向作卷积  </span>
<span class="pl-st">void</span> <span class="pl-en">Convolve1DHeight</span>(<span class="pl-st">float</span>* kern, <span class="pl-st">int</span> dim, CvMat * src, CvMat * dst)   
{  
#<span class="pl-k">define</span> <span class="pl-en">Dst</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(dst-&gt;data.fl + dst-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-st">unsigned</span> <span class="pl-st">int</span> i,j;  
    <span class="pl-k">for</span> ( j = <span class="pl-c1">0</span>; j &lt; src-&gt;rows; j++)   
    {  
        <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; src-&gt;cols; i++)   
        {  
            <span class="pl-c">//printf("%d, %d/n", i, j);  </span>
            <span class="pl-s3">Dst</span>(j,i) = <span class="pl-s3">ConvolveLocHeight</span>(kern, dim, src, i, j);  
        }  
    }  
}  

<span class="pl-c">//卷积模糊图像  </span>
<span class="pl-st">int</span> <span class="pl-en">BlurImage</span>(CvMat * src, CvMat * dst, <span class="pl-st">float</span> sigma)   
{  
    <span class="pl-st">float</span>* convkernel;  
    <span class="pl-st">int</span> dim = (<span class="pl-st">int</span>) <span class="pl-s3">max</span>(<span class="pl-c1">3</span>.<span class="pl-c1">0f</span>, <span class="pl-c1">2.0</span> * GAUSSKERN * sigma + <span class="pl-c1">1</span>.<span class="pl-c1">0f</span>);  
    CvMat *tempMat;  
    <span class="pl-c">// make dim odd  </span>
    <span class="pl-k">if</span> (dim % <span class="pl-c1">2</span> == <span class="pl-c1">0</span>)  
        dim++;  
    tempMat = <span class="pl-s3">cvCreateMat</span>(src-&gt;rows, src-&gt;cols, CV_32FC1);  
    convkernel = <span class="pl-s3">GaussianKernel1D</span>(sigma, dim);  

    <span class="pl-s3">Convolve1DWidth</span>(convkernel, dim, src, tempMat);  
    <span class="pl-s3">Convolve1DHeight</span>(convkernel, dim, tempMat, dst);  
    <span class="pl-s3">cvReleaseMat</span>(&amp;tempMat);  
    <span class="pl-k">return</span> dim;  
} </pre>
  </div>
  <h3>
   <a aria-hidden="true" class="anchor" href="#%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4" id="user-content-五个步骤">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    五个步骤
   </strong>
  </h3>
  <p>
   ok，接下来，进入重点部分，咱们依据上文介绍的sift算法的几个步骤，来一一实现这些函数。
  </p>
  <p>
   为了版述清晰，再贴一下，主函数，顺便再加强下对sift 算法的五个步骤的认识：
  </p>
  <p>
   1、 SIFT算法第一步：图像预处理
  </p>
  <p>
   CvMat *ScaleInitImage(CvMat * im) ;                  //金字塔初始化
  </p>
  <p>
   2、 SIFT算法第二步：建立高斯金字塔函数
  </p>
  <p>
   ImageOctaves* BuildGaussianOctaves(CvMat * image) ;  //建立高斯金字塔
  </p>
  <p>
   3、 SIFT算法第三步：特征点位置检测，最后确定特征点的位置
  </p>
  <p>
   int DetectKeypoint(int numoctaves, ImageOctaves *GaussianPyr);
  </p>
  <p>
   4、 SIFT算法第四步：计算高斯图像的梯度方向和幅值，计算各个特征点的主方向
  </p>
  <p>
   void ComputeGrad_DirecandMag(int numoctaves, ImageOctaves *GaussianPyr);
  </p>
  <p>
   5、 SIFT算法第五步：抽取各个特征点处的特征描述字
  </p>
  <p>
   void ExtractFeatureDescriptors(int numoctaves, ImageOctaves *GaussianPyr);
  </p>
  <p>
   ok，接下来一一具体实现这几个函数：
  </p>
  <h4>
   <a aria-hidden="true" class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E6%AD%A5" id="user-content-sift算法第一步">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第一步
   </strong>
  </h4>
  <p>
   SIFT算法第一步：扩大图像，预滤波剔除噪声，得到金字塔的最底层-第一阶的第一层：
  </p>
  <div class="highlight highlight-c">
   <pre>CvMat *<span class="pl-en">ScaleInitImage</span>(CvMat * im)   
{  
    <span class="pl-st">double</span> sigma,preblur_sigma;  
    CvMat *imMat;  
    CvMat * dst;  
    CvMat *tempMat;  
    <span class="pl-c">//首先对图像进行平滑滤波，抑制噪声  </span>
    imMat = <span class="pl-s3">cvCreateMat</span>(im-&gt;rows, im-&gt;cols, CV_32FC1);  
    <span class="pl-s3">BlurImage</span>(im, imMat, INITSIGMA);  
    <span class="pl-c">//针对两种情况分别进行处理：初始化放大原始图像或者在原图像基础上进行后续操作  </span>
    <span class="pl-c">//建立金字塔的最底层  </span>
    <span class="pl-k">if</span> (DOUBLE_BASE_IMAGE_SIZE)   
    {  
        tempMat = <span class="pl-s3">doubleSizeImage2</span>(imMat);<span class="pl-c">//对扩大两倍的图像进行二次采样，采样率为0.5，采用线性插值  </span>
#<span class="pl-k">define</span> <span class="pl-en">TEMPMAT</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(tempMat-&gt;data.fl + tempMat-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) * (ROW)))[(COL)]  

        dst = <span class="pl-s3">cvCreateMat</span>(tempMat-&gt;rows, tempMat-&gt;cols, CV_32FC1);  
        preblur_sigma = <span class="pl-c1">1.0</span>;<span class="pl-c">//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span>
        <span class="pl-s3">BlurImage</span>(tempMat, dst, preblur_sigma);   

        <span class="pl-c">// The initial blurring for the first image of the first octave of the pyramid.  </span>
        sigma = <span class="pl-s3">sqrt</span>( (<span class="pl-c1">4</span>*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  
        <span class="pl-c">//  sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4);  </span>
        <span class="pl-c">//printf("Init Sigma: %f/n", sigma);  </span>
        <span class="pl-s3">BlurImage</span>(dst, tempMat, sigma);       <span class="pl-c">//得到金字塔的最底层-放大2倍的图像  </span>
        <span class="pl-s3">cvReleaseMat</span>( &amp;dst );   
        <span class="pl-k">return</span> tempMat;  
    }   
    <span class="pl-k">else</span>   
    {  
        dst = <span class="pl-s3">cvCreateMat</span>(im-&gt;rows, im-&gt;cols, CV_32FC1);  
        <span class="pl-c">//sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA);  </span>
        preblur_sigma = <span class="pl-c1">1.0</span>;<span class="pl-c">//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span>
        sigma = <span class="pl-s3">sqrt</span>( (<span class="pl-c1">4</span>*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  
        <span class="pl-c">//printf("Init Sigma: %f/n", sigma);  </span>
        <span class="pl-s3">BlurImage</span>(imMat, dst, sigma);        <span class="pl-c">//得到金字塔的最底层：原始图像大小  </span>
        <span class="pl-k">return</span> dst;  
    }   
}</pre>
  </div>
  <h4>
   <a aria-hidden="true" class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AD%A5" id="user-content-sift算法第二步">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第二步
   </strong>
  </h4>
  <p>
   SIFT第二步，建立Gaussian金字塔，给定金字塔第一阶第一层图像后，计算高斯金字塔其他尺度图像，
每一阶的数目由变量SCALESPEROCTAVE决定，给定一个基本图像，计算它的高斯金字塔图像，返回外部向量是阶梯指针，内部向量是每一个阶梯内部的不同尺度图像。
  </p>
  <div class="highlight highlight-c">
   <pre><span class="pl-c">//SIFT算法第二步  </span>
ImageOctaves* <span class="pl-en">BuildGaussianOctaves</span>(CvMat * image)   
{  
    ImageOctaves *octaves;  
    CvMat *tempMat;  
    CvMat *dst;  
    CvMat *temp;  

    <span class="pl-st">int</span> i,j;  
    <span class="pl-st">double</span> k = <span class="pl-s3">pow</span>(<span class="pl-c1">2</span>, <span class="pl-c1">1.0</span>/((<span class="pl-st">float</span>)SCALESPEROCTAVE));  <span class="pl-c">//方差倍数  </span>
    <span class="pl-st">float</span> preblur_sigma, initial_sigma , sigma1,sigma2,sigma,absolute_sigma,sigma_f;  
    <span class="pl-c">//计算金字塔的阶梯数目  </span>
    <span class="pl-st">int</span> dim = <span class="pl-s3">min</span>(image-&gt;rows, image-&gt;cols);  
    <span class="pl-st">int</span> numoctaves = (<span class="pl-st">int</span>) (<span class="pl-s3">log</span>((<span class="pl-st">double</span>) dim) / <span class="pl-s3">log</span>(<span class="pl-c1">2.0</span>)) - <span class="pl-c1">2</span>;    <span class="pl-c">//金字塔阶数  </span>
    <span class="pl-c">//限定金字塔的阶梯数  </span>
    numoctaves = <span class="pl-s3">min</span>(numoctaves, MAXOCTAVES);  
    <span class="pl-c">//为高斯金塔和DOG金字塔分配内存  </span>
    octaves=(ImageOctaves*) <span class="pl-s3">malloc</span>( numoctaves * <span class="pl-k">sizeof</span>(ImageOctaves) );  
    DOGoctaves=(ImageOctaves*) <span class="pl-s3">malloc</span>( numoctaves * <span class="pl-k">sizeof</span>(ImageOctaves) );  

    <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span>BuildGaussianOctaves(): Base image dimension is <span class="pl-c1">%d</span>x<span class="pl-c1">%d</span>/n<span class="pl-pds">"</span></span>, (<span class="pl-st">int</span>)(<span class="pl-c1">0.5</span>*(image-&gt;cols)), (<span class="pl-st">int</span>)(<span class="pl-c1">0.5</span>*(image-&gt;rows)) );  
    <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span>BuildGaussianOctaves(): Building <span class="pl-c1">%d</span> octaves/n<span class="pl-pds">"</span></span>, numoctaves);  

    <span class="pl-c">// start with initial source image  </span>
    tempMat=<span class="pl-s3">cvCloneMat</span>( image );  
    <span class="pl-c">// preblur_sigma = 1.0;//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span>
    initial_sigma = <span class="pl-s3">sqrt</span>(<span class="pl-c1">2</span>);<span class="pl-c">//sqrt( (4*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  </span>
    <span class="pl-c">//   initial_sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4);  </span>

    <span class="pl-c">//在每一阶金字塔图像中建立不同的尺度图像  </span>
    <span class="pl-k">for</span> ( i = <span class="pl-c1">0</span>; i &lt; numoctaves; i++)   
    {     
        <span class="pl-c">//首先建立金字塔每一阶梯的最底层，其中0阶梯的最底层已经建立好  </span>
        <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span>Building octave <span class="pl-c1">%d</span> of dimesion (<span class="pl-c1">%d</span>, <span class="pl-c1">%d</span>)/n<span class="pl-pds">"</span></span>, i, tempMat-&gt;cols,tempMat-&gt;rows);  
        <span class="pl-c">//为各个阶梯分配内存  </span>
        octaves[i].<span class="pl-vo">Octave</span>= (ImageLevels*) <span class="pl-s3">malloc</span>( (SCALESPEROCTAVE + <span class="pl-c1">3</span>) * <span class="pl-k">sizeof</span>(ImageLevels) );  
        DOGoctaves[i].<span class="pl-vo">Octave</span>= (ImageLevels*) <span class="pl-s3">malloc</span>( (SCALESPEROCTAVE + <span class="pl-c1">2</span>) * <span class="pl-k">sizeof</span>(ImageLevels) );  
        <span class="pl-c">//存储各个阶梯的最底层  </span>
        (octaves[i].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">Level</span>=tempMat;  

        octaves[i].<span class="pl-vo">col</span>=tempMat-&gt;cols;  
        octaves[i].<span class="pl-vo">row</span>=tempMat-&gt;rows;  
        DOGoctaves[i].<span class="pl-vo">col</span>=tempMat-&gt;cols;  
        DOGoctaves[i].<span class="pl-vo">row</span>=tempMat-&gt;rows;  
        <span class="pl-k">if</span> (DOUBLE_BASE_IMAGE_SIZE)  
            octaves[i].<span class="pl-vo">subsample</span>=<span class="pl-s3">pow</span>(<span class="pl-c1">2</span>,i)*<span class="pl-c1">0.5</span>;  
        <span class="pl-k">else</span>  
            octaves[i].<span class="pl-vo">subsample</span>=<span class="pl-s3">pow</span>(<span class="pl-c1">2</span>,i);  

        <span class="pl-k">if</span>(i==<span class="pl-c1">0</span>)       
        {  
            (octaves[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">levelsigma</span> = initial_sigma;  
            (octaves[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">absolute_sigma</span> = initial_sigma;  
            <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span>0 scale and blur sigma : <span class="pl-c1">%f</span> /n<span class="pl-pds">"</span></span>, (octaves[<span class="pl-c1">0</span>].<span class="pl-vo">subsample</span>) * ((octaves[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">absolute_sigma</span>));  
        }  
        <span class="pl-k">else</span>  
        {  
            (octaves[i].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">levelsigma</span> = (octaves[i-<span class="pl-c1">1</span>].<span class="pl-vo">Octave</span>)[SCALESPEROCTAVE].<span class="pl-vo">levelsigma</span>;  
            (octaves[i].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">absolute_sigma</span> = (octaves[i-<span class="pl-c1">1</span>].<span class="pl-vo">Octave</span>)[SCALESPEROCTAVE].<span class="pl-vo">absolute_sigma</span>;  
            <span class="pl-s3">printf</span>( <span class="pl-s1"><span class="pl-pds">"</span>0 scale and blur sigma : <span class="pl-c1">%f</span> /n<span class="pl-pds">"</span></span>, ((octaves[i].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">absolute_sigma</span>) );  
        }  
        sigma = initial_sigma;  
        <span class="pl-c">//建立本阶梯其他层的图像  </span>
        <span class="pl-k">for</span> ( j =  <span class="pl-c1">1</span>; j &lt; SCALESPEROCTAVE + <span class="pl-c1">3</span>; j++)   
        {  
            dst = <span class="pl-s3">cvCreateMat</span>(tempMat-&gt;rows, tempMat-&gt;cols, CV_32FC1);<span class="pl-c">//用于存储高斯层  </span>
            temp = <span class="pl-s3">cvCreateMat</span>(tempMat-&gt;rows, tempMat-&gt;cols, CV_32FC1);<span class="pl-c">//用于存储DOG层  </span>
            <span class="pl-c">// 2 passes of 1D on original  </span>
            <span class="pl-c">//   if(i!=0)  </span>
            <span class="pl-c">//   {  </span>
            <span class="pl-c">//       sigma1 = pow(k, j - 1) * ((octaves[i-1].Octave)[j-1].levelsigma);  </span>
            <span class="pl-c">//          sigma2 = pow(k, j) * ((octaves[i].Octave)[j-1].levelsigma);  </span>
            <span class="pl-c">//       sigma = sqrt(sigma2*sigma2 - sigma1*sigma1);  </span>
            sigma_f= <span class="pl-s3">sqrt</span>(k*k-<span class="pl-c1">1</span>)*sigma;  
            <span class="pl-c">//   }  </span>
            <span class="pl-c">//   else  </span>
            <span class="pl-c">//   {  </span>
            <span class="pl-c">//       sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4)*pow(k,j);  </span>
            <span class="pl-c">//   }    </span>
            sigma = k*sigma;  
            absolute_sigma = sigma * (octaves[i].<span class="pl-vo">subsample</span>);  
            <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span><span class="pl-c1">%d</span> scale and Blur sigma: <span class="pl-c1">%f</span>  /n<span class="pl-pds">"</span></span>, j, absolute_sigma);  

            (octaves[i].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">levelsigma</span> = sigma;  
            (octaves[i].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">absolute_sigma</span> = absolute_sigma;  
            <span class="pl-c">//产生高斯层  </span>
            <span class="pl-st">int</span> length=<span class="pl-s3">BlurImage</span>((octaves[i].<span class="pl-vo">Octave</span>)[j-<span class="pl-c1">1</span>].<span class="pl-vo">Level</span>, dst, sigma_f);<span class="pl-c">//相应尺度  </span>
            (octaves[i].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">levelsigmalength</span> = length;  
            (octaves[i].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">Level</span>=dst;  
            <span class="pl-c">//产生DOG层  </span>
            <span class="pl-s3">cvSub</span>( ((octaves[i].<span class="pl-vo">Octave</span>)[j]).<span class="pl-vo">Level</span>, ((octaves[i].<span class="pl-vo">Octave</span>)[j-<span class="pl-c1">1</span>]).<span class="pl-vo">Level</span>, temp, <span class="pl-c1">0</span> );  
            <span class="pl-c">//         cvAbsDiff( ((octaves[i].Octave)[j]).Level, ((octaves[i].Octave)[j-1]).Level, temp );  </span>
            ((DOGoctaves[i].<span class="pl-vo">Octave</span>)[j-<span class="pl-c1">1</span>]).<span class="pl-vo">Level</span>=temp;  
        }  
        <span class="pl-c">// halve the image size for next iteration  </span>
        tempMat  = <span class="pl-s3">halfSizeImage</span>( ( (octaves[i].<span class="pl-vo">Octave</span>)[SCALESPEROCTAVE].<span class="pl-vo">Level</span> ) );  
    }  
    <span class="pl-k">return</span> octaves;  
}</pre>
  </div>
  <h4>
   <a aria-hidden="true" class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%89%E6%AD%A5" id="user-content-sift算法第三步">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第三步
   </strong>
  </h4>
  <p>
   SIFT算法第三步，特征点位置检测，最后确定特征点的位置检测DOG金字塔中的局部最大值，找到之后，还要经过两个检验才能确认为特征点：一是它必须有明显的差异，二是他不应该是边缘点，（也就是说，在极值点处的主曲率比应该小于某一个阈值）。
  </p>
  <div class="highlight highlight-c">
   <pre><span class="pl-c">//SIFT算法第三步，特征点位置检测，  </span>
<span class="pl-st">int</span> <span class="pl-en">DetectKeypoint</span>(<span class="pl-st">int</span> numoctaves, ImageOctaves *GaussianPyr)  
{  
    <span class="pl-c">//计算用于DOG极值点检测的主曲率比的阈值  </span>
    <span class="pl-st">double</span> curvature_threshold;  
    curvature_threshold= ((CURVATURE_THRESHOLD + <span class="pl-c1">1</span>)*(CURVATURE_THRESHOLD + <span class="pl-c1">1</span>))/CURVATURE_THRESHOLD;  
#<span class="pl-k">define</span> <span class="pl-en">ImLevels</span>(<span class="pl-v">OCTAVE,LEVEL,ROW,COL</span>) ((<span class="pl-st">float</span> *)(DOGoctaves[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + DOGoctaves[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  

    <span class="pl-st">int</span>   keypoint_count = <span class="pl-c1">0</span>;     
    <span class="pl-k">for</span> (<span class="pl-st">int</span> i=<span class="pl-c1">0</span>; i&lt;numoctaves; i++)    
    {          
        <span class="pl-k">for</span>(<span class="pl-st">int</span> j=<span class="pl-c1">1</span>;j&lt;SCALESPEROCTAVE+<span class="pl-c1">1</span>;j++)<span class="pl-c">//取中间的scaleperoctave个层  </span>
        {    
            <span class="pl-c">//在图像的有效区域内寻找具有显著性特征的局部最大值  </span>
            <span class="pl-c">//float sigma=(GaussianPyr[i].Octave)[j].levelsigma;  </span>
            <span class="pl-c">//int dim = (int) (max(3.0f, 2.0*GAUSSKERN *sigma + 1.0f)*0.5);  </span>
            <span class="pl-st">int</span> dim = (<span class="pl-st">int</span>)(<span class="pl-c1">0.5</span>*((GaussianPyr[i].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">levelsigmalength</span>)+<span class="pl-c1">0.5</span>);  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> m=dim;m&lt;((DOGoctaves[i].<span class="pl-vo">row</span>)-dim);m++)   
                <span class="pl-k">for</span>(<span class="pl-st">int</span> n=dim;n&lt;((DOGoctaves[i].<span class="pl-vo">col</span>)-dim);n++)  
                {       
                    <span class="pl-k">if</span> ( <span class="pl-s3">fabs</span>(<span class="pl-s3">ImLevels</span>(i,j,m,n))&gt;= CONTRAST_THRESHOLD )  
                    {  

                        <span class="pl-k">if</span> ( <span class="pl-s3">ImLevels</span>(i,j,m,n)!=<span class="pl-c1">0.0</span> )  <span class="pl-c">//1、首先是非零  </span>
                        {  
                            <span class="pl-st">float</span> inf_val=<span class="pl-s3">ImLevels</span>(i,j,m,n);  
                            <span class="pl-k">if</span>(( (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m  ,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m  ,n  ))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m  ,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;    <span class="pl-c">//底层的小尺度9  </span>

                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j,m  ,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j,m  ,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;     <span class="pl-c">//当前层8  </span>

                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m  ,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m  ,n  ))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m  ,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &lt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))     <span class="pl-c">//下一层大尺度9          </span>
                                ) ||   
                                ( (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m  ,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m  ,n  ))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m  ,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j-<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;  

                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j,m  ,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j,m  ,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;   

                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m  ,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m  ,n  ))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n  ))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m-<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m  ,n+<span class="pl-c1">1</span>))&amp;&amp;  
                                (inf_val &gt;= <span class="pl-s3">ImLevels</span>(i,j+<span class="pl-c1">1</span>,m+<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>))   
                                ) )      <span class="pl-c">//2、满足26个中极值点  </span>
                            {     
                                <span class="pl-c">//此处可存储  </span>
                                <span class="pl-c">//然后必须具有明显的显著性，即必须大于CONTRAST_THRESHOLD=0.02  </span>
                                <span class="pl-k">if</span> ( <span class="pl-s3">fabs</span>(<span class="pl-s3">ImLevels</span>(i,j,m,n))&gt;= CONTRAST_THRESHOLD )  
                                {  
                                    <span class="pl-c">//最后显著处的特征点必须具有足够的曲率比，CURVATURE_THRESHOLD=10.0，首先计算Hessian矩阵  </span>
                                    <span class="pl-c">// Compute the entries of the Hessian matrix at the extrema location.  </span>
                                    <span class="pl-c">/* </span>
<span class="pl-c">                                    1   0   -1 </span>
<span class="pl-c">                                    0   0   0 </span>
<span class="pl-c">                                    -1   0   1         *0.25 </span>
<span class="pl-c">                                    */</span>  
                                    <span class="pl-c">// Compute the trace and the determinant of the Hessian.  </span>
                                    <span class="pl-c">//Tr_H = Dxx + Dyy;  </span>
                                    <span class="pl-c">//Det_H = Dxx*Dyy - Dxy^2;  </span>
                                    <span class="pl-st">float</span> Dxx,Dyy,Dxy,Tr_H,Det_H,curvature_ratio;  
                                    Dxx = <span class="pl-s3">ImLevels</span>(i,j,m,n-<span class="pl-c1">1</span>) + <span class="pl-s3">ImLevels</span>(i,j,m,n+<span class="pl-c1">1</span>)-<span class="pl-c1">2.0</span>*<span class="pl-s3">ImLevels</span>(i,j,m,n);  
                                    Dyy = <span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n) + <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n)-<span class="pl-c1">2.0</span>*<span class="pl-s3">ImLevels</span>(i,j,m,n);  
                                    Dxy = <span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>) + <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>) - <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n-<span class="pl-c1">1</span>) - <span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n+<span class="pl-c1">1</span>);  
                                    Tr_H = Dxx + Dyy;  
                                    Det_H = Dxx*Dyy - Dxy*Dxy;  
                                    <span class="pl-c">// Compute the ratio of the principal curvatures.  </span>
                                    curvature_ratio = (<span class="pl-c1">1.0</span>*Tr_H*Tr_H)/Det_H;  
                                    <span class="pl-k">if</span> ( (Det_H&gt;=<span class="pl-c1">0.0</span>) &amp;&amp; (curvature_ratio &lt;= curvature_threshold) )  <span class="pl-c">//最后得到最具有显著性特征的特征点  </span>
                                    {  
                                        <span class="pl-c">//将其存储起来，以计算后面的特征描述字  </span>
                                        keypoint_count++;  
                                        Keypoint k;  
                                        <span class="pl-c">/* Allocate memory for the keypoint. */</span>  
                                        k = (Keypoint) <span class="pl-s3">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-st">struct</span> KeypointSt));  
                                        k-&gt;next = keypoints;  
                                        keypoints = k;  
                                        k-&gt;row = m*(GaussianPyr[i].<span class="pl-vo">subsample</span>);  
                                        k-&gt;col =n*(GaussianPyr[i].<span class="pl-vo">subsample</span>);  
                                        k-&gt;sy = m;    <span class="pl-c">//行  </span>
                                        k-&gt;sx = n;    <span class="pl-c">//列  </span>
                                        k-&gt;octave=i;  
                                        k-&gt;level=j;  
                                        k-&gt;scale = (GaussianPyr[i].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">absolute_sigma</span>;        
                                    }<span class="pl-c">//if &gt;curvature_thresh  </span>
                                }<span class="pl-c">//if &gt;contrast  </span>
                            }<span class="pl-c">//if inf value  </span>
                        }<span class="pl-c">//if non zero  </span>
                    }<span class="pl-c">//if &gt;contrast  </span>
                }  <span class="pl-c">//for concrete image level col  </span>
        }<span class="pl-c">//for levels  </span>
    }<span class="pl-c">//for octaves  </span>
    <span class="pl-k">return</span> keypoint_count;  
}  

<span class="pl-c">//在图像中，显示SIFT特征点的位置  </span>
<span class="pl-st">void</span> <span class="pl-en">DisplayKeypointLocation</span>(IplImage* image, ImageOctaves *GaussianPyr)  
{  

    Keypoint p = keypoints; <span class="pl-c">// p指向第一个结点  </span>
    <span class="pl-k">while</span>(p) <span class="pl-c">// 没到表尾  </span>
    {     
        <span class="pl-s3">cvLine</span>( image, <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)((p-&gt;col)-<span class="pl-c1">3</span>),(<span class="pl-st">int</span>)(p-&gt;row)),   
            <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)((p-&gt;col)+<span class="pl-c1">3</span>),(<span class="pl-st">int</span>)(p-&gt;row)), <span class="pl-s3">CV_RGB</span>(<span class="pl-c1">255</span>,<span class="pl-c1">255</span>,<span class="pl-c1">0</span>),  
            <span class="pl-c1">1</span>, <span class="pl-c1">8</span>, <span class="pl-c1">0</span> );  
        <span class="pl-s3">cvLine</span>( image, <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)(p-&gt;col),(<span class="pl-st">int</span>)((p-&gt;row)-<span class="pl-c1">3</span>)),   
            <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)(p-&gt;col),(<span class="pl-st">int</span>)((p-&gt;row)+<span class="pl-c1">3</span>)), <span class="pl-s3">CV_RGB</span>(<span class="pl-c1">255</span>,<span class="pl-c1">255</span>,<span class="pl-c1">0</span>),  
            <span class="pl-c1">1</span>, <span class="pl-c1">8</span>, <span class="pl-c1">0</span> );  
        <span class="pl-c">//  cvCircle(image,cvPoint((uchar)(p-&gt;col),(uchar)(p-&gt;row)),  </span>
        <span class="pl-c">//   (int)((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level].absolute_sigma),  </span>
        <span class="pl-c">//   CV_RGB(255,0,0),1,8,0);  </span>
        p=p-&gt;next;  
    }   
}  

<span class="pl-c">// Compute the gradient direction and magnitude of the gaussian pyramid images  </span>
<span class="pl-st">void</span> <span class="pl-en">ComputeGrad_DirecandMag</span>(<span class="pl-st">int</span> numoctaves, ImageOctaves *GaussianPyr)  
{  
    <span class="pl-c">// ImageOctaves *mag_thresh ;  </span>
    mag_pyr=(ImageOctaves*) <span class="pl-s3">malloc</span>( numoctaves * <span class="pl-k">sizeof</span>(ImageOctaves) );  
    grad_pyr=(ImageOctaves*) <span class="pl-s3">malloc</span>( numoctaves * <span class="pl-k">sizeof</span>(ImageOctaves) );  
    <span class="pl-c">// float sigma=( (GaussianPyr[0].Octave)[SCALESPEROCTAVE+2].absolute_sigma ) / GaussianPyr[0].subsample;  </span>
    <span class="pl-c">// int dim = (int) (max(3.0f, 2 * GAUSSKERN *sigma + 1.0f)*0.5+0.5);  </span>
#<span class="pl-k">define</span> <span class="pl-en">ImLevels</span>(<span class="pl-v">OCTAVE,LEVEL,ROW,COL</span>) ((<span class="pl-st">float</span> *)(GaussianPyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + GaussianPyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-k">for</span> (<span class="pl-st">int</span> i=<span class="pl-c1">0</span>; i&lt;numoctaves; i++)    
    {          
        mag_pyr[i].<span class="pl-vo">Octave</span>= (ImageLevels*) <span class="pl-s3">malloc</span>( (SCALESPEROCTAVE) * <span class="pl-k">sizeof</span>(ImageLevels) );  
        grad_pyr[i].<span class="pl-vo">Octave</span>= (ImageLevels*) <span class="pl-s3">malloc</span>( (SCALESPEROCTAVE) * <span class="pl-k">sizeof</span>(ImageLevels) );  
        <span class="pl-k">for</span>(<span class="pl-st">int</span> j=<span class="pl-c1">1</span>;j&lt;SCALESPEROCTAVE+<span class="pl-c1">1</span>;j++)<span class="pl-c">//取中间的scaleperoctave个层  </span>
        {    
            CvMat *Mag = <span class="pl-s3">cvCreateMat</span>(GaussianPyr[i].<span class="pl-vo">row</span>, GaussianPyr[i].<span class="pl-vo">col</span>, CV_32FC1);  
            CvMat *Ori = <span class="pl-s3">cvCreateMat</span>(GaussianPyr[i].<span class="pl-vo">row</span>, GaussianPyr[i].<span class="pl-vo">col</span>, CV_32FC1);  
            CvMat *tempMat1 = <span class="pl-s3">cvCreateMat</span>(GaussianPyr[i].<span class="pl-vo">row</span>, GaussianPyr[i].<span class="pl-vo">col</span>, CV_32FC1);  
            CvMat *tempMat2 = <span class="pl-s3">cvCreateMat</span>(GaussianPyr[i].<span class="pl-vo">row</span>, GaussianPyr[i].<span class="pl-vo">col</span>, CV_32FC1);  
            <span class="pl-s3">cvZero</span>(Mag);  
            <span class="pl-s3">cvZero</span>(Ori);  
            <span class="pl-s3">cvZero</span>(tempMat1);  
            <span class="pl-s3">cvZero</span>(tempMat2);   
#<span class="pl-k">define</span> <span class="pl-en">MAG</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(Mag-&gt;data.fl + Mag-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]     
#<span class="pl-k">define</span> <span class="pl-en">ORI</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(Ori-&gt;data.fl + Ori-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]    
#<span class="pl-k">define</span> <span class="pl-en">TEMPMAT1</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(tempMat1-&gt;data.fl + tempMat1-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
#<span class="pl-k">define</span> <span class="pl-en">TEMPMAT2</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(tempMat2-&gt;data.fl + tempMat2-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> m=<span class="pl-c1">1</span>;m&lt;(GaussianPyr[i].<span class="pl-vo">row</span>-<span class="pl-c1">1</span>);m++)   
                <span class="pl-k">for</span>(<span class="pl-st">int</span> n=<span class="pl-c1">1</span>;n&lt;(GaussianPyr[i].<span class="pl-vo">col</span>-<span class="pl-c1">1</span>);n++)  
                {  
                    <span class="pl-c">//计算幅值  </span>
                    <span class="pl-s3">TEMPMAT1</span>(m,n) = <span class="pl-c1">0.5</span>*( <span class="pl-s3">ImLevels</span>(i,j,m,n+<span class="pl-c1">1</span>)-<span class="pl-s3">ImLevels</span>(i,j,m,n-<span class="pl-c1">1</span>) );  <span class="pl-c">//dx  </span>
                    <span class="pl-s3">TEMPMAT2</span>(m,n) = <span class="pl-c1">0.5</span>*( <span class="pl-s3">ImLevels</span>(i,j,m+<span class="pl-c1">1</span>,n)-<span class="pl-s3">ImLevels</span>(i,j,m-<span class="pl-c1">1</span>,n) );  <span class="pl-c">//dy  </span>
                    <span class="pl-s3">MAG</span>(m,n) = <span class="pl-s3">sqrt</span>(<span class="pl-s3">TEMPMAT1</span>(m,n)*<span class="pl-s3">TEMPMAT1</span>(m,n)+<span class="pl-s3">TEMPMAT2</span>(m,n)*<span class="pl-s3">TEMPMAT2</span>(m,n));  <span class="pl-c">//mag  </span>
                    <span class="pl-c">//计算方向  </span>
                    <span class="pl-s3">ORI</span>(m,n) =<span class="pl-s3">atan</span>( <span class="pl-s3">TEMPMAT2</span>(m,n)/<span class="pl-s3">TEMPMAT1</span>(m,n) );  
                    <span class="pl-k">if</span> (<span class="pl-s3">ORI</span>(m,n)==CV_PI)  
                        <span class="pl-s3">ORI</span>(m,n)=-CV_PI;  
                }  
                ((mag_pyr[i].<span class="pl-vo">Octave</span>)[j-<span class="pl-c1">1</span>]).<span class="pl-vo">Level</span>=Mag;  
                ((grad_pyr[i].<span class="pl-vo">Octave</span>)[j-<span class="pl-c1">1</span>]).<span class="pl-vo">Level</span>=Ori;  
                <span class="pl-s3">cvReleaseMat</span>(&amp;tempMat1);  
                <span class="pl-s3">cvReleaseMat</span>(&amp;tempMat2);  
        }<span class="pl-c">//for levels  </span>
    }<span class="pl-c">//for octaves  </span>
}</pre>
  </div>
  <h4>
   <a aria-hidden="true" class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E6%AD%A5" id="user-content-sift算法第四步">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第四步
   </strong>
  </h4>
  <div class="highlight highlight-c">
   <pre><span class="pl-c">//SIFT算法第四步：计算各个特征点的主方向，确定主方向  </span>
<span class="pl-st">void</span> <span class="pl-en">AssignTheMainOrientation</span>(<span class="pl-st">int</span> numoctaves, ImageOctaves *GaussianPyr,ImageOctaves *mag_pyr,ImageOctaves *grad_pyr)  
{  
    <span class="pl-c">// Set up the histogram bin centers for a 36 bin histogram.  </span>
    <span class="pl-st">int</span> num_bins = <span class="pl-c1">36</span>;  
    <span class="pl-st">float</span> hist_step = <span class="pl-c1">2.0</span>*PI/num_bins;  
    <span class="pl-st">float</span> hist_orient[<span class="pl-c1">36</span>];  
    <span class="pl-k">for</span> (<span class="pl-st">int</span> i=<span class="pl-c1">0</span>;i&lt;<span class="pl-c1">36</span>;i++)  
        hist_orient[i]=-PI+i*hist_step;  
    <span class="pl-st">float</span> sigma1=( ((GaussianPyr[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[SCALESPEROCTAVE].<span class="pl-vo">absolute_sigma</span>) ) / (GaussianPyr[<span class="pl-c1">0</span>].<span class="pl-vo">subsample</span>);<span class="pl-c">//SCALESPEROCTAVE+2  </span>
    <span class="pl-st">int</span> zero_pad = (<span class="pl-st">int</span>) (<span class="pl-s3">max</span>(<span class="pl-c1">3</span>.<span class="pl-c1">0f</span>, <span class="pl-c1">2</span> * GAUSSKERN *sigma1 + <span class="pl-c1">1</span>.<span class="pl-c1">0f</span>)*<span class="pl-c1">0.5</span>+<span class="pl-c1">0.5</span>);  
    <span class="pl-c">//Assign orientations to the keypoints.  </span>
#<span class="pl-k">define</span> <span class="pl-en">ImLevels</span>(<span class="pl-v">OCTAVES,LEVELS,ROW,COL</span>) ((<span class="pl-st">float</span> *)((GaussianPyr[(OCTAVES)].Octave[(LEVELS)].Level)-&gt;data.fl + (GaussianPyr[(OCTAVES)].Octave[(LEVELS)].Level)-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  

    <span class="pl-st">int</span> keypoint_count = <span class="pl-c1">0</span>;  
    Keypoint p = keypoints; <span class="pl-c">// p指向第一个结点  </span>

    <span class="pl-k">while</span>(p) <span class="pl-c">// 没到表尾  </span>
    {  
        <span class="pl-st">int</span> i=p-&gt;octave;  
        <span class="pl-st">int</span> j=p-&gt;level;  
        <span class="pl-st">int</span> m=p-&gt;sy;   <span class="pl-c">//行  </span>
        <span class="pl-st">int</span> n=p-&gt;sx;   <span class="pl-c">//列  </span>
        <span class="pl-k">if</span> ((m&gt;=zero_pad)&amp;&amp;(m&lt;GaussianPyr[i].<span class="pl-vo">row</span>-zero_pad)&amp;&amp;  
            (n&gt;=zero_pad)&amp;&amp;(n&lt;GaussianPyr[i].<span class="pl-vo">col</span>-zero_pad) )  
        {  
            <span class="pl-st">float</span> sigma=( ((GaussianPyr[i].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">absolute_sigma</span>) ) / (GaussianPyr[i].<span class="pl-vo">subsample</span>);  
            <span class="pl-c">//产生二维高斯模板  </span>
            CvMat* mat = <span class="pl-s3">GaussianKernel2D</span>( sigma );           
            <span class="pl-st">int</span> dim=(<span class="pl-st">int</span>)(<span class="pl-c1">0.5</span> * (mat-&gt;rows));  
            <span class="pl-c">//分配用于存储Patch幅值和方向的空间  </span>
#<span class="pl-k">define</span> <span class="pl-en">MAT</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(mat-&gt;data.fl + mat-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  

            <span class="pl-c">//声明方向直方图变量  </span>
            <span class="pl-st">double</span>* orienthist = (<span class="pl-st">double</span> *) <span class="pl-s3">malloc</span>(<span class="pl-c1">36</span> * <span class="pl-k">sizeof</span>(<span class="pl-st">double</span>));  
            <span class="pl-k">for</span> ( <span class="pl-st">int</span> sw = <span class="pl-c1">0</span> ; sw &lt; <span class="pl-c1">36</span> ; ++sw)   
            {  
                orienthist[sw]=<span class="pl-c1">0.0</span>;    
            }  
            <span class="pl-c">//在特征点的周围统计梯度方向  </span>
            <span class="pl-k">for</span> (<span class="pl-st">int</span> x=m-dim,mm=<span class="pl-c1">0</span>;x&lt;=(m+dim);x++,mm++)   
                <span class="pl-k">for</span>(<span class="pl-st">int</span> y=n-dim,nn=<span class="pl-c1">0</span>;y&lt;=(n+dim);y++,nn++)  
                {       
                    <span class="pl-c">//计算特征点处的幅值  </span>
                    <span class="pl-st">double</span> dx = <span class="pl-c1">0.5</span>*(<span class="pl-s3">ImLevels</span>(i,j,x,y+<span class="pl-c1">1</span>)-<span class="pl-s3">ImLevels</span>(i,j,x,y-<span class="pl-c1">1</span>));  <span class="pl-c">//dx  </span>
                    <span class="pl-st">double</span> dy = <span class="pl-c1">0.5</span>*(<span class="pl-s3">ImLevels</span>(i,j,x+<span class="pl-c1">1</span>,y)-<span class="pl-s3">ImLevels</span>(i,j,x-<span class="pl-c1">1</span>,y));  <span class="pl-c">//dy  </span>
                    <span class="pl-st">double</span> mag = <span class="pl-s3">sqrt</span>(dx*dx+dy*dy);  <span class="pl-c">//mag  </span>
                    <span class="pl-c">//计算方向  </span>
                    <span class="pl-st">double</span> Ori =<span class="pl-s3">atan</span>( <span class="pl-c1">1.0</span>*dy/dx );  
                    <span class="pl-st">int</span> binIdx = <span class="pl-s3">FindClosestRotationBin</span>(<span class="pl-c1">36</span>, Ori);                   <span class="pl-c">//得到离现有方向最近的直方块  </span>
                    orienthist[binIdx] = orienthist[binIdx] + <span class="pl-c1">1.0</span>* mag * <span class="pl-s3">MAT</span>(mm,nn);<span class="pl-c">//利用高斯加权累加进直方图相应的块  </span>
                }  
                <span class="pl-c">// Find peaks in the orientation histogram using nonmax suppression.  </span>
                <span class="pl-s3">AverageWeakBins</span> (orienthist, <span class="pl-c1">36</span>);  
                <span class="pl-c">// find the maximum peak in gradient orientation  </span>
                <span class="pl-st">double</span> maxGrad = <span class="pl-c1">0.0</span>;  
                <span class="pl-st">int</span> maxBin = <span class="pl-c1">0</span>;  
                <span class="pl-k">for</span> (<span class="pl-st">int</span> b = <span class="pl-c1">0</span> ; b &lt; <span class="pl-c1">36</span> ; ++b)   
                {  
                    <span class="pl-k">if</span> (orienthist[b] &gt; maxGrad)   
                    {  
                        maxGrad = orienthist[b];  
                        maxBin = b;  
                    }  
                }  
                <span class="pl-c">// First determine the real interpolated peak high at the maximum bin  </span>
                <span class="pl-c">// position, which is guaranteed to be an absolute peak.  </span>
                <span class="pl-st">double</span> maxPeakValue=<span class="pl-c1">0.0</span>;  
                <span class="pl-st">double</span> maxDegreeCorrection=<span class="pl-c1">0.0</span>;  
                <span class="pl-k">if</span> ( (<span class="pl-s3">InterpolateOrientation</span> ( orienthist[maxBin == <span class="pl-c1">0</span> ? (<span class="pl-c1">36</span> - <span class="pl-c1">1</span>) : (maxBin - <span class="pl-c1">1</span>)],  
                    orienthist[maxBin], orienthist[(maxBin + <span class="pl-c1">1</span>) % <span class="pl-c1">36</span>],  
                    &amp;maxDegreeCorrection, &amp;maxPeakValue)) == <span class="pl-c1">false</span>)  
                    <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span>BUG: Parabola fitting broken<span class="pl-pds">"</span></span>);  

                <span class="pl-c">// Now that we know the maximum peak value, we can find other keypoint  </span>
                <span class="pl-c">// orientations, which have to fulfill two criterias:  </span>
                <span class="pl-c">//  </span>
                <span class="pl-c">//  1. They must be a local peak themselves. Else we might add a very  </span>
                <span class="pl-c">//     similar keypoint orientation twice (imagine for example the  </span>
                <span class="pl-c">//     values: 0.4 1.0 0.8, if 1.0 is maximum peak, 0.8 is still added  </span>
                <span class="pl-c">//     with the default threshhold, but the maximum peak orientation  </span>
                <span class="pl-c">//     was already added).  </span>
                <span class="pl-c">//  2. They must have at least peakRelThresh times the maximum peak  </span>
                <span class="pl-c">//     value.  </span>
                <span class="pl-st">bool</span> binIsKeypoint[<span class="pl-c1">36</span>];  
                <span class="pl-k">for</span> ( b = <span class="pl-c1">0</span> ; b &lt; <span class="pl-c1">36</span> ; ++b)   
                {  
                    binIsKeypoint[b] = <span class="pl-c1">false</span>;  
                    <span class="pl-c">// The maximum peak of course is  </span>
                    <span class="pl-k">if</span> (b == maxBin)   
                    {  
                        binIsKeypoint[b] = <span class="pl-c1">true</span>;  
                        <span class="pl-k">continue</span>;  
                    }  
                    <span class="pl-c">// Local peaks are, too, in case they fulfill the threshhold  </span>
                    <span class="pl-k">if</span> (orienthist[b] &lt; (peakRelThresh * maxPeakValue))  
                        <span class="pl-k">continue</span>;  
                    <span class="pl-st">int</span> leftI = (b == <span class="pl-c1">0</span>) ? (<span class="pl-c1">36</span> - <span class="pl-c1">1</span>) : (b - <span class="pl-c1">1</span>);  
                    <span class="pl-st">int</span> rightI = (b + <span class="pl-c1">1</span>) % <span class="pl-c1">36</span>;  
                    <span class="pl-k">if</span> (orienthist[b] &lt;= orienthist[leftI] || orienthist[b] &lt;= orienthist[rightI])  
                        <span class="pl-k">continue</span>; <span class="pl-c">// no local peak  </span>
                    binIsKeypoint[b] = <span class="pl-c1">true</span>;  
                }  
                <span class="pl-c">// find other possible locations  </span>
                <span class="pl-st">double</span> oneBinRad = (<span class="pl-c1">2.0</span> * PI) / <span class="pl-c1">36</span>;  
                <span class="pl-k">for</span> ( b = <span class="pl-c1">0</span> ; b &lt; <span class="pl-c1">36</span> ; ++b)   
                {  
                    <span class="pl-k">if</span> (binIsKeypoint[b] == <span class="pl-c1">false</span>)  
                        <span class="pl-k">continue</span>;  
                    <span class="pl-st">int</span> bLeft = (b == <span class="pl-c1">0</span>) ? (<span class="pl-c1">36</span> - <span class="pl-c1">1</span>) : (b - <span class="pl-c1">1</span>);  
                    <span class="pl-st">int</span> bRight = (b + <span class="pl-c1">1</span>) % <span class="pl-c1">36</span>;  
                    <span class="pl-c">// Get an interpolated peak direction and value guess.  </span>
                    <span class="pl-st">double</span> peakValue;  
                    <span class="pl-st">double</span> degreeCorrection;  

                    <span class="pl-st">double</span> maxPeakValue, maxDegreeCorrection;                
                    <span class="pl-k">if</span> (<span class="pl-s3">InterpolateOrientation</span> ( orienthist[maxBin == <span class="pl-c1">0</span> ? (<span class="pl-c1">36</span> - <span class="pl-c1">1</span>) : (maxBin - <span class="pl-c1">1</span>)],  
                        orienthist[maxBin], orienthist[(maxBin + <span class="pl-c1">1</span>) % <span class="pl-c1">36</span>],  
                        °reeCorrection, &amp;peakValue) == <span class="pl-c1">false</span>)  
                    {  
                        <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span>BUG: Parabola fitting broken<span class="pl-pds">"</span></span>);  
                    }  

                    <span class="pl-st">double</span> degree = (b + degreeCorrection) * oneBinRad - PI;  
                    <span class="pl-k">if</span> (degree &lt; -PI)  
                        degree += <span class="pl-c1">2.0</span> * PI;  
                    <span class="pl-k">else</span> <span class="pl-k">if</span> (degree &gt; PI)  
                        degree -= <span class="pl-c1">2.0</span> * PI;  
                    <span class="pl-c">//存储方向，可以直接利用检测到的链表进行该步主方向的指定;  </span>
                    <span class="pl-c">//分配内存重新存储特征点  </span>
                    Keypoint k;  
                    <span class="pl-c">/* Allocate memory for the keypoint Descriptor. */</span>  
                    k = (Keypoint) <span class="pl-s3">malloc</span>(<span class="pl-k">sizeof</span>(<span class="pl-st">struct</span> KeypointSt));  
                    k-&gt;next = keyDescriptors;  
                    keyDescriptors = k;  
                    k-&gt;descrip = (<span class="pl-st">float</span>*)<span class="pl-s3">malloc</span>(LEN * <span class="pl-k">sizeof</span>(<span class="pl-st">float</span>));  
                    k-&gt;row = p-&gt;row;  
                    k-&gt;col = p-&gt;col;  
                    k-&gt;sy = p-&gt;sy;    <span class="pl-c">//行  </span>
                    k-&gt;sx = p-&gt;sx;    <span class="pl-c">//列  </span>
                    k-&gt;octave = p-&gt;octave;  
                    k-&gt;level = p-&gt;level;  
                    k-&gt;scale = p-&gt;scale;        
                    k-&gt;ori = degree;  
                    k-&gt;mag = peakValue;    
                }<span class="pl-c">//for  </span>
                <span class="pl-s3">free</span>(orienthist);  
        }  
        p=p-&gt;next;  
    }   
}  

<span class="pl-c">//寻找与方向直方图最近的柱，确定其index   </span>
<span class="pl-st">int</span> <span class="pl-en">FindClosestRotationBin</span> (<span class="pl-st">int</span> binCount, <span class="pl-st">float</span> angle)  
{  
    angle += CV_PI;  
    angle /= <span class="pl-c1">2.0</span> * CV_PI;  
    <span class="pl-c">// calculate the aligned bin  </span>
    angle *= binCount;  
    <span class="pl-st">int</span> idx = (<span class="pl-st">int</span>) angle;  
    <span class="pl-k">if</span> (idx == binCount)  
        idx = <span class="pl-c1">0</span>;  
    <span class="pl-k">return</span> (idx);  
}  

<span class="pl-c">// Average the content of the direction bins.  </span>
<span class="pl-st">void</span> <span class="pl-en">AverageWeakBins</span> (<span class="pl-st">double</span>* hist, <span class="pl-st">int</span> binCount)  
{  
    <span class="pl-c">// TODO: make some tests what number of passes is the best. (its clear  </span>
    <span class="pl-c">// one is not enough, as we may have something like  </span>
    <span class="pl-c">// ( 0.4, 0.4, 0.3, 0.4, 0.4 ))  </span>
    <span class="pl-k">for</span> (<span class="pl-st">int</span> sn = <span class="pl-c1">0</span> ; sn &lt; <span class="pl-c1">2</span> ; ++sn)   
    {  
        <span class="pl-st">double</span> firstE = hist[<span class="pl-c1">0</span>];  
        <span class="pl-st">double</span> last = hist[binCount-<span class="pl-c1">1</span>];  
        <span class="pl-k">for</span> (<span class="pl-st">int</span> sw = <span class="pl-c1">0</span> ; sw &lt; binCount ; ++sw)   
        {  
            <span class="pl-st">double</span> cur = hist[sw];  
            <span class="pl-st">double</span> next = (sw == (binCount - <span class="pl-c1">1</span>)) ? firstE : hist[(sw + <span class="pl-c1">1</span>) % binCount];  
            hist[sw] = (last + cur + next) / <span class="pl-c1">3.0</span>;  
            last = cur;  
        }  
    }  
}  

<span class="pl-c">// Fit a parabol to the three points (-1.0 ; left), (0.0 ; middle) and  </span>
<span class="pl-c">// (1.0 ; right).  </span>
<span class="pl-c">// Formulas:  </span>
<span class="pl-c">// f(x) = a (x - c)^2 + b  </span>
<span class="pl-c">// c is the peak offset (where f'(x) is zero), b is the peak value.  </span>
<span class="pl-c">// In case there is an error false is returned, otherwise a correction  </span>
<span class="pl-c">// value between [-1 ; 1] is returned in 'degreeCorrection', where -1  </span>
<span class="pl-c">// means the peak is located completely at the left vector, and -0.5 just  </span>
<span class="pl-c">// in the middle between left and middle and &gt; 0 to the right side. In  </span>
<span class="pl-c">// 'peakValue' the maximum estimated peak value is stored.  </span>
<span class="pl-st">bool</span> <span class="pl-en">InterpolateOrientation</span> (<span class="pl-st">double</span> left, <span class="pl-st">double</span> middle,<span class="pl-st">double</span> right, <span class="pl-st">double</span> *degreeCorrection, <span class="pl-st">double</span> *peakValue)  
{  
    <span class="pl-st">double</span> a = ((left + right) - <span class="pl-c1">2.0</span> * middle) / <span class="pl-c1">2.0</span>;   <span class="pl-c">//抛物线捏合系数a  </span>
    <span class="pl-c">// degreeCorrection = peakValue = Double.NaN;  </span>

    <span class="pl-c">// Not a parabol  </span>
    <span class="pl-k">if</span> (a == <span class="pl-c1">0.0</span>)  
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;  
    <span class="pl-st">double</span> c = (((left - middle) / a) - <span class="pl-c1">1.0</span>) / <span class="pl-c1">2.0</span>;  
    <span class="pl-st">double</span> b = middle - c * c * a;  
    <span class="pl-k">if</span> (c &lt; -<span class="pl-c1">0.5</span> || c &gt; <span class="pl-c1">0.5</span>)  
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;  
    *degreeCorrection = c;  
    *peakValue = b;  
    <span class="pl-k">return</span> <span class="pl-c1">true</span>;  
}  

<span class="pl-c">//显示特征点处的主方向  </span>
<span class="pl-st">void</span> <span class="pl-en">DisplayOrientation</span> (IplImage* image, ImageOctaves *GaussianPyr)  
{  
    Keypoint p = keyDescriptors; <span class="pl-c">// p指向第一个结点  </span>
    <span class="pl-k">while</span>(p) <span class="pl-c">// 没到表尾  </span>
    {  
        <span class="pl-st">float</span> scale=(GaussianPyr[p-&gt;octave].<span class="pl-vo">Octave</span>)[p-&gt;level].<span class="pl-vo">absolute_sigma</span>;  
        <span class="pl-st">float</span> autoscale = <span class="pl-c1">3.0</span>;   
        <span class="pl-st">float</span> uu=autoscale*scale*<span class="pl-s3">cos</span>(p-&gt;ori);  
        <span class="pl-st">float</span> vv=autoscale*scale*<span class="pl-s3">sin</span>(p-&gt;ori);  
        <span class="pl-st">float</span> x=(p-&gt;col)+uu;  
        <span class="pl-st">float</span> y=(p-&gt;row)+vv;  
        <span class="pl-s3">cvLine</span>( image, <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)(p-&gt;col),(<span class="pl-st">int</span>)(p-&gt;row)),   
            <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)x,(<span class="pl-st">int</span>)y), <span class="pl-s3">CV_RGB</span>(<span class="pl-c1">255</span>,<span class="pl-c1">255</span>,<span class="pl-c1">0</span>),  
            <span class="pl-c1">1</span>, <span class="pl-c1">8</span>, <span class="pl-c1">0</span> );  
        <span class="pl-c">// Arrow head parameters  </span>
        <span class="pl-st">float</span> alpha = <span class="pl-c1">0.33</span>; <span class="pl-c">// Size of arrow head relative to the length of the vector  </span>
        <span class="pl-st">float</span> beta = <span class="pl-c1">0.33</span>;  <span class="pl-c">// Width of the base of the arrow head relative to the length  </span>

        <span class="pl-st">float</span> xx0= (p-&gt;col)+uu-alpha*(uu+beta*vv);  
        <span class="pl-st">float</span> yy0= (p-&gt;row)+vv-alpha*(vv-beta*uu);  
        <span class="pl-st">float</span> xx1= (p-&gt;col)+uu-alpha*(uu-beta*vv);  
        <span class="pl-st">float</span> yy1= (p-&gt;row)+vv-alpha*(vv+beta*uu);  
        <span class="pl-s3">cvLine</span>( image, <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)xx0,(<span class="pl-st">int</span>)yy0),   
            <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)x,(<span class="pl-st">int</span>)y), <span class="pl-s3">CV_RGB</span>(<span class="pl-c1">255</span>,<span class="pl-c1">255</span>,<span class="pl-c1">0</span>),  
            <span class="pl-c1">1</span>, <span class="pl-c1">8</span>, <span class="pl-c1">0</span> );  
        <span class="pl-s3">cvLine</span>( image, <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)xx1,(<span class="pl-st">int</span>)yy1),   
            <span class="pl-s3">cvPoint</span>((<span class="pl-st">int</span>)x,(<span class="pl-st">int</span>)y), <span class="pl-s3">CV_RGB</span>(<span class="pl-c1">255</span>,<span class="pl-c1">255</span>,<span class="pl-c1">0</span>),  
            <span class="pl-c1">1</span>, <span class="pl-c1">8</span>, <span class="pl-c1">0</span> );  
        p=p-&gt;next;  
    }   
}</pre>
  </div>
  <h4>
   <a aria-hidden="true" class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%94%E6%AD%A5" id="user-content-sift算法第五步">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第五步
   </strong>
  </h4>
  <p>
   SIFT算法第五步：抽取各个特征点处的特征描述字，确定特征点的描述字。描述字是Patch网格内梯度方向的描述，旋转网格到主方向，插值得到网格处梯度值。
  </p>
  <p>
   一个特征点可以用2
   <em>
    2
   </em>
   8=32维的向量，也可以用4
   <em>
    4
   </em>
   8=128维的向量更精确的进行描述。
  </p>
  <div class="highlight highlight-c">
   <pre><span class="pl-st">void</span> <span class="pl-en">ExtractFeatureDescriptors</span>(<span class="pl-st">int</span> numoctaves, ImageOctaves *GaussianPyr)  
{  
    <span class="pl-c">// The orientation histograms have 8 bins  </span>
    <span class="pl-st">float</span> orient_bin_spacing = PI/<span class="pl-c1">4</span>;  
    <span class="pl-st">float</span> orient_angles[<span class="pl-c1">8</span>]={-PI,-PI+orient_bin_spacing,-PI*<span class="pl-c1">0.5</span>, -orient_bin_spacing,  
        <span class="pl-c1">0.0</span>, orient_bin_spacing, PI*<span class="pl-c1">0.5</span>,  PI+orient_bin_spacing};  
    <span class="pl-c">//产生描述字中心各点坐标  </span>
    <span class="pl-st">float</span> *feat_grid=(<span class="pl-st">float</span> *) <span class="pl-s3">malloc</span>( <span class="pl-c1">2</span>*<span class="pl-c1">16</span> * <span class="pl-k">sizeof</span>(<span class="pl-st">float</span>));  
    <span class="pl-k">for</span> (<span class="pl-st">int</span> i=<span class="pl-c1">0</span>;i&lt;GridSpacing;i++)  
    {  
        <span class="pl-k">for</span> (<span class="pl-st">int</span> j=<span class="pl-c1">0</span>;j&lt;<span class="pl-c1">2</span>*GridSpacing;++j,++j)  
        {  
            feat_grid[i*<span class="pl-c1">2</span>*GridSpacing+j]=-<span class="pl-c1">6.0</span>+i*GridSpacing;  
            feat_grid[i*<span class="pl-c1">2</span>*GridSpacing+j+<span class="pl-c1">1</span>]=-<span class="pl-c1">6.0</span>+<span class="pl-c1">0.5</span>*j*GridSpacing;  
        }  
    }  
    <span class="pl-c">//产生网格  </span>
    <span class="pl-st">float</span> *feat_samples=(<span class="pl-st">float</span> *) <span class="pl-s3">malloc</span>( <span class="pl-c1">2</span>*<span class="pl-c1">256</span> * <span class="pl-k">sizeof</span>(<span class="pl-st">float</span>));  
    <span class="pl-k">for</span> ( i=<span class="pl-c1">0</span>;i&lt;<span class="pl-c1">4</span>*GridSpacing;i++)  
    {  
        <span class="pl-k">for</span> (<span class="pl-st">int</span> j=<span class="pl-c1">0</span>;j&lt;<span class="pl-c1">8</span>*GridSpacing;j+=<span class="pl-c1">2</span>)  
        {  
            feat_samples[i*<span class="pl-c1">8</span>*GridSpacing+j]=-(<span class="pl-c1">2</span>*GridSpacing-<span class="pl-c1">0.5</span>)+i;  
            feat_samples[i*<span class="pl-c1">8</span>*GridSpacing+j+<span class="pl-c1">1</span>]=-(<span class="pl-c1">2</span>*GridSpacing-<span class="pl-c1">0.5</span>)+<span class="pl-c1">0.5</span>*j;  
        }  
    }  
    <span class="pl-st">float</span> feat_window = <span class="pl-c1">2</span>*GridSpacing;  
    Keypoint p = keyDescriptors; <span class="pl-c">// p指向第一个结点  </span>
    <span class="pl-k">while</span>(p) <span class="pl-c">// 没到表尾  </span>
    {  
        <span class="pl-st">float</span> scale=(GaussianPyr[p-&gt;octave].<span class="pl-vo">Octave</span>)[p-&gt;level].<span class="pl-vo">absolute_sigma</span>;  

        <span class="pl-st">float</span> sine = <span class="pl-s3">sin</span>(p-&gt;ori);  
        <span class="pl-st">float</span> cosine = <span class="pl-s3">cos</span>(p-&gt;ori);    
        <span class="pl-c">//计算中心点坐标旋转之后的位置  </span>
        <span class="pl-st">float</span> *featcenter=(<span class="pl-st">float</span> *) <span class="pl-s3">malloc</span>( <span class="pl-c1">2</span>*<span class="pl-c1">16</span> * <span class="pl-k">sizeof</span>(<span class="pl-st">float</span>));  
        <span class="pl-k">for</span> (<span class="pl-st">int</span> i=<span class="pl-c1">0</span>;i&lt;GridSpacing;i++)  
        {  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> j=<span class="pl-c1">0</span>;j&lt;<span class="pl-c1">2</span>*GridSpacing;j+=<span class="pl-c1">2</span>)  
            {  
                <span class="pl-st">float</span> x=feat_grid[i*<span class="pl-c1">2</span>*GridSpacing+j];  
                <span class="pl-st">float</span> y=feat_grid[i*<span class="pl-c1">2</span>*GridSpacing+j+<span class="pl-c1">1</span>];  
                featcenter[i*<span class="pl-c1">2</span>*GridSpacing+j]=((cosine * x + sine * y) + p-&gt;sx);  
                featcenter[i*<span class="pl-c1">2</span>*GridSpacing+j+<span class="pl-c1">1</span>]=((-sine * x + cosine * y) + p-&gt;sy);  
            }  
        }  
        <span class="pl-c">// calculate sample window coordinates (rotated along keypoint)  </span>
        <span class="pl-st">float</span> *feat=(<span class="pl-st">float</span> *) <span class="pl-s3">malloc</span>( <span class="pl-c1">2</span>*<span class="pl-c1">256</span> * <span class="pl-k">sizeof</span>(<span class="pl-st">float</span>));  
        <span class="pl-k">for</span> ( i=<span class="pl-c1">0</span>;i&lt;<span class="pl-c1">64</span>*GridSpacing;i++,i++)  
        {  
            <span class="pl-st">float</span> x=feat_samples[i];  
            <span class="pl-st">float</span> y=feat_samples[i+<span class="pl-c1">1</span>];  
            feat[i]=((cosine * x + sine * y) + p-&gt;sx);  
            feat[i+<span class="pl-c1">1</span>]=((-sine * x + cosine * y) + p-&gt;sy);  
        }  
        <span class="pl-c">//Initialize the feature descriptor.  </span>
        <span class="pl-st">float</span> *feat_desc = (<span class="pl-st">float</span> *) <span class="pl-s3">malloc</span>( <span class="pl-c1">128</span> * <span class="pl-k">sizeof</span>(<span class="pl-st">float</span>));  
        <span class="pl-k">for</span> (i=<span class="pl-c1">0</span>;i&lt;<span class="pl-c1">128</span>;i++)  
        {  
            feat_desc[i]=<span class="pl-c1">0.0</span>;  
            <span class="pl-c">// printf("%f  ",feat_desc[i]);    </span>
        }  
        <span class="pl-c">//printf("/n");  </span>
        <span class="pl-k">for</span> ( i=<span class="pl-c1">0</span>;i&lt;<span class="pl-c1">512</span>;++i,++i)  
        {  
            <span class="pl-st">float</span> x_sample = feat[i];  
            <span class="pl-st">float</span> y_sample = feat[i+<span class="pl-c1">1</span>];  
            <span class="pl-c">// Interpolate the gradient at the sample position  </span>
            <span class="pl-c">/* </span>
<span class="pl-c">            0   1   0 </span>
<span class="pl-c">            1   *   1 </span>
<span class="pl-c">            0   1   0   具体插值策略如图示 </span>
<span class="pl-c">            */</span>  
            <span class="pl-st">float</span> sample12=<span class="pl-s3">getPixelBI</span>(((GaussianPyr[p-&gt;octave].<span class="pl-vo">Octave</span>)[p-&gt;level]).<span class="pl-vo">Level</span>, x_sample, y_sample-<span class="pl-c1">1</span>);  
            <span class="pl-st">float</span> sample21=<span class="pl-s3">getPixelBI</span>(((GaussianPyr[p-&gt;octave].<span class="pl-vo">Octave</span>)[p-&gt;level]).<span class="pl-vo">Level</span>, x_sample-<span class="pl-c1">1</span>, y_sample);   
            <span class="pl-st">float</span> sample22=<span class="pl-s3">getPixelBI</span>(((GaussianPyr[p-&gt;octave].<span class="pl-vo">Octave</span>)[p-&gt;level]).<span class="pl-vo">Level</span>, x_sample, y_sample);   
            <span class="pl-st">float</span> sample23=<span class="pl-s3">getPixelBI</span>(((GaussianPyr[p-&gt;octave].<span class="pl-vo">Octave</span>)[p-&gt;level]).<span class="pl-vo">Level</span>, x_sample+<span class="pl-c1">1</span>, y_sample);   
            <span class="pl-st">float</span> sample32=<span class="pl-s3">getPixelBI</span>(((GaussianPyr[p-&gt;octave].<span class="pl-vo">Octave</span>)[p-&gt;level]).<span class="pl-vo">Level</span>, x_sample, y_sample+<span class="pl-c1">1</span>);   
            <span class="pl-c">//float diff_x = 0.5*(sample23 - sample21);  </span>
            <span class="pl-c">//float diff_y = 0.5*(sample32 - sample12);  </span>
            <span class="pl-st">float</span> diff_x = sample23 - sample21;  
            <span class="pl-st">float</span> diff_y = sample32 - sample12;  
            <span class="pl-st">float</span> mag_sample = <span class="pl-s3">sqrt</span>( diff_x*diff_x + diff_y*diff_y );  
            <span class="pl-st">float</span> grad_sample = <span class="pl-s3">atan</span>( diff_y / diff_x );  
            <span class="pl-k">if</span>(grad_sample == CV_PI)  
                grad_sample = -CV_PI;  
            <span class="pl-c">// Compute the weighting for the x and y dimensions.  </span>
            <span class="pl-st">float</span> *x_wght=(<span class="pl-st">float</span> *) <span class="pl-s3">malloc</span>( GridSpacing * GridSpacing * <span class="pl-k">sizeof</span>(<span class="pl-st">float</span>));  
            <span class="pl-st">float</span> *y_wght=(<span class="pl-st">float</span> *) <span class="pl-s3">malloc</span>( GridSpacing * GridSpacing * <span class="pl-k">sizeof</span>(<span class="pl-st">float</span>));  
            <span class="pl-st">float</span> *pos_wght=(<span class="pl-st">float</span> *) <span class="pl-s3">malloc</span>( <span class="pl-c1">8</span>*GridSpacing * GridSpacing * <span class="pl-k">sizeof</span>(<span class="pl-st">float</span>));;  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> m=<span class="pl-c1">0</span>;m&lt;<span class="pl-c1">32</span>;++m,++m)  
            {  
                <span class="pl-st">float</span> x=featcenter[m];  
                <span class="pl-st">float</span> y=featcenter[m+<span class="pl-c1">1</span>];  
                x_wght[m/<span class="pl-c1">2</span>] = <span class="pl-s3">max</span>(<span class="pl-c1">1</span> - (<span class="pl-s3">fabs</span>(x - x_sample)*<span class="pl-c1">1.0</span>/GridSpacing), <span class="pl-c1">0</span>);  
                y_wght[m/<span class="pl-c1">2</span>] = <span class="pl-s3">max</span>(<span class="pl-c1">1</span> - (<span class="pl-s3">fabs</span>(y - y_sample)*<span class="pl-c1">1.0</span>/GridSpacing), <span class="pl-c1">0</span>);   

            }  
            <span class="pl-k">for</span> ( m=<span class="pl-c1">0</span>;m&lt;<span class="pl-c1">16</span>;++m)  
                <span class="pl-k">for</span> (<span class="pl-st">int</span> n=<span class="pl-c1">0</span>;n&lt;<span class="pl-c1">8</span>;++n)  
                    pos_wght[m*<span class="pl-c1">8</span>+n]=x_wght[m]*y_wght[m];  
            <span class="pl-s3">free</span>(x_wght);  
            <span class="pl-s3">free</span>(y_wght);  
            <span class="pl-c">//计算方向的加权，首先旋转梯度场到主方向，然后计算差异   </span>
            <span class="pl-st">float</span> diff[<span class="pl-c1">8</span>],orient_wght[<span class="pl-c1">128</span>];  
            <span class="pl-k">for</span> ( m=<span class="pl-c1">0</span>;m&lt;<span class="pl-c1">8</span>;++m)  
            {   
                <span class="pl-st">float</span> angle = grad_sample-(p-&gt;ori)-orient_angles[m]+CV_PI;  
                <span class="pl-st">float</span> temp = angle / (<span class="pl-c1">2.0</span> * CV_PI);  
                angle -= (<span class="pl-st">int</span>)(temp) * (<span class="pl-c1">2.0</span> * CV_PI);  
                diff[m]= angle - CV_PI;  
            }  
            <span class="pl-c">// Compute the gaussian weighting.  </span>
            <span class="pl-st">float</span> x=p-&gt;sx;  
            <span class="pl-st">float</span> y=p-&gt;sy;  
            <span class="pl-st">float</span> g = <span class="pl-s3">exp</span>(-((x_sample-x)*(x_sample-x)+(y_sample-y)*(y_sample-y))/(<span class="pl-c1">2</span>*feat_window*feat_window))/(<span class="pl-c1">2</span>*CV_PI*feat_window*feat_window);  

            <span class="pl-k">for</span> ( m=<span class="pl-c1">0</span>;m&lt;<span class="pl-c1">128</span>;++m)  
            {  
                orient_wght[m] = <span class="pl-s3">max</span>((<span class="pl-c1">1.0</span> - <span class="pl-c1">1.0</span>*<span class="pl-s3">fabs</span>(diff[m%<span class="pl-c1">8</span>])/orient_bin_spacing),<span class="pl-c1">0</span>);  
                feat_desc[m] = feat_desc[m] + orient_wght[m]*pos_wght[m]*g*mag_sample;  
            }  
            <span class="pl-s3">free</span>(pos_wght);     
        }  
        <span class="pl-s3">free</span>(feat);  
        <span class="pl-s3">free</span>(featcenter);  
        <span class="pl-st">float</span> norm=<span class="pl-s3">GetVecNorm</span>( feat_desc, <span class="pl-c1">128</span>);  
        <span class="pl-k">for</span> (<span class="pl-st">int</span> m=<span class="pl-c1">0</span>;m&lt;<span class="pl-c1">128</span>;m++)  
        {  
            feat_desc[m]/=norm;  
            <span class="pl-k">if</span> (feat_desc[m]&gt;<span class="pl-c1">0.2</span>)  
                feat_desc[m]=<span class="pl-c1">0.2</span>;  
        }  
        norm=<span class="pl-s3">GetVecNorm</span>( feat_desc, <span class="pl-c1">128</span>);  
        <span class="pl-k">for</span> ( m=<span class="pl-c1">0</span>;m&lt;<span class="pl-c1">128</span>;m++)  
        {  
            feat_desc[m]/=norm;  
            <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span><span class="pl-c1">%f</span>  <span class="pl-pds">"</span></span>,feat_desc[m]);    
        }  
        <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span>/n<span class="pl-pds">"</span></span>);  
        p-&gt;descrip = feat_desc;  
        p=p-&gt;next;  
    }  
    <span class="pl-s3">free</span>(feat_grid);  
    <span class="pl-s3">free</span>(feat_samples);  
}  

<span class="pl-c">//为了显示图象金字塔，而作的图像水平拼接  </span>
CvMat* <span class="pl-en">MosaicHorizen</span>( CvMat* im1, CvMat* im2 )  
{  
    <span class="pl-st">int</span> row,col;  
    CvMat *mosaic = <span class="pl-s3">cvCreateMat</span>( <span class="pl-s3">max</span>(im1-&gt;rows,im2-&gt;rows),(im1-&gt;cols+im2-&gt;cols),CV_32FC1);  
#<span class="pl-k">define</span> <span class="pl-en">Mosaic</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span>*)(mosaic-&gt;data.fl + mosaic-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>)*(ROW)))[(COL)]  
#<span class="pl-k">define</span> <span class="pl-en">Im11Mat</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(im1-&gt;data.fl + im1-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
#<span class="pl-k">define</span> <span class="pl-en">Im22Mat</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(im2-&gt;data.fl + im2-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-s3">cvZero</span>(mosaic);  
    <span class="pl-c">/* Copy images into mosaic1. */</span>  
    <span class="pl-k">for</span> ( row = <span class="pl-c1">0</span>; row &lt; im1-&gt;rows; row++)  
        <span class="pl-k">for</span> ( col = <span class="pl-c1">0</span>; col &lt; im1-&gt;cols; col++)  
            <span class="pl-s3">Mosaic</span>(row,col)=<span class="pl-s3">Im11Mat</span>(row,col) ;  
    <span class="pl-k">for</span> (  row = <span class="pl-c1">0</span>; row &lt; im2-&gt;rows; row++)  
        <span class="pl-k">for</span> (  col = <span class="pl-c1">0</span>; col &lt; im2-&gt;cols; col++)  
            <span class="pl-s3">Mosaic</span>(row, (col+im1-&gt;cols) )= <span class="pl-s3">Im22Mat</span>(row,col) ;  
    <span class="pl-k">return</span> mosaic;  
}  

<span class="pl-c">//为了显示图象金字塔，而作的图像垂直拼接  </span>
CvMat* <span class="pl-en">MosaicVertical</span>( CvMat* im1, CvMat* im2 )  
{  
    <span class="pl-st">int</span> row,col;  
    CvMat *mosaic = <span class="pl-s3">cvCreateMat</span>(im1-&gt;rows+im2-&gt;rows,<span class="pl-s3">max</span>(im1-&gt;cols,im2-&gt;cols), CV_32FC1);  
#<span class="pl-k">define</span> <span class="pl-en">Mosaic</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span>*)(mosaic-&gt;data.fl + mosaic-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>)*(ROW)))[(COL)]  
#<span class="pl-k">define</span> <span class="pl-en">Im11Mat</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(im1-&gt;data.fl + im1-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
#<span class="pl-k">define</span> <span class="pl-en">Im22Mat</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(im2-&gt;data.fl + im2-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-s3">cvZero</span>(mosaic);  

    <span class="pl-c">/* Copy images into mosaic1. */</span>  
    <span class="pl-k">for</span> ( row = <span class="pl-c1">0</span>; row &lt; im1-&gt;rows; row++)  
        <span class="pl-k">for</span> ( col = <span class="pl-c1">0</span>; col &lt; im1-&gt;cols; col++)  
            <span class="pl-s3">Mosaic</span>(row,col)= <span class="pl-s3">Im11Mat</span>(row,col) ;  
    <span class="pl-k">for</span> ( row = <span class="pl-c1">0</span>; row &lt; im2-&gt;rows; row++)  
        <span class="pl-k">for</span> ( col = <span class="pl-c1">0</span>; col &lt; im2-&gt;cols; col++)  
            <span class="pl-s3">Mosaic</span>((row+im1-&gt;rows),col)=<span class="pl-s3">Im22Mat</span>(row,col) ;  

    <span class="pl-k">return</span> mosaic;  
}</pre>
  </div>
  <p>
   ok，为了版述清晰，再贴一下上文所述的主函数（注，上文已贴出，此是为了版述清晰，重复造轮）：
  </p>
  <div class="highlight highlight-c">
   <pre><span class="pl-st">int</span> <span class="pl-en">main</span>( <span class="pl-st">void</span> )  
{  
    <span class="pl-c">//声明当前帧IplImage指针  </span>
    IplImage* src = <span class="pl-c1">NULL</span>;   
    IplImage* image1 = <span class="pl-c1">NULL</span>;   
    IplImage* grey_im1 = <span class="pl-c1">NULL</span>;   
    IplImage* DoubleSizeImage = <span class="pl-c1">NULL</span>;  

    IplImage* mosaic1 = <span class="pl-c1">NULL</span>;   
    IplImage* mosaic2 = <span class="pl-c1">NULL</span>;   

    CvMat* mosaicHorizen1 = <span class="pl-c1">NULL</span>;  
    CvMat* mosaicHorizen2 = <span class="pl-c1">NULL</span>;  
    CvMat* mosaicVertical1 = <span class="pl-c1">NULL</span>;  

    CvMat* image1Mat = <span class="pl-c1">NULL</span>;  
    CvMat* tempMat=<span class="pl-c1">NULL</span>;  

    ImageOctaves *Gaussianpyr;  
    <span class="pl-st">int</span> rows,cols;  

#<span class="pl-k">define</span> <span class="pl-en">Im1Mat</span>(<span class="pl-v">ROW,COL</span>) ((<span class="pl-st">float</span> *)(image1Mat-&gt;data.fl + image1Mat-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  

    <span class="pl-c">//灰度图象像素的数据结构  </span>
#<span class="pl-k">define</span> <span class="pl-en">Im1B</span>(<span class="pl-v">ROW,COL</span>) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*<span class="pl-c1">3</span>]  
#<span class="pl-k">define</span> <span class="pl-en">Im1G</span>(<span class="pl-v">ROW,COL</span>) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*<span class="pl-c1">3</span>+<span class="pl-c1">1</span>]  
#<span class="pl-k">define</span> <span class="pl-en">Im1R</span>(<span class="pl-v">ROW,COL</span>) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*<span class="pl-c1">3</span>+<span class="pl-c1">2</span>]  

    storage = <span class="pl-s3">cvCreateMemStorage</span>(<span class="pl-c1">0</span>);   

    <span class="pl-c">//读取图片  </span>
    <span class="pl-k">if</span>( (src = <span class="pl-s3">cvLoadImage</span>( <span class="pl-s1"><span class="pl-pds">"</span>street1.jpg<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>)) == <span class="pl-c1">0</span> )  <span class="pl-c">// test1.jpg einstein.pgm back1.bmp  </span>
        <span class="pl-k">return</span> -<span class="pl-c1">1</span>;  

    <span class="pl-c">//为图像分配内存   </span>
    image1 = <span class="pl-s3">cvCreateImage</span>(<span class="pl-s3">cvSize</span>(src-&gt;width, src-&gt;height),  IPL_DEPTH_8U,<span class="pl-c1">3</span>);  
    grey_im1 = <span class="pl-s3">cvCreateImage</span>(<span class="pl-s3">cvSize</span>(src-&gt;width, src-&gt;height),  IPL_DEPTH_8U,<span class="pl-c1">1</span>);  
    DoubleSizeImage = <span class="pl-s3">cvCreateImage</span>(<span class="pl-s3">cvSize</span>(<span class="pl-c1">2</span>*(src-&gt;width), <span class="pl-c1">2</span>*(src-&gt;height)),  IPL_DEPTH_8U,<span class="pl-c1">3</span>);  

    <span class="pl-c">//为图像阵列分配内存，假设两幅图像的大小相同，tempMat跟随image1的大小  </span>
    image1Mat = <span class="pl-s3">cvCreateMat</span>(src-&gt;height, src-&gt;width, CV_32FC1);  
    <span class="pl-c">//转化成单通道图像再处理  </span>
    <span class="pl-s3">cvCvtColor</span>(src, grey_im1, CV_BGR2GRAY);  
    <span class="pl-c">//转换进入Mat数据结构,图像操作使用的是浮点型操作  </span>
    <span class="pl-s3">cvConvert</span>(grey_im1, image1Mat);  

    <span class="pl-st">double</span> t = (<span class="pl-st">double</span>)<span class="pl-s3">cvGetTickCount</span>();  
    <span class="pl-c">//图像归一化  </span>
    <span class="pl-s3">cvConvertScale</span>( image1Mat, image1Mat, <span class="pl-c1">1.0</span>/<span class="pl-c1">255</span>, <span class="pl-c1">0</span> );  

    <span class="pl-st">int</span> dim = <span class="pl-s3">min</span>(image1Mat-&gt;rows, image1Mat-&gt;cols);  
    numoctaves = (<span class="pl-st">int</span>) (<span class="pl-s3">log</span>((<span class="pl-st">double</span>) dim) / <span class="pl-s3">log</span>(<span class="pl-c1">2.0</span>)) - <span class="pl-c1">2</span>;    <span class="pl-c">//金字塔阶数  </span>
    numoctaves = <span class="pl-s3">min</span>(numoctaves, MAXOCTAVES);  

    <span class="pl-c">//SIFT算法第一步，预滤波除噪声，建立金字塔底层  </span>
    tempMat = <span class="pl-s3">ScaleInitImage</span>(image1Mat) ;  
    <span class="pl-c">//SIFT算法第二步，建立Guassian金字塔和DOG金字塔  </span>
    Gaussianpyr = <span class="pl-s3">BuildGaussianOctaves</span>(tempMat) ;  

    t = (<span class="pl-st">double</span>)<span class="pl-s3">cvGetTickCount</span>() - t;  
    <span class="pl-s3">printf</span>( <span class="pl-s1"><span class="pl-pds">"</span>the time of build Gaussian pyramid and DOG pyramid is <span class="pl-c1">%.1f</span>/n<span class="pl-pds">"</span></span>, t/(<span class="pl-s3">cvGetTickFrequency</span>()*<span class="pl-c1">1000</span>.) );  

#<span class="pl-k">define</span> <span class="pl-en">ImLevels</span>(<span class="pl-v">OCTAVE,LEVEL,ROW,COL</span>) ((<span class="pl-st">float</span> *)(Gaussianpyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + Gaussianpyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/<span class="pl-k">sizeof</span>(<span class="pl-st">float</span>) *(ROW)))[(COL)]  
    <span class="pl-c">//显示高斯金字塔  </span>
    <span class="pl-k">for</span> (<span class="pl-st">int</span> i=<span class="pl-c1">0</span>; i&lt;numoctaves;i++)  
    {  
        <span class="pl-k">if</span> (i==<span class="pl-c1">0</span>)  
        {  
            mosaicHorizen1=<span class="pl-s3">MosaicHorizen</span>( (Gaussianpyr[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">Level</span>, (Gaussianpyr[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">1</span>].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> j=<span class="pl-c1">2</span>;j&lt;SCALESPEROCTAVE+<span class="pl-c1">3</span>;j++)  
                mosaicHorizen1=<span class="pl-s3">MosaicHorizen</span>( mosaicHorizen1, (Gaussianpyr[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> ( j=<span class="pl-c1">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen1=<span class="pl-s3">halfSizeImage</span>(mosaicHorizen1);  
        }  
        <span class="pl-k">else</span> <span class="pl-k">if</span> (i==<span class="pl-c1">1</span>)  
        {  
            mosaicHorizen2=<span class="pl-s3">MosaicHorizen</span>( (Gaussianpyr[<span class="pl-c1">1</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">Level</span>, (Gaussianpyr[<span class="pl-c1">1</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">1</span>].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> j=<span class="pl-c1">2</span>;j&lt;SCALESPEROCTAVE+<span class="pl-c1">3</span>;j++)  
                mosaicHorizen2=<span class="pl-s3">MosaicHorizen</span>( mosaicHorizen2, (Gaussianpyr[<span class="pl-c1">1</span>].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> ( j=<span class="pl-c1">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen2=<span class="pl-s3">halfSizeImage</span>(mosaicHorizen2);  
            mosaicVertical1=<span class="pl-s3">MosaicVertical</span>( mosaicHorizen1, mosaicHorizen2 );  
        }  
        <span class="pl-k">else</span>  
        {  
            mosaicHorizen1=<span class="pl-s3">MosaicHorizen</span>( (Gaussianpyr[i].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">Level</span>, (Gaussianpyr[i].<span class="pl-vo">Octave</span>)[<span class="pl-c1">1</span>].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> j=<span class="pl-c1">2</span>;j&lt;SCALESPEROCTAVE+<span class="pl-c1">3</span>;j++)  
                mosaicHorizen1=<span class="pl-s3">MosaicHorizen</span>( mosaicHorizen1, (Gaussianpyr[i].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> ( j=<span class="pl-c1">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen1=<span class="pl-s3">halfSizeImage</span>(mosaicHorizen1);  
            mosaicVertical1=<span class="pl-s3">MosaicVertical</span>( mosaicVertical1, mosaicHorizen1 );  
        }  
    }  
    mosaic1 = <span class="pl-s3">cvCreateImage</span>(<span class="pl-s3">cvSize</span>(mosaicVertical1-&gt;width, mosaicVertical1-&gt;height),  IPL_DEPTH_8U,<span class="pl-c1">1</span>);  
    <span class="pl-s3">cvConvertScale</span>( mosaicVertical1, mosaicVertical1, <span class="pl-c1">255.0</span>, <span class="pl-c1">0</span> );  
    <span class="pl-s3">cvConvertScaleAbs</span>( mosaicVertical1, mosaic1, <span class="pl-c1">1</span>, <span class="pl-c1">0</span> );  

    <span class="pl-c">//  cvSaveImage("GaussianPyramid of me.jpg",mosaic1);  </span>
    <span class="pl-s3">cvNamedWindow</span>(<span class="pl-s1"><span class="pl-pds">"</span>mosaic1<span class="pl-pds">"</span></span>,<span class="pl-c1">1</span>);  
    <span class="pl-s3">cvShowImage</span>(<span class="pl-s1"><span class="pl-pds">"</span>mosaic1<span class="pl-pds">"</span></span>, mosaic1);  
    <span class="pl-s3">cvWaitKey</span>(<span class="pl-c1">0</span>);  
    <span class="pl-s3">cvDestroyWindow</span>(<span class="pl-s1"><span class="pl-pds">"</span>mosaic1<span class="pl-pds">"</span></span>);  
    <span class="pl-c">//显示DOG金字塔  </span>
    <span class="pl-k">for</span> ( i=<span class="pl-c1">0</span>; i&lt;numoctaves;i++)  
    {  
        <span class="pl-k">if</span> (i==<span class="pl-c1">0</span>)  
        {  
            mosaicHorizen1=<span class="pl-s3">MosaicHorizen</span>( (DOGoctaves[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">Level</span>, (DOGoctaves[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">1</span>].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> j=<span class="pl-c1">2</span>;j&lt;SCALESPEROCTAVE+<span class="pl-c1">2</span>;j++)  
                mosaicHorizen1=<span class="pl-s3">MosaicHorizen</span>( mosaicHorizen1, (DOGoctaves[<span class="pl-c1">0</span>].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> ( j=<span class="pl-c1">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen1=<span class="pl-s3">halfSizeImage</span>(mosaicHorizen1);  
        }  
        <span class="pl-k">else</span> <span class="pl-k">if</span> (i==<span class="pl-c1">1</span>)  
        {  
            mosaicHorizen2=<span class="pl-s3">MosaicHorizen</span>( (DOGoctaves[<span class="pl-c1">1</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">Level</span>, (DOGoctaves[<span class="pl-c1">1</span>].<span class="pl-vo">Octave</span>)[<span class="pl-c1">1</span>].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> j=<span class="pl-c1">2</span>;j&lt;SCALESPEROCTAVE+<span class="pl-c1">2</span>;j++)  
                mosaicHorizen2=<span class="pl-s3">MosaicHorizen</span>( mosaicHorizen2, (DOGoctaves[<span class="pl-c1">1</span>].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> ( j=<span class="pl-c1">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen2=<span class="pl-s3">halfSizeImage</span>(mosaicHorizen2);  
            mosaicVertical1=<span class="pl-s3">MosaicVertical</span>( mosaicHorizen1, mosaicHorizen2 );  
        }  
        <span class="pl-k">else</span>  
        {  
            mosaicHorizen1=<span class="pl-s3">MosaicHorizen</span>( (DOGoctaves[i].<span class="pl-vo">Octave</span>)[<span class="pl-c1">0</span>].<span class="pl-vo">Level</span>, (DOGoctaves[i].<span class="pl-vo">Octave</span>)[<span class="pl-c1">1</span>].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> (<span class="pl-st">int</span> j=<span class="pl-c1">2</span>;j&lt;SCALESPEROCTAVE+<span class="pl-c1">2</span>;j++)  
                mosaicHorizen1=<span class="pl-s3">MosaicHorizen</span>( mosaicHorizen1, (DOGoctaves[i].<span class="pl-vo">Octave</span>)[j].<span class="pl-vo">Level</span> );  
            <span class="pl-k">for</span> ( j=<span class="pl-c1">0</span>;j&lt;NUMSIZE;j++)  
                mosaicHorizen1=<span class="pl-s3">halfSizeImage</span>(mosaicHorizen1);  
            mosaicVertical1=<span class="pl-s3">MosaicVertical</span>( mosaicVertical1, mosaicHorizen1 );  
        }  
    }  
    <span class="pl-c">//考虑到DOG金字塔各层图像都会有正负，所以，必须寻找最负的，以将所有图像抬高一个台阶去显示  </span>
    <span class="pl-st">double</span> min_val=<span class="pl-c1">0</span>;  
    <span class="pl-st">double</span> max_val=<span class="pl-c1">0</span>;  
    <span class="pl-s3">cvMinMaxLoc</span>( mosaicVertical1, &amp;min_val, &amp;max_val,<span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span> );  
    <span class="pl-k">if</span> ( min_val&lt;<span class="pl-c1">0.0</span> )  
        <span class="pl-s3">cvAddS</span>( mosaicVertical1, <span class="pl-s3">cvScalarAll</span>( (-<span class="pl-c1">1.0</span>)*min_val ), mosaicVertical1, <span class="pl-c1">NULL</span> );  
    mosaic2 = <span class="pl-s3">cvCreateImage</span>(<span class="pl-s3">cvSize</span>(mosaicVertical1-&gt;width, mosaicVertical1-&gt;height),  IPL_DEPTH_8U,<span class="pl-c1">1</span>);  
    <span class="pl-s3">cvConvertScale</span>( mosaicVertical1, mosaicVertical1, <span class="pl-c1">255.0</span>/(max_val-min_val), <span class="pl-c1">0</span> );  
    <span class="pl-s3">cvConvertScaleAbs</span>( mosaicVertical1, mosaic2, <span class="pl-c1">1</span>, <span class="pl-c1">0</span> );  

    <span class="pl-c">//  cvSaveImage("DOGPyramid of me.jpg",mosaic2);  </span>
    <span class="pl-s3">cvNamedWindow</span>(<span class="pl-s1"><span class="pl-pds">"</span>mosaic1<span class="pl-pds">"</span></span>,<span class="pl-c1">1</span>);  
    <span class="pl-s3">cvShowImage</span>(<span class="pl-s1"><span class="pl-pds">"</span>mosaic1<span class="pl-pds">"</span></span>, mosaic2);  
    <span class="pl-s3">cvWaitKey</span>(<span class="pl-c1">0</span>);  

    <span class="pl-c">//SIFT算法第三步：特征点位置检测，最后确定特征点的位置  </span>
    <span class="pl-st">int</span> keycount=<span class="pl-s3">DetectKeypoint</span>(numoctaves, Gaussianpyr);  
    <span class="pl-s3">printf</span>(<span class="pl-s1"><span class="pl-pds">"</span>the keypoints number are <span class="pl-c1">%d</span> ;/n<span class="pl-pds">"</span></span>, keycount);  
    <span class="pl-s3">cvCopy</span>(src,image1,<span class="pl-c1">NULL</span>);  
    <span class="pl-s3">DisplayKeypointLocation</span>( image1 ,Gaussianpyr);  

    <span class="pl-s3">cvPyrUp</span>( image1, DoubleSizeImage, CV_GAUSSIAN_5x5 );  
    <span class="pl-s3">cvNamedWindow</span>(<span class="pl-s1"><span class="pl-pds">"</span>image1<span class="pl-pds">"</span></span>,<span class="pl-c1">1</span>);  
    <span class="pl-s3">cvShowImage</span>(<span class="pl-s1"><span class="pl-pds">"</span>image1<span class="pl-pds">"</span></span>, DoubleSizeImage);  
    <span class="pl-s3">cvWaitKey</span>(<span class="pl-c1">0</span>);    
    <span class="pl-s3">cvDestroyWindow</span>(<span class="pl-s1"><span class="pl-pds">"</span>image1<span class="pl-pds">"</span></span>);  

    <span class="pl-c">//SIFT算法第四步：计算高斯图像的梯度方向和幅值，计算各个特征点的主方向  </span>
    <span class="pl-s3">ComputeGrad_DirecandMag</span>(numoctaves, Gaussianpyr);  
    <span class="pl-s3">AssignTheMainOrientation</span>( numoctaves, Gaussianpyr,mag_pyr,grad_pyr);  
    <span class="pl-s3">cvCopy</span>(src,image1,<span class="pl-c1">NULL</span>);  
    <span class="pl-s3">DisplayOrientation</span> ( image1, Gaussianpyr);  

    <span class="pl-c">//  cvPyrUp( image1, DoubleSizeImage, CV_GAUSSIAN_5x5 );  </span>
    <span class="pl-s3">cvNamedWindow</span>(<span class="pl-s1"><span class="pl-pds">"</span>image1<span class="pl-pds">"</span></span>,<span class="pl-c1">1</span>);  
    <span class="pl-c">//  cvResizeWindow("image1", 2*(image1-&gt;width), 2*(image1-&gt;height) );  </span>
    <span class="pl-s3">cvShowImage</span>(<span class="pl-s1"><span class="pl-pds">"</span>image1<span class="pl-pds">"</span></span>, image1);  
    <span class="pl-s3">cvWaitKey</span>(<span class="pl-c1">0</span>);  

    <span class="pl-c">//SIFT算法第五步：抽取各个特征点处的特征描述字  </span>
    <span class="pl-s3">ExtractFeatureDescriptors</span>( numoctaves, Gaussianpyr);  
    <span class="pl-s3">cvWaitKey</span>(<span class="pl-c1">0</span>);  

    <span class="pl-c">//销毁窗口  </span>
    <span class="pl-s3">cvDestroyWindow</span>(<span class="pl-s1"><span class="pl-pds">"</span>image1<span class="pl-pds">"</span></span>);  
    <span class="pl-s3">cvDestroyWindow</span>(<span class="pl-s1"><span class="pl-pds">"</span>mosaic1<span class="pl-pds">"</span></span>);  
    <span class="pl-c">//释放图像  </span>
    <span class="pl-s3">cvReleaseImage</span>(&amp;image1);  
    <span class="pl-s3">cvReleaseImage</span>(&amp;grey_im1);  
    <span class="pl-s3">cvReleaseImage</span>(&amp;mosaic1);  
    <span class="pl-s3">cvReleaseImage</span>(&amp;mosaic2);  
    <span class="pl-k">return</span> <span class="pl-c1">0</span>;  
}</pre>
  </div>
  <p>
   最后，再看一下，运行效果（图中美女为老乡+朋友，何姐08年照）：
  </p>
  <p>
   <a href="../images/10/10.1.3/10.1.3.1.jpg" target="_blank">
    <img alt="" src="../images/10/10.1.3/10.1.3.1.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   <a href="../images/10/10.1.3/10.1.3.2.jpg" target="_blank">
    <img alt="" src="../images/10/10.1.3/10.1.3.2.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   <a href="../images/10/10.1.3/10.1.3.3.jpg" target="_blank">
    <img alt="" src="../images/10/10.1.3/10.1.3.3.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   <a href="../images/10/10.1.3/10.1.3.4.jpg" target="_blank">
    <img alt="" src="../images/10/10.1.3/10.1.3.4.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   <a href="../images/10/10.1.3/10.1.3.5.jpg" target="_blank">
    <img alt="" src="../images/10/10.1.3/10.1.3.5.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   完。
  </p>
  <p>
   <strong>
    updated
   </strong>
  </p>
  <p>
   有很多朋友都在本文评论下要求要本程序的完整源码包（注：本文代码未贴全，复制粘贴编译肯定诸多错误），但由于时隔太久，这份代码我自己也找不到了，不过，我可以提供一份sift + KD + BBF，且可以编译正确的代码供大家参考学习，有pudn帐号的朋友可以前去下载：
   <a href="http://www.pudn.com/downloads340/sourcecode/graph/texture_mapping/detail1486667.html">
    http://www.pudn.com/downloads340/sourcecode/graph/texture_mapping/detail1486667.html
   </a>
   （没有pudn账号的同学请加群：169056165，验证信息：sift，至群共享下载），然后用两幅不同的图片做了下匹配（当然，运行结果显示是不匹配的），效果还不错：
   <a href="">
    http://weibo.com/1580904460/yDmzAEwcV#1348475194313
   </a>
   ! July、二零一二年十月十一日。
  </p>
 </body>
</html>
		  </article>
		  
			<div id="nav">
				
					<a href="10.01.02.html">prev</a>
					|
				
				
					<a href="40亿个数中快速查找.html">next</a>
				
				<span style="float: right"><a href="index.html">Back to home</a>
			</div>
		  
		</div>
	</div>
  </div>
  
  <div>&nbsp;</div>
  </div>
  <div style="text-align:center; margin-bottom: 30px">
	  Generated by <a href="https://github.com/marchtea/md_to_github_html">mdtogh</a>
  </div>
</body>
</html>