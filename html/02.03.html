<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title></title><link rel="stylesheet" href="style_cache/github-b4baae9c06716bcd0a8068e3030607851f19b980.css" />
  <link rel="stylesheet" href="style_cache/github2-4940da06adce480cfcfba223624a2b2f09e8f90f.css" />
  <style>
    .file-box {
      margin: 64px auto;
      width: 920px;
    }
	body {
		font-size: 14px;
		line-height: 22px;
		<!--font-family: "adelle",Georgia,"Times New Roman",serif;-->
		color: #4e443c;
		background: #f0efe7;
	}

	.book-toc {

	}
	a {
		color: #0388a6;
		text-decoration: none;
	}
	a:hover {
		color: #04b1d8;
		text-decoration: none;
	}
	ol.book-toc li.chapter{
		margin-bottom:0.6em
	}
	ol.book-toc, ol{
		list-style-type: disc
	}
	ol.book-toc{
		margin:30px 36px
	}
	ol.book-toc a{
		padding-left:4px
	}
	li {
		line-height: 22px;
	}
	h1, h2, h3, h4, h5, h6, li, p, a, ol, div{
		margin: 0;
		padding: 0;
		border: 0;
		vertical-align: baseline;
	}
	ul, ol {
		padding: 0;
		margin: 0 0 11px 25px;
	}
	h1 {
		font-size: 36px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	h2 {
		font-size: 18px;
		color: #f14e32;
		font-weight: bold;
	}
	h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h1{
		font-size: 22px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	ol.book-toc h2 {
		font-size: 16px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	p {
		margin: 0 0 11px;
		font-size: 14px;
		line-height: 22px;
	}
	div {
		display: block;
	}
	div#nav{
		padding: 30px
	}
  </style>
</head>
<body>
  <div class="page">
    <div class="file-box">
	<div class="file">
		<div id="readme" class="blob instapaper_body announce md">
		  <article class="markdown-body entry-content" itemprop="mainContentOfPage">
			<html>
 <body>
  <h1>
   <a class="anchor" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BA%B2%E5%92%8C%E6%95%B0%E9%97%AE%E9%A2%98--%E6%B1%82%E8%A7%A3500%E4%B8%87%E4%BB%A5%E5%86%85%E7%9A%84%E4%BA%B2%E5%92%8C%E6%95%B0" name="%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BA%B2%E5%92%8C%E6%95%B0%E9%97%AE%E9%A2%98--%E6%B1%82%E8%A7%A3500%E4%B8%87%E4%BB%A5%E5%86%85%E7%9A%84%E4%BA%B2%E5%92%8C%E6%95%B0">
    <span class="octicon octicon-link">
    </span>
   </a>
   第六章：亲和数问题--求解500万以内的亲和数
  </h1>
  <h2>
   <a class="anchor" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" name="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">
    <span class="octicon octicon-link">
    </span>
   </a>
   题目描述
  </h2>
  <p>
   求500万以内的所有亲和数
  </p>
  <p>
   如果两个数a和b，a的所有真因数之和等于b,b的所有真因数之和等于a,则称a,b是一对亲和数。
例如220和284，1184和1210，2620和2924。
  </p>
  <h2>
   <a class="anchor" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" name="%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">
    <span class="octicon octicon-link">
    </span>
   </a>
   思路分析
  </h2>
  <p>
   首先得明确到底是什么是亲和数?
  </p>
  <p>
   亲和数问题最早是由毕达哥拉斯学派发现和研究的。他们在研究数字的规律的时候发现有以下性质特点的两个数:
  </p>
  <p>
   220的真因子是：1、2、4、5、10、11、20、22、44、55、110；
  </p>
  <p>
   284的真因子是：1、2、4、71、142。
  </p>
  <p>
   而这两个数恰恰等于对方的真因子各自加起来的和（sum[i]表示数i 的各个真因子的和），即
  </p>
  <p>
   220=1+2+4+71+142=sum[284],
  </p>
  <p>
   284=1+2+4+5+10+11+20+22+44+55+110=sum[220]。
  </p>
  <p>
   得284的真因子之和sum[284]=220，且220的真因子之和sum[220]=284，即有sum[220]=sum[sum[284]]=284。
  </p>
  <p>
   如此，是否已看出丝毫端倪?
  </p>
  <p>
   如上所示，考虑到1是每个整数的因子，把出去整数本身之外的所有因子叫做这个数的“真因子”。如果两个整数，其中每一个真因子的和都恰好等于另一个数，那么这两个数，就构成一对“亲和数”（有关亲和数的更多讨论，可参考
   <a href="http://t.cn/hesH09">
    这里
   </a>
   )。
  </p>
  <p>
   <strong>
    求解
   </strong>
   :
    了解了什么是亲和数，接下来咱们一步一步来解决上面提出的问题（以下内容大部引自水的原话，同时水哥有一句原话，
   <strong>
    “在你真正弄弄懂这个范例之前，你不配说你懂数据结构和算法”
   </strong>
   ）。
  </p>
  <ol>
   <li>
    看到这个问题后，第一想法是什么？模拟搜索+剪枝？回溯？时间复杂度有多大？其中bn为an的伪亲和数，即bn是an的真因数之和大约是多少？至少是10^10的数量级。那么对于每秒千万次运算的计算机来说，大概在1000多天也就是3年内就可以搞定了（10^10 / 10^7 =1000000秒，大约 278 小时）。如果是基于这个基数在优化，你无法在一天内得到结果的。
   </li>
   <li>
    一个不错的算法应该在半小时之内搞定这个问题，当然这样的算法有很多。节约时间的做法是可以生成伴随数组，也就是空间换时间，但是那样，空间代价太大，因为数据规模庞大。
   </li>
   <li>
    在稍后的算法中，依然使用的伴随数组，只不过，因为题目的特殊性，只是它方便和巧妙地利用了下标作为伴随数组，来节约时间。同时，将回溯的思想换成递推的思想(预处理数组的时间复杂度为
    <strong>
     O(N*logN)
    </strong>
    (logN为调和级数)，扫描数组的时间复杂度为线性
    <strong>
     O(N)
    </strong>
    。所以，总的时间复杂度仍然为
    <strong>
     O(N*logN)
    </strong>
    (其中logN为调和级数))，扫描数组的时间与其相比是低阶的。
   </li>
  </ol>
  <h2>
   <a class="anchor" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%E4%BC%B4%E9%9A%8F%E6%95%B0%E7%BB%84%E7%BA%BF%E6%80%A7%E9%81%8D%E5%8E%86" name="%E8%A7%A3%E6%B3%95%E4%B8%80%E4%BC%B4%E9%9A%8F%E6%95%B0%E7%BB%84%E7%BA%BF%E6%80%A7%E9%81%8D%E5%8E%86">
    <span class="octicon octicon-link">
    </span>
   </a>
   解法一、伴随数组线性遍历
  </h2>
  <p>
   依据上文的思路分析，可以编写如下代码：
  </p>
  <div class="highlight highlight-c">
   <pre><span class="c1">//求解亲和数问题</span>

<span class="c1">//第一个for和第二个for循环是logN*N（调和级数）次遍历,第三个for循环扫描O(N)。</span>
<span class="c1">//所以总的时间复杂度为 O(N*logN) + O(n) =O(N*logN+N)（其中logN为调和级数）。</span>

<span class="c1">//关于第一个for和第二个for寻找中，调和级数的说明：</span>
<span class="c1">//比如给2的倍数加2，那么应该是  n/2次，3的倍数加3 应该是 n/3次，...</span>
<span class="c1">//那么其实就是n*（1+1/2+1/3+1/4+...1/(n/2)）=n*（调和级数）=n*logn。</span>

<span class="c1">//copyright@ 上善若水</span>
<span class="c1">//July、updated，2011.05.24。</span>
<span class="cp">#include&lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="n">sum</span><span class="p">[</span><span class="mi">5000010</span><span class="p">];</span>   <span class="c1">//为防越界</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">//1是所有数的真因数所以全部置1</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="c1">//预处理，预处理是logN（调和级数）*N。</span>
        <span class="c1">//@litaoye：调和级数1/2 + 1/3 + 1/4......的和近似为ln(n)，</span>
        <span class="c1">//因此O(n *(1/2 + 1/3 + 1/4......)) = O(n * ln(n)) = O(N*log(N))。</span>
    <span class="p">{</span>
        <span class="c1">//5000000以下最大的真因数是不超过它的一半的</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">//因为真因数，所以不能算本身，所以从它的2倍开始</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">5000000</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//将所有i的倍数的位置上加i</span>
            <span class="n">sum</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">220</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   <span class="c1">//扫描，O（N）。</span>
    <span class="p">{</span>
        <span class="c1">// 一次遍历，因为知道最小是220和284因此从220开始</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">5000000</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="p">[</span><span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//去重，不越界，满足亲和</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d/n"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>
  <p>
   <strong>
    运行结果
   </strong>
   :
  </p>
  <p>
   <a href="../images/6.1.jpg" target="_blank">
    <img alt="" src="../images/6.1.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <blockquote>
   <p>
    @上善若水：
   </p>
   <p>
    1、可能大家理解的还不是很清晰，我们建立一个5 000 000 的数组，从1到2 500 000开始，在每一个下标是i的倍数的位置上加上i，那么在循环结束之后，我们得到的是什么？是类似埃斯托拉晒求素数的数组（当然里面有真的亲和数），然后只需要一次遍历就可以轻松找到所有的亲和数了。时间复杂度，线性。
   </p>
   <p>
    2、我们可以清晰的发现连续数据的映射可以通过数组结构本身的特点替代，用来节约空间，这是数据结构的艺术。在大规模连续数据的回溯处理上，可以通过转化为递推生成的方法，逆向思维操作，这是算法的艺术。
   </p>
   <p>
    3、把最简单的东西运用的最巧妙的人，要比用复杂方法解决复杂问题的人要头脑清晰。
   </p>
  </blockquote>
  <h3>
   <a class="anchor" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E8%A7%A3%E9%87%8A" name="%E8%A7%A3%E6%B3%95%E4%B8%80%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E8%A7%A3%E9%87%8A">
    <span class="octicon octicon-link">
    </span>
   </a>
   解法一的构造与解释
  </h3>
  <p>
   我再来具体解释下上述程序的原理，ok，举个例子，假设是求10以内的亲和数，求解步骤如下：
  </p>
  <p>
   因为所有数的真因数都包含1，所以，先在各个数的下方全部置1
  </p>
  <p>
   1. 然后取i=2,3,4,5（i&lt;=10/2），j依次对应的位置为j=（4、6、8、10），（6、9）,（8）,（10）各数所对应的位置。依据j所找到的位置，在j所指的各个数的下面加上各个真因子i（i=2、3、4、5）。
  </p>
  <p>
   2. 整个过程，即如下图所示（如sum[6]=1+2+3=6，sum[10]=1+2+5=8.）:
  </p>
  <p>
   <a href="../images/6.2.jpg" target="_blank">
    <img alt="" src="../images/6.2.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   3. 然后一次遍历i从220开始到5000000，i每遍历一个数后,
将i对应的数下面的各个真因子加起来得到一个和sum[i]，如果这个和sum[i]==某个i’，且sum[i‘]=i，
那么这两个数i和i’，即为一对亲和数。
  </p>
  <p>
   4. i=2；sum[4]+=2，sum[6]+=2，sum[8]+=2，sum[10]+=2，sum[12]+=2...
i=3，sum[6]+=3，sum[9]+=3...
  </p>
  <p>
   5. i=220时，sum[220]=284，i=284时，sum[284]=220；即sum[220]=sum[sum[284]]=284，
得出220与284是一对亲和数。所以，最终输出220、284，...
  </p>
  <h2>
   <a class="anchor" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C" name="%E8%A7%A3%E6%B3%95%E4%BA%8C">
    <span class="octicon octicon-link">
    </span>
   </a>
   解法二
  </h2>
  <blockquote>
   <p>
    litaoye专门为本亲和数问题开帖子继续阐述，有兴趣的朋友可继续参见
    <a href="http://topic.csdn.net/u/20110526/21/129c2235-1f44-42e9-a55f-878920c21e19.html">
     这里
    </a>
    。同时，任何人对本亲和数问题有任何问题，也可以回复到上述帖子上。
   </p>
  </blockquote>
  <h3>
   <a class="anchor" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%9C%9F%E5%9B%A0%E5%AD%90%E4%B9%8B%E5%92%8C" name="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%9C%9F%E5%9B%A0%E5%AD%90%E4%B9%8B%E5%92%8C">
    <span class="octicon octicon-link">
    </span>
   </a>
   深入理解真因子之和
  </h3>
  <p>
   假设一个整数分解因式形式为
   <a href="https://camo.githubusercontent.com/2f191aac6814ccd226b0015402203cc5a763842b/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d25354370726f645f253742693d312537442535456e253742253742615f692537442535452537426b5f69253744253744" target="_blank">
    <img alt="img" data-canonical-src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cprod_%7Bi=1%7D%5En%7B%7Ba_i%7D%5E%7Bk_i%7D%7D" src="https://camo.githubusercontent.com/2f191aac6814ccd226b0015402203cc5a763842b/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d25354370726f645f253742693d312537442535456e253742253742615f692537442535452537426b5f69253744253744" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   那么它的所有
   <strong>
    因子之和
   </strong>
   （也就是真因子之和加上其本身）等于
  </p>
  <p>
   <a href="https://camo.githubusercontent.com/0c8e051a21e2f73f3bd4a827f01b6ca02ce9571a/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d25354370726f645f253742693d312537442535456e25374225354373756d5f2537426a3d312537442535452537426b5f69253744253742615f692537442535456a253744" target="_blank">
    <img alt="img" data-canonical-src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cprod_%7Bi=1%7D%5En%7B%5Csum_%7Bj=1%7D%5E%7Bk_i%7D%7Ba_i%7D%5Ej%7D" src="https://camo.githubusercontent.com/0c8e051a21e2f73f3bd4a827f01b6ca02ce9571a/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d25354370726f645f253742693d312537442535456e25374225354373756d5f2537426a3d312537442535452537426b5f69253744253742615f692537442535456a253744" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   举例说明：90分解质因数为
   <a href="https://camo.githubusercontent.com/3ec1d71ae28d73d1b931586736cfa3bab1b65da4/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d39303d322a33253545322a35" target="_blank">
    <img alt="img" data-canonical-src="http://chart.apis.google.com/chart?cht=tx&amp;chl=90=2*3%5E2*5" src="https://camo.githubusercontent.com/3ec1d71ae28d73d1b931586736cfa3bab1b65da4/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d39303d322a33253545322a35" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   所以90的因子之和为
   <a href="https://camo.githubusercontent.com/334cbf93d3bd2f736271867c0b77b5019aaaa0b5/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d66283930293d28312532423229283125324233253242332535453229283125324235293d323334" target="_blank">
    <img alt="img" data-canonical-src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f(90)=(1%2B2)(1%2B3%2B3%5E2)(1%2B5)=234" src="https://camo.githubusercontent.com/334cbf93d3bd2f736271867c0b77b5019aaaa0b5/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d66283930293d28312532423229283125324233253242332535453229283125324235293d323334" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   而这个函数f(n)有什么好性质呢？当n=p*q，并且p,q互质时，有：
  </p>
  <p>
   <a href="https://camo.githubusercontent.com/7fdf9b47d3f79382ddea032baa5784ff8044fef4/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d66286e293d662870292a66287129" target="_blank">
    <img alt="img" data-canonical-src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f(n)=f(p)*f(q)" src="https://camo.githubusercontent.com/7fdf9b47d3f79382ddea032baa5784ff8044fef4/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d66286e293d662870292a66287129" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   也就是说，我们只要知道n的任意一种pq分解，p、q互质，以及f(p)和f(q)的具体值，就可以快速知道f(n)的值了。
  </p>
  <p>
   进一步，本例中我们只需要对真因子加和，设其为函数counter(n)。我们就会有counter(n)=f(n)-n的关系。如果我们能快速得到f(n)，counter(n)就不成问题，我们就能快速的验证counter(counter(n))=n来判断亲和数。
  </p>
  <h3>
   <a class="anchor" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%B4%A8%E6%95%B0%E7%AD%9Bprime-sieves" name="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%B4%A8%E6%95%B0%E7%AD%9Bprime-sieves">
    <span class="octicon octicon-link">
    </span>
   </a>
   深入理解质数筛（Prime Sieves）
  </h3>
  <p>
   我们知道在解法一中，预处理时间为O(NlogN)，同时也能看到，为了给一个合数加够它的因子，计算次数相对于f(n)而言实在是太大了，而如果我们能够对每一个数最多操作一次就能知道它的f(n)值（进而知道counter(n)值），那这个算法就变成O(N)的了。
  </p>
  <p>
   这种算法存在吗？答案是确定的。我们一边找素数一边去确定f(n)的值，那我们就不得不提到这个算法的基础算法：线性素数筛。
  </p>
  <h4>
   <a class="anchor" href="#eratosthenes%E8%BF%91%E7%BA%BF%E6%80%A7%E7%B4%A0%E6%95%B0%E7%AD%9B" name="eratosthenes%E8%BF%91%E7%BA%BF%E6%80%A7%E7%B4%A0%E6%95%B0%E7%AD%9B">
    <span class="octicon octicon-link">
    </span>
   </a>
   Eratosthenes近线性素数筛
  </h4>
  <p>
   首先介绍一种使用O(N)空间伴随数组的素数筛
  </p>
  <div class="highlight highlight-C">
   <pre><span class="c1">//使用了一个布尔型伴随数组的素数筛</span>
<span class="kt">bool</span><span class="o">*</span> <span class="nf">prime</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="o">*</span><span class="n">notp</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">bool</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">notp</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="o">*</span><span class="n">n</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">notp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">i</span><span class="p">)</span>
        <span class="n">notp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">notp</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>
  <p>
   初始化伴随数组为全0后，我们对于每一个在notp中被标记0的下标i，对下标为i的2倍，3倍...的notp元素标记为"true"，即合数。这个算法的好处在于，因为我们从2开始顺序扫描到i的，如果发现i仍然没被标记过"true"，则它没有2到i-1的约束，肯定是素数。而如果一个合数被标记过"true"了，它的倍数肯定也被这个合数的第一个质因数都标记完"true"了，这个算法在标记素数上确实是不漏的，而在标记合数上，标记的次数是这个合数的不同质因数的个数。
  </p>
  <p>
   整个算法的复杂度为
   <strong>
    O(Nloglog(N))
   </strong>
   ，参考
   <a href="http://en.wikipedia.org/wiki/Prime_harmonic_series">
    http://en.wikipedia.org/wiki/Prime_harmonic_series
   </a>
   的公式：
  </p>
  <p>
   <a href="https://camo.githubusercontent.com/b1db53a515edc0ce6234cc8fd9757dfc8da09b9b/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d25354373756d2535436c696d6974735f253742703a7072696d652533433d4e2537442535436672616325374231253744253742702537443d4f286c6f676c6f674e29" target="_blank">
    <img alt="img" data-canonical-src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Csum%5Climits_%7Bp:prime%3C=N%7D%5Cfrac%7B1%7D%7Bp%7D=O(loglogN)" src="https://camo.githubusercontent.com/b1db53a515edc0ce6234cc8fd9757dfc8da09b9b/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d25354373756d2535436c696d6974735f253742703a7072696d652533433d4e2537442535436672616325374231253744253742702537443d4f286c6f676c6f674e29" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   而且是渐进于这个
   <strong>
    loglogN
   </strong>
   的。因为loglogN工程上很小，可以当常量来估计。
  </p>
  <h4>
   <a class="anchor" href="#eratosthenes%E8%B4%A8%E6%95%B0%E7%AD%9B" name="eratosthenes%E8%B4%A8%E6%95%B0%E7%AD%9B">
    <span class="octicon octicon-link">
    </span>
   </a>
   Eratosthenes质数筛
  </h4>
  <p>
   进一步的我们对这个算法进行剪枝，是前述近线性素数筛的加强版，首先我们知道如果质数m小于质数p的平方，则在第p轮循环之前m就被比p还小的质数标记过了；同时对于另外的质数，如果发现它被标记过就跳过标记他。虽然加速了许多，但是考虑到比较大小和幅值的操作代价相差不多，复杂度上界并没有改变。每个合数m都被它的最小质因数标记了1次，其他质因数进行了notp[m]的寻址和比较。
  </p>
  <div class="highlight highlight-C">
   <pre><span class="c1">//使用了一个布尔型伴随数组的素数筛</span>
<span class="kt">bool</span><span class="o">*</span> <span class="nf">prime_wiki</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="o">*</span><span class="n">notp</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">bool</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">notp</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="o">*</span><span class="n">n</span> <span class="p">);</span>
  <span class="kt">double</span> <span class="n">sqr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sqr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">notp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">i</span><span class="p">)</span>
          <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">notp</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span><span class="n">notp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;}</span>
  <span class="k">return</span> <span class="n">notp</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>
  <h4>
   <a class="anchor" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%AD%9B" name="%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%AD%9B">
    <span class="octicon octicon-link">
    </span>
   </a>
   线性时间筛
  </h4>
  <div class="highlight highlight-C">
   <pre><span class="kt">bool</span><span class="o">*</span> <span class="nf">prime_linear</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="o">*</span><span class="n">notp</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">bool</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">plist</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="o">+</span><span class="mi">20</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">notp</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">plist</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="o">+</span><span class="mi">20</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">half</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">notp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">plist</span><span class="p">[</span><span class="n">np</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">half</span><span class="p">){</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">plist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">notp</span><span class="p">[</span><span class="n">plist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="n">plist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                  <span class="p">}</span>
            <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">delete</span> <span class="n">plist</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">notp</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>
  <p>
   同时保存一个长度为N的伴随数组表示“p是否为合数”及长度为O(N/log(N))的数组来保存质数列表。这里，每一个质数p会保持notp[p]=0的标记并加入列表，每一个合数也只被它最大的真因数（也就是这个合数除以其最小质因数）标记一次。这样的好处我们可以看到，交换了标记次序并及时使用break，每个合数只需要1次标记和1次判断。
  </p>
  <h3>
   <a class="anchor" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E5%BA%94%E7%94%A8%E4%BA%8E%E4%BA%B2%E5%92%8C%E6%95%B0%E9%97%AE%E9%A2%98" name="%E7%BA%BF%E6%80%A7%E7%AD%9B%E5%BA%94%E7%94%A8%E4%BA%8E%E4%BA%B2%E5%92%8C%E6%95%B0%E9%97%AE%E9%A2%98">
    <span class="octicon octicon-link">
    </span>
   </a>
   线性筛应用于亲和数问题
  </h3>
  <p>
   很多人都觉得近线性已经足够好了，根本不想花O(N/log(N))的空间存储素数。错！在本题中存储素数加上线性筛算法，恰恰保证了寻找合数最小质因数分解的快速性，以提高合数n对应的f(n)的计算，如下C#代码所示。
  </p>
  <div class="highlight highlight-csharp">
   <pre><span class="c1">//求解亲和数问题</span>
<span class="c1">//copyright@ litaoye</span>
<span class="c1">//July、胡滨，updated，2011.05.26。</span>
<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">CSharpTest</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">max</span> <span class="p">=</span> <span class="m">5000000</span><span class="p">;</span>
            <span class="n">DateTime</span> <span class="n">start</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
            <span class="kt">int</span><span class="p">[]</span> <span class="n">counter</span> <span class="p">=</span> <span class="n">CreateCounter</span><span class="p">(</span><span class="n">max</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">num</span> <span class="p">=</span> <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">-</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="p">&lt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">Length</span> <span class="p">&amp;&amp;</span> <span class="n">num</span> <span class="p">&gt;</span> <span class="n">i</span> <span class="p">&amp;&amp;</span> <span class="n">counter</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="p">==</span> <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"{0} {1}"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">((</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span> <span class="p">-</span> <span class="n">start</span><span class="p">).</span><span class="n">TotalSeconds</span><span class="p">);</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="kt">int</span><span class="p">[]</span> <span class="nf">CreateCounter</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">primes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
            <span class="kt">int</span><span class="p">[]</span> <span class="n">counter</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span> <span class="p">+</span> <span class="m">1</span><span class="p">];</span>
            <span class="n">counter</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
                    <span class="n">primes</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">primes</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">*</span> <span class="n">i</span> <span class="p">&gt;</span> <span class="n">n</span><span class="p">)</span>
                        <span class="k">break</span><span class="p">;</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">%</span> <span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="kt">int</span> <span class="n">k</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
                        <span class="kt">int</span> <span class="n">l</span> <span class="p">=</span> <span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">*</span> <span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

                        <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="p">%</span> <span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">l</span> <span class="p">*=</span> <span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                            <span class="n">k</span> <span class="p">/=</span> <span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                        <span class="p">}</span>

                        <span class="n">counter</span><span class="p">[</span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">*</span> <span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">counter</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">*</span> <span class="p">(</span><span class="n">l</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">/</span> <span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                        <span class="n">counter</span><span class="p">[</span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">*</span> <span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">*</span> <span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">测试结果：</span>
<span class="cm">0.484375</span>
<span class="cm">0.484375</span>
<span class="cm">0.46875</span>
<span class="cm">单位second。</span>
<span class="cm">*/</span>
</pre>
  </div>
  <p>
   至此，这个算法融合了线性质数筛的最佳性质，它的步骤如下：
  </p>
  <ul>
   <li>
    我们为1到N存储一个int型伴随数组，存储它们的因子和，而非伴随bool变量，同时也存储质数列表；
   </li>
   <li>
    刷新伴随数组时，"因子和等于本身加1"等价于"质数"；
   </li>
   <li>
    我们可以通过伴随数组精确的知道内层循环在哪一步break，进而知道：
    <ul>
     <li>
      break之前counter[j]和i本身就互质，直接得到了计算因子和的方案
     </li>
     <li>
      break这一步通过获取得其最小质因数p，找到最大的k使得
      <a href="https://camo.githubusercontent.com/2006b97d1dc67347ce26d2210d67bef57777c517/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d702535456b2537436d" target="_blank">
       <img alt="img" data-canonical-src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p%5Ek%7Cm" src="https://camo.githubusercontent.com/2006b97d1dc67347ce26d2210d67bef57777c517/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d702535456b2537436d" style="max-width:100%;"/>
      </a>
      ，从而实现
      <a href="https://camo.githubusercontent.com/e35be0e758205a68633200edf87ab5122dae7f71/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d6d3d702535456b71" target="_blank">
       <img alt="img" data-canonical-src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m=p%5Ekq" src="https://camo.githubusercontent.com/e35be0e758205a68633200edf87ab5122dae7f71/687474703a2f2f63686172742e617069732e676f6f676c652e636f6d2f63686172743f6368743d74782663686c3d6d3d702535456b71" style="max-width:100%;"/>
      </a>
      ，能够把m分解成两个互质整数的乘积。
     </li>
    </ul>
   </li>
   <li>
    知道了m的因子和，减去m就是m的真因子之和，进而考察counter[counter[m]] == m 析出亲和数。
   </li>
  </ul>
 </body>
</html>
		  </article>
		  
			<div id="nav">
				
					<a href="02.02.html">prev</a>
					|
				
				
					<a href="02.04.html">next</a>
				
				<span style="float: right"><a href="index.html">Back to home</a>
			</div>
		  
		</div>
	</div>
  </div>
  
  <div>&nbsp;</div>
  </div>
  <div style="text-align:center; margin-bottom: 30px">
	  Generated by <a href="https://github.com/marchtea/md_to_github_html">mdtogh</a>
  </div>
</body>
</html>