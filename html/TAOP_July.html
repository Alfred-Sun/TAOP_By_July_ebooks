<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#第一章左旋转字符串">第一章：左旋转字符串</a></li>
<li><a href="#第二章字符串是否包含问题">第二章：字符串是否包含问题</a></li>
<li><a href="#第三章寻找最小的-k-个数">第三章：寻找最小的 k 个数</a></li>
<li><a href="#第三章续搜索引擎热门查询统计">第三章续：搜索引擎热门查询统计</a></li>
<li><a href="#第三章再续快速选择select算法的深入分析与实现">第三章再续：快速选择SELECT算法的深入分析与实现</a></li>
<li><a href="#第三章三续求数组中给定下标区间内的第-k-小大元素">第三章三续：求数组中给定下标区间内的第 K 小(大)元素</a></li>
<li><a href="#第三章四续动态数据中求第-k-小大元素">第三章四续：动态数据中求第 K 小(大)元素</a></li>
<li><a href="#第四章现场编写类似strstrstrcpystrpbrk的函数">第四章：现场编写类似strstr/strcpy/strpbrk的函数</a></li>
<li><a href="#第五章寻找和为定值的两个或多个数">第五章：寻找和为定值的两个或多个数</a></li>
<li><a href="#解法二">解法二</a></li>
<li><a href="#第六章亲和数问题--求解500万以内的亲和数">第六章：亲和数问题--求解500万以内的亲和数</a></li>
<li><a href="#第七章求连续子数组的最大和">第七章：求连续子数组的最大和</a></li>
<li><a href="#第十章如何给107个数据量的磁盘文件排序">第十章：如何给10^7个数据量的磁盘文件排序</a></li>
<li><a href="#第十一章最长公共子序列lcs问题">第十一章：最长公共子序列（LCS）问题</a></li>
<li><a href="#第十二第十五章中钱概率ip访问次数回文等问题初稿">第十二~第十五章：中钱概率，IP访问次数，回文等问题（初稿）</a></li>
<li><a href="#第十六第二十章全排列跳台阶奇偶排序第一个只出现一次等问题">第十六~第二十章：全排列，跳台阶，奇偶排序，第一个只出现一次等问题</a></li>
<li><a href="#第二十一章出现次数超过一半的数字">第二十一章：出现次数超过一半的数字</a></li>
<li><a href="#第二十二章最短摘要的生成">第二十二章：最短摘要的生成</a></li>
<li><a href="#第二十三章杨氏矩阵查找">第二十三章：杨氏矩阵查找</a></li>
<li><a href="#第二十四章倒排索引关键词不重复hash编码">第二十四章：倒排索引关键词不重复Hash编码</a></li>
<li><a href="#第二十五章二分查找实现">第二十五章：二分查找实现</a></li>
<li><a href="#第二十六章基于给定的文档生成倒排索引的编码与实践">第二十六章：基于给定的文档生成倒排索引的编码与实践</a></li>
<li><a href="#第二十七章不改变正负数相对顺序重新排列数组">第二十七章：不改变正负数相对顺序重新排列数组</a></li>
<li><a href="#第二十八章最大连续乘积子串">第二十八章：最大连续乘积子串</a></li>
<li><a href="#第二十九章字符串编辑距离">第二十九章：字符串编辑距离</a></li>
<li><a href="#第三十章字符串转换成整数">第三十章：字符串转换成整数</a></li>
<li><a href="#第三十一章带通配符的字符串匹配问题">第三十一章：带通配符的字符串匹配问题</a></li>
<li><a href="#第三十二章最小操作数">第三十二章：最小操作数</a></li>
<li><a href="#第三十三章木块砌墙">第三十三章：木块砌墙</a></li>
<li><a href="#第三十四三十五章格子取数问题完美洗牌算法">第三十四~三十五章：格子取数问题，完美洗牌算法</a></li>
<li><a href="#第三十五章完美洗牌算法">第三十五章：完美洗牌算法</a></li>
<li><a href="#第三十六三十七章搜索智能提示suggestion附近点搜索">第三十六~三十七章：搜索智能提示suggestion，附近点搜索</a></li>
<li><a href="#第三十八章hero在线编程判题出题系统的演进与优化">第三十八章：Hero在线编程判题、出题系统的演进与优化</a></li>
</ul>
</nav>
<h1 id="第一章左旋转字符串">第一章：左旋转字符串</h1>
<h2 id="题目描述">题目描述</h2>
<p>定义字符串的左旋转操作:把字符串前面的若干个字符移动到字符串的尾部,如把字符串 abcdef 左旋转 2 位得到字符串 cdefab。请实现字符串左旋转的函数,要求对长度为 n 的字符串操作的时间复杂度为 O(n),空间复杂度为 O(1)。</p>
<h2 id="解法一暴力移位法">解法一、暴力移位法</h2>
<p>初看此题,咱们最先想到的笨方法可能就是一位一位移动,故咱们写一个函数叫做 <code>left_shift_one(char *s, int n)</code> 完成左移动一位的功能</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> left_shift_one(<span class="dt">char</span> *s, <span class="dt">int</span> n)
{
    assert(s != NULL);
    <span class="dt">char</span> t = s[<span class="dv">0</span>];  <span class="co">//保存第一个字符</span>
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; i++)
    {
        s[i - <span class="dv">1</span>] = s[i];
    }
    s[n - <span class="dv">1</span>] = t;
}</code></pre>
<p>如此,左移 m 位的话,可以如下实现:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> left_shift_m(<span class="dt">char</span> *s, <span class="dt">int</span> n, <span class="dt">int</span> m)
{
    <span class="kw">while</span> (m--)
    {
        left_shift_one(s, n);
    }
}</code></pre>
<h2 id="解法二三步翻转法">解法二、三步翻转法</h2>
<p>对于这个问题，咱们换一个角度，可以这么做：</p>
<p>将一个字符串分成两部分，X和Y两个部分，在字符串上定义反转的操作X<sup>T，即把X的所有字符反转（如，X=&quot;abc&quot;，那么X</sup>T=&quot;cba&quot;），那么我们可以得到下面的结论：(X<sup>TY</sup>T)^T=YX。显然我们这就可以转化为字符串的反转的问题了。</p>
<p>不是么? ok,就拿abcdef 这个例子来说，若要让def翻转到abc的前头，那么只要按下述3个步骤操作即可：</p>
<ol type="1">
<li>首先分为俩部分，X:abc，Y:def；</li>
<li>X-&gt;X^T，abc-&gt;cba， Y-&gt;Y^T，def-&gt;fed。</li>
<li>(X<sup>TY</sup>T)^T=YX，cbafed-&gt;defabc，即整个翻转。</li>
</ol>
<p>我想，这下，你应该一目了然了。</p>
<p>其次，在《编程珠玑》上也有这样一个类似的问题，它的解法同本思路一致，如下图所示：</p>
<figure>
<img src="../images/1/3.jpeg" />
</figure>
<p>然后，代码可以这么写：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//updated@caopengcs &amp;&amp; July</span>
<span class="co">//2014-1-6</span>
<span class="dt">void</span> reverse(<span class="dt">char</span> *s,<span class="dt">int</span> from,<span class="dt">int</span> to)
{
    <span class="kw">while</span> (from &lt; to)
    {
        <span class="dt">char</span> t = s[from];
        s[from++] = s[to];
        s[to--] = t;
    }
}

<span class="dt">void</span> leftshift(<span class="dt">char</span> *s,<span class="dt">int</span> n,<span class="dt">int</span> m)
{
    m %= n;               <span class="co">//左移动大于n位和 %n是等价的</span>
    reverse(s, <span class="dv">0</span>, m - <span class="dv">1</span>); <span class="co">//翻转[0..m - 1]，套用到上面举的例子中，就是X-&gt;X^T，即 abc-&gt;cba</span>
    reverse(s, m, n - <span class="dv">1</span>); <span class="co">//翻转[m..n - 1]，例如Y-&gt;Y^T，即 def-&gt;fed</span>
    reverse(s, <span class="dv">0</span>, n - <span class="dv">1</span>); <span class="co">//翻转[0..n - 1]，即如整个翻转，(X^TY^T)^T=YX，即 cbafed-&gt;defabc。</span>
}</code></pre>
<h1 id="第二章字符串是否包含问题">第二章：字符串是否包含问题</h1>
<h2 id="题目描述-1">题目描述</h2>
<p>假设这有一个各种字母组成的字符串A，和另外一个字符串B，字符串里B的字母数相对少一些。什么方法能最快的查出所有小字符串B里的字母在大字符串A里都有？为了简单起见，我们规定输入的字符串只包含大写英文字母。 实现函数bool compare(string &amp;A,string &amp;B)</p>
<p>比如，如果是下面两个字符串：</p>
<p>String 1: ABCDEFGHLMNOPQRS</p>
<p>String 2: DCGSRQPO</p>
<p>答案是true，所有在string2里的字母string1也都有。</p>
<p>如果是下面两个字符串：</p>
<p>String 1: ABCDEFGHLMNOPQRS</p>
<p>String 2: DCGSRQPZ</p>
<p>答案是false，因为第二个字符串里的Z字母不在第一个字符串里。</p>
<p>点评：</p>
<ol type="1">
<li><p>题目描述虽长，但题意简单明了，就是给定一长一短的俩个字符串A，B，假设A长B短，现在，要你判断B是否包含在字符串A中，即B?(-A。</p></li>
<li><p>题意虽简单，但实现起来并不轻松，且当如果面试官步步紧逼，一个一个否决你能想到的方法，要你给出更好、最好的方案时，你恐怕就要伤不少脑筋了。</p></li>
</ol>
<p>ok，在继续往下阅读之前，您最好先想个几分钟，看你能想到的最好方案是什么，是否与本文最后实现的方法一致。</p>
<h2 id="解法一暴力轮询">解法一、暴力轮询</h2>
<p>判断string2中的字符是否在string1中?：</p>
<p>String 1: ABCDEFGHLMNOPQRS</p>
<p>String 2: DCGSRQPO</p>
<p>判断一个字符串是否在另一个字符串中，最直观也是最简单的思路是，针对第二个字符串string2中每一个字符，一一与第一个字符串string1中每个字符依次轮询比较，看它是否在第一个字符串string1中。</p>
<p>代码可如下编写：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@caopengcs 2013-01-14</span>
<span class="dt">bool</span> compare(string &amp;a,string &amp;b)
{
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; b.length(); ++i) {
        <span class="dt">int</span> j;
        <span class="kw">for</span> (j = <span class="dv">0</span>; (j &lt; a.length()) &amp;&amp; (a[j] != b[i]); ++j)
            ;
        <span class="kw">if</span> (j &gt;= a.length())
        {
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
<p>假设n是字符串string1的长度，m是字符串string2的长度，那么此算法，需要O（n<em>m）次操作，拿上面的例子来说，最坏的情况下将会有16</em>8 = 128次操作。显然，时间开销太大，我们需要找到一种更好的办法。</p>
<h2 id="解法二普通排序">解法二、普通排序</h2>
<p>一个稍微好一点的方案是先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。</p>
<p>同样拿上面的字串做例子，将会需要16<em>4 + 8</em>3 = 88，再加上对两个字串线性扫描的16 + 8 = 24的操作。(随着字串长度的增长，你会发现这个算法的效果会越来越好)</p>
<p>关于采用何种排序方法，我们采用最常用的快速排序，C有库函数qsort,C++有库函数sort，很方便，排序不是我们这里的终点，因此使用库函数好一些。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@caopengcs 2014-01-14 </span>
<span class="co">//注意A B中可能包含重复字符，所以注意A下标不要轻易移动。这种方法改变了字符串。如不想改变请自己复制</span>
<span class="dt">bool</span> compare(string &amp;a,string &amp;b)
{
    sort(a.begin(),a.end());
    sort(b.begin(),b.end());
    <span class="kw">for</span> (<span class="dt">int</span> pa = <span class="dv">0</span>, pb = <span class="dv">0</span>; pb &lt; b.length();)
    {
        <span class="kw">while</span> ((pa &lt; a.length()) &amp;&amp; (a[pa] &lt; b[pb]))
        {
            ++pa;
        }
        <span class="kw">if</span> ((pa &gt;= a.length()) || (a[pa] &gt; b[pb]))
        {
            <span class="kw">return</span> <span class="kw">false</span>;
        }
        <span class="co">//a[pa] == b[pb]</span>
        ++pb;
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
<h2 id="解法三计数比较">解法三、计数比较</h2>
<p>此方案与上述思路相比，就是不需要排序。采用线性时间的计数方法，假设需要比较字符串A（n）中是否包含字符串B（m），统计A中出现的字符O(n)，比较B中是否有出现的字符O(m)，总计时间复杂度为：O(n+m)。</p>
<p>代码如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// copyright@caopengcs 2014-01-14</span>
<span class="co">// modified by @古道西风 2014-01-14</span>
<span class="dt">bool</span> compare(string &amp;a,string &amp;b)
{
    vector&lt;<span class="dt">int</span>&gt; have;
    have.resize(<span class="dv">26</span>,<span class="dv">0</span>);
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; a.length(); ++i)
    {
        ++have[a[i] - &#39;A&#39;];
    }
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; b.length(); ++i)
    {
        <span class="co">//若A中只需要包含同一个相同的字符即可代表B中重复出现的字符</span>
        <span class="co">//即A：CDEFAB B：AABBCC 合法</span>
        <span class="kw">if</span> (have[b[i] - &#39;A&#39;] == <span class="dv">0</span>)
        {
            <span class="kw">return</span> <span class="kw">false</span>;
        }
        <span class="co">//若A中需要包含B中所有重复出现字符</span>
        <span class="co">//即A：AAACCDBBCCE    B：AABBCC 合法</span>
        <span class="co">//即A：BCDEFA B：AABBCC 非法</span>
        <span class="co">//if (have[b[i] - &#39;A&#39;]-- == 0) {</span>
        <span class="co">//  return false;</span>
        <span class="co">//}</span>
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
<h2 id="解法四巧用hashtable">解法四、巧用hashtable</h2>
<p>上述方案中，较好的方法是先对字符串进行排序，然后再线性扫描，总的时间复杂度已经优化到了：O(m+n)，貌似到了极限，还有没有更好的办法列?</p>
<p>我们可以对短字串进行轮询（此思路的叙述可能与网上的一些叙述有出入，因为我们最好是应该把短的先存储，那样，会降低题目的时间复杂度），把其中的每个字母都放入一个Hashtable里（我们始终设m为短字符串的长度，那么此项操作成本是O(m)或8次操作）。然后轮询长字符串，在Hashtable里查询短字符串的每个字符，看能否找到。如果找不到，说明没有匹配成功，轮询长字符串将消耗掉16次操作，这样两项操作加起来一共只有8+16=24次。</p>
<p>当然，理想情况是如果长字串的前缀就为短字串，只需消耗8次操作，这样总共只需8+8=16次。</p>
<p>或如梦想天窗所说： 我之前用散列表做过一次，算法如下： 1. hash[26]，先全部清零，然后扫描短的字符串，若有相应的置1， 2. 计算hash[26]中1的个数，记为m 3. 扫描长字符串的每个字符a；若原来hash[a] == 1 ，则修改hash[a] = 0，并将m减1；若hash[a] == 0，则不做处理 4. 若m == 0 or 扫描结束，退出循环。</p>
<p>这种方法其实和1.3节方法类似。 代码实现，也不难，如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// copyright@caopengcs 2014-01-14</span>
<span class="dt">bool</span> compare(string &amp;a,string &amp;b)
{
    vector&lt;<span class="dt">int</span>&gt; hash;
    hash.resize(<span class="dv">26</span>,<span class="dv">0</span>);
    <span class="dt">int</span> m = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; b.length(); ++i)
    {
        <span class="dt">int</span> x = b[i] - &#39;A&#39;;
        <span class="kw">if</span> (hash[x] == <span class="dv">0</span>)
        {
            hash[x] = <span class="dv">1</span>;
            ++m;
        }
    }
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; a.length(); ++i)
    {
        <span class="dt">int</span> x = a[i] - &#39;A&#39;;
        <span class="kw">if</span> (hash[x] == <span class="dv">1</span>)
        {
            --m;
            hash[x] = <span class="dv">0</span>;
        }
    }
    <span class="kw">return</span> m == <span class="dv">0</span>;
}</code></pre>
<h2 id="解法五素数相乘">解法五、素数相乘</h2>
<p>我想问的是，还有更好的方案么?</p>
<p>你可能会这么想：O(n+m)是你能得到的最好的结果了，至少要对每个字母至少访问一次才能完成这项操作，而上一节最后的俩个方案是刚好是对每个字母只访问一次。</p>
<p>ok，下面给出一个更好的方案：</p>
<p>假设我们有一个一定个数的字母组成字串，我给每个字母分配一个素数，从2开始，往后类推。这样A将会是2，B将会是3，C将会是5，等等。现在我遍历第一个字串，把每个字母代表的素数相乘。你最终会得到一个很大的整数，对吧？</p>
<p>然后——轮询第二个字符串，用每个字母除它。如果除的结果有余数，这说明有不匹配的字母。如果整个过程中没有余数，你应该知道它是第一个字串恰好的子集了。</p>
<p>思路总结如下： 1. 定义最小的26个素数分别与字符'A'到'Z'对应。 2. 遍历长字符串，求得每个字符对应素数的乘积。 3. 遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。 4. 输出结果。</p>
<p>至此，如上所述，上述算法的时间复杂度为O(m+n)，时间复杂度最好的情况为O(n)（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回false），n为长字串的长度，空间复杂度为O(1)。如你所见，我们已经优化到了最好的程度。</p>
<p>不过，正如原文中所述：“现在我想告诉你 —— Guy的方案在算法上并不能说就比我的好。而且在实际操作中，你很可能仍会使用我的方案，因为它更通用，无需跟麻烦的大型数字打交道。但从”巧妙水平“上讲，Guy提供的是一种更、更、更有趣的方案。”</p>
<p>ok，如果你有更好的思路，欢迎在本文的评论中给出，非常感谢。 这种方法的缺点是可能整数溢出……</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// copyright@caopengcs </span>
<span class="co">//此方法只有理论意义 因为整数乘积很大 会溢出</span>
<span class="dt">bool</span> compare(string &amp;a,string &amp;b)
{
    <span class="dt">const</span> <span class="dt">int</span> p[<span class="dv">26</span>] = {<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">13</span>, <span class="dv">17</span>, <span class="dv">19</span>, <span class="dv">23</span>, <span class="dv">29</span>, <span class="dv">31</span>, <span class="dv">37</span>, <span class="dv">41</span>, <span class="dv">43</span>, <span class="dv">47</span>, <span class="dv">53</span>, <span class="dv">59</span>,<span class="dv">61</span>, <span class="dv">67</span>, <span class="dv">71</span>, <span class="dv">73</span>, <span class="dv">79</span>, <span class="dv">83</span>, <span class="dv">89</span>, <span class="dv">97</span>, <span class="dv">101</span>};
    <span class="dt">int</span> f = <span class="dv">1</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; a.length(); ++i)
    {
        <span class="dt">int</span> x = p[a[i] - &#39;A&#39;];
        <span class="kw">if</span> (f % x)
        {
            f *= x;
        }
    }
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; b.length(); ++i)
    {
        <span class="dt">int</span> x = p[b[i] - &#39;A&#39;];
        <span class="kw">if</span> (f % x)
        {
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
<h2 id="解法六位运算">解法六、位运算</h2>
<p>最好的思路是对字符串A,用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符A里面进行查找。这个方法的实质是用一个整数代替了hashtable，空间复杂度可以降低为O(1)。时间复杂度还是O(n + m)。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// copyright@caopengcs </span>
<span class="co">// “最好的方法”，时间复杂度O(n + m)，空间复杂度O(1)</span>
<span class="dt">bool</span> compare(string &amp;a,string &amp;b)
{
    <span class="dt">int</span> hash = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; a.length(); ++i)
    {
        hash |= (<span class="dv">1</span> &lt;&lt; (a[i] - &#39;A&#39;));
    }
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; b.length(); ++i)
    {
        <span class="kw">if</span> ((hash &amp; (<span class="dv">1</span> &lt;&lt; (b[i] - &#39;A&#39;))) == <span class="dv">0</span>)
        {
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
<h1 id="第三章寻找最小的-k-个数">第三章：寻找最小的 k 个数</h1>
<p>July：本第3章与原文 （http://blog.csdn.net/v_JULY_v/article/details/6370650 ）有太大出入，失去了通俗易懂的特点，哪位朋友重新给同步下？二零一四年一月。</p>
<h3 id="题目描述-2">题目描述：</h3>
<p>输入一个数组和整数k，从中找到最小的k个数，例如输入数组为A = {1,9,2,4,7,6,3}，整数k为3，则输出最小的3个数分别为{1,2,3}。</p>
<p>分析：学习和掌握了基本排序算法都知道，此问题可以通过排序来解决，即对A数组进行排序，然后输出前k个数即可，时间复杂度为O(n log n)；再者考虑到运行效率，对前k个数进行排序并维护一个长度为k的排序数组，然后向此输入中插入剩下的n-k（假设A数组大小为n）个数，这样做在k较小时效果较好，而当k的大小与n相近时，此方法的效果还不如前者。假设插入n-k的元素的过程采用二分搜索，则时间复杂度为O(k log k+(n-k) log k)。</p>
<p>而最简便的方法是通过构造堆结构来解决问题，即维护一个大小为k的最大堆的数据结构，然后将剩余的n-k个数依次插入此堆结构中，最后输出此数组即可，由于题目并没有要求要对这最小的k个数排序，故可直接输出。</p>
<h3 id="算法实现">算法实现：</h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">//获取父节点指针</span>
<span class="dt">int</span> GetParent(<span class="dt">int</span>* pArray, <span class="dt">int</span>* pLast)
{
    <span class="kw">if</span>(pLast &gt;= pArray)
        <span class="kw">return</span> (pLast - pArray + <span class="dv">1</span>) / <span class="dv">2</span> - <span class="dv">1</span>;
    <span class="kw">else</span>
        <span class="kw">return</span> -<span class="dv">1</span>;
}

<span class="co">//获取左孩子节点指针</span>
<span class="dt">int</span> GetLeft(<span class="dt">int</span>* pArray, <span class="dt">int</span>* pLast)
{
    <span class="kw">if</span>(pLast &gt;= pArray)
        <span class="kw">return</span> (pLast - pArray + <span class="dv">1</span>) * <span class="dv">2</span> - <span class="dv">1</span>;
    <span class="kw">else</span>
        <span class="kw">return</span> -<span class="dv">1</span>;
}

<span class="co">//获取右孩子节点指针</span>
<span class="dt">int</span> GetRight(<span class="dt">int</span>* pArray, <span class="dt">int</span>* pLast)
{
    <span class="kw">if</span>(pLast &gt;= pArray)
        <span class="kw">return</span> (pLast - pArray + <span class="dv">1</span>) * <span class="dv">2</span>;
    <span class="kw">else</span>
        <span class="kw">return</span> -<span class="dv">1</span>;
}

<span class="co">//交换两个元素的值</span>
<span class="dt">void</span> Swap(<span class="dt">int</span>* pa, <span class="dt">int</span>* pb)
{
    <span class="dt">int</span> temp = *pa;
    *pa = *pb;
    *pb = temp;
}

<span class="co">//最大化堆过程，保持最大堆性质，即父节点元素值大于等于其子孙节点元素</span>
<span class="dt">void</span> MaxHeapify(<span class="dt">int</span>* pArray, <span class="dt">const</span> <span class="dt">int</span> nLength, <span class="dt">const</span> <span class="dt">int</span> nI)
{
    <span class="kw">if</span>((nI &lt; <span class="dv">0</span>) || (pArray == NULL) || (nI &gt; nLength))
    {
        <span class="kw">return</span>;
    }

    <span class="dt">int</span> nLeft = GetLeft(pArray, pArray+nI);         <span class="co">//获取当前节点的左儿子索引</span>
    <span class="dt">int</span> nRight = GetRight(pArray, pArray+nI);       <span class="co">//获取当前节点的右儿子索引</span>
    <span class="dt">int</span>* pLargest = NULL;                           <span class="co">//初始化记录最大值的指针</span>

    <span class="co">//若当前元素小于左儿子，则对最大值指针赋值为左儿子指针</span>
    <span class="kw">if</span>((nLeft &lt; nLength) &amp;&amp; (*(pArray + nI) &lt; *(pArray + nLeft)))
    {
        pLargest = pArray + nLeft;
    }
    <span class="kw">else</span>
    {
        pLargest = pArray + nI;
    }

    <span class="co">//若右儿子元素大于最大值元素，则对最大值指针赋值</span>
    <span class="kw">if</span>((nRight &lt; nLength) &amp;&amp; (*(pLargest) &lt; *(pArray + nRight)))
    {
        pLargest = pArray + nRight;
    }

    <span class="co">//当前元素指针不为最大值，则交换最大值与当前元素值</span>
    <span class="kw">if</span>(pLargest != (pArray + nI))
    {
        Swap(pLargest, (pArray + nI));
        {
            <span class="co">//对交换后后的子堆递归进行堆的最大化过程</span>
            MaxHeapify(pArray, nLength, pLargest - pArray);
        }
    }
}

<span class="co">//建立最大堆函数</span>
<span class="dt">int</span> BuildMaxHeap(<span class="dt">int</span>* pArray, <span class="dt">int</span>* pLast)
{
    <span class="kw">if</span>((pArray == NULL) || (pLast == NULL))
    {
        <span class="kw">return</span> -<span class="dv">1</span>;
    }

    <span class="dt">int</span> nLength = pLast - pArray + <span class="dv">1</span>;   <span class="co">//获取当前堆数组长度</span>
    <span class="dt">int</span> nMid = nLength / <span class="dv">2</span>;

    <span class="co">//对数组的前半数据进行堆最大化过程，因为后半部分数据为叶子节点数据，已经保持了最大堆性质</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = nMid ; i &gt;= <span class="dv">0</span>; i--)
    {
        MaxHeapify(pArray, nLength, i);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">//寻找数组中最小的k个数，考虑到对空间的有效利用，这里数组pArray的前k项即为最小的k个数，函数正确返回0，错误返回-1</span>
<span class="dt">int</span> FindMinimumK(<span class="dt">int</span>* pArray, <span class="dt">int</span> nLength, <span class="dt">int</span> k)
{
    <span class="dt">int</span> nIndex = <span class="dv">0</span>;

    <span class="kw">if</span>((pArray == NULL) || (nLength &lt;= <span class="dv">0</span>) || (k &lt;= <span class="dv">0</span>))
        <span class="kw">return</span> -<span class="dv">1</span>;

    BuildMaxHeap(pArray, pArray + k - <span class="dv">1</span>);

    <span class="kw">for</span>(nIndex = k; nIndex &lt; nLength; nIndex++)
    {
        <span class="kw">if</span>(pArray[<span class="dv">0</span>] &gt; pArray[nIndex])
        {
            Swap(&amp;pArray[<span class="dv">0</span>], &amp;pArray[nIndex]);
            MaxHeapify(pArray, k, <span class="dv">0</span>);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> Array[] = {<span class="dv">9</span>, <span class="dv">8</span>, <span class="dv">6</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>};
    <span class="dt">int</span> k = <span class="dv">3</span>;
    <span class="dt">int</span> i = <span class="dv">0</span>;
    FindMinimumK(Array, <span class="kw">sizeof</span>(Array) / <span class="kw">sizeof</span>(<span class="dt">int</span>), k);
    cout &lt;&lt; <span class="st">&quot;The &quot;</span> &lt;&lt; k &lt;&lt; <span class="st">&quot; minimum numbers in Array are:&quot;</span> &lt;&lt; endl;
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; k; i++)
        cout &lt;&lt; Array[i] &lt;&lt; <span class="st">&quot; &quot;</span>;
    cout &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>同样，若想寻找最大的k个数，则可通过构造大小为k的最小堆来实现以上操作，读者可考虑如何通过修改以上代码完成。</p>
<h1 id="第三章续搜索引擎热门查询统计">第三章续：搜索引擎热门查询统计</h1>
<p><strong>题目描述</strong>： 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。<br />假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>分析：这个问题在之前的这篇文章<a href="http://blog.csdn.net/v_JULY_v/article/details/6256463">十一、从头到尾彻底解析Hash表算法</a>里，已经有所解答。方法是:</p>
<p><strong>第一步</strong>、先对这批海量数据预处理，在O(N)的时间内用Hash表完成统计；<br /><strong>第二步</strong>、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。<br />即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆（K1&gt;K2&gt;....Kmin，Kmin设为堆顶元素），然后遍历300万的Query，分别和根元素Kmin进行对比比较（如上第2节思路3所述，若X&gt;Kmin，则更新并调整堆，否则，不更新），我们最终的时间复杂度是：O(N) + N'*O(logK)，（N为1000万，N’为300万）。</p>
<p>或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<p>ok，本章里，咱们来实现这个问题，为了降低实现上的难度，假设这些记录全部是一些英文单词，即用户在搜索框里敲入一个英文单词，然后查询搜索结果，最后，要你统计输入单词中频率最大的前K个单词。ok，复杂问题简单化了之后，编写代码实现也相对轻松多了，画的简单示意图（绘制者，yansha），如下：</p>
<figure>
<img src="../images/3/3.1/3.1.1.jpg" />
</figure>
<p><strong>完整源码</strong>：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@yansha &amp;&amp;July</span>
<span class="co">//July、updated，2011.05.08</span>

<span class="co">//题目描述：</span>
<span class="co">//搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的</span>
<span class="co">//长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果</span>
<span class="co">//除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），</span>
<span class="co">//请你统计最热门的10个查询串，要求使用的内存不能超过1G。</span>

<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;assert.h&gt;</span>
using namespace std;

<span class="ot">#define HASHLEN 2807303</span>
<span class="ot">#define WORDLEN 30</span>

<span class="co">// 结点指针</span>
<span class="kw">typedef</span> <span class="kw">struct</span> node_no_space *ptr_no_space;
<span class="kw">typedef</span> <span class="kw">struct</span> node_has_space *ptr_has_space;
ptr_no_space head[HASHLEN];

<span class="kw">struct</span> node_no_space
{
    <span class="dt">char</span> *word;
    <span class="dt">int</span> count;
    ptr_no_space next;
};

<span class="kw">struct</span> node_has_space
{
    <span class="dt">char</span> word[WORDLEN];
    <span class="dt">int</span> count;
    ptr_has_space next;
};

<span class="co">// 最简单hash函数</span>
<span class="dt">int</span> hash_function(<span class="dt">char</span> <span class="dt">const</span> *p)
{
    <span class="dt">int</span> value = <span class="dv">0</span>;
    <span class="kw">while</span> (*p != &#39;/<span class="dv">0</span>&#39;)
    {
        value = value * <span class="dv">31</span> + *p++;
        <span class="kw">if</span> (value &gt; HASHLEN)
            value = value % HASHLEN;
    }
    <span class="kw">return</span> value;
}

<span class="co">// 添加单词到hash表</span>
<span class="dt">void</span> append_word(<span class="dt">char</span> <span class="dt">const</span> *str)
{
    <span class="dt">int</span> index = hash_function(str);
    ptr_no_space p = head[index];
    <span class="kw">while</span> (p != NULL)
    {
        <span class="kw">if</span> (strcmp(str, p-&gt;word) == <span class="dv">0</span>)
        {
            (p-&gt;count)++;
            <span class="kw">return</span>;
        }
        p = p-&gt;next;
    }

    <span class="co">// 新建一个结点</span>
    ptr_no_space q = new node_no_space;
    q-&gt;count = <span class="dv">1</span>;
    q-&gt;word = new <span class="dt">char</span> [strlen(str)+<span class="dv">1</span>];
    strcpy(q-&gt;word, str);
    q-&gt;next = head[index];
    head[index] = q;
}


<span class="co">// 将单词处理结果写入文件</span>
<span class="dt">void</span> write_to_file()
{
    FILE *fp = fopen(<span class="st">&quot;result.txt&quot;</span>, <span class="st">&quot;w&quot;</span>);
    assert(fp);

    <span class="dt">int</span> i = <span class="dv">0</span>;
    <span class="kw">while</span> (i &lt; HASHLEN)
    {
        <span class="kw">for</span> (ptr_no_space p = head[i]; p != NULL; p = p-&gt;next)
            fprintf(fp, <span class="st">&quot;%s  %d</span><span class="ch">\n</span><span class="st">&quot;</span>, p-&gt;word, p-&gt;count);
        i++;
    }
    fclose(fp);
}

<span class="co">// 从上往下筛选，保持小根堆</span>
<span class="dt">void</span> sift_down(node_has_space heap[], <span class="dt">int</span> i, <span class="dt">int</span> len)
{
    <span class="dt">int</span> min_index = -<span class="dv">1</span>;
    <span class="dt">int</span> left = <span class="dv">2</span> * i;
    <span class="dt">int</span> right = <span class="dv">2</span> * i + <span class="dv">1</span>;

    <span class="kw">if</span> (left &lt;= len &amp;&amp; heap[left].count &lt; heap[i].count)
        min_index = left;
    <span class="kw">else</span>
        min_index = i;

    <span class="kw">if</span> (right &lt;= len &amp;&amp; heap[right].count &lt; heap[min_index].count)
        min_index = right;

    <span class="kw">if</span> (min_index != i)
    {
        <span class="co">// 交换结点元素</span>
        swap(heap[i].count, heap[min_index].count);

        <span class="dt">char</span> buffer[WORDLEN];
        strcpy(buffer, heap[i].word);
        strcpy(heap[i].word, heap[min_index].word);
        strcpy(heap[min_index].word, buffer);

        sift_down(heap, min_index, len);
    }
}

<span class="co">// 建立小根堆</span>
<span class="dt">void</span> build_min_heap(node_has_space heap[], <span class="dt">int</span> len)
{
    <span class="kw">if</span> (heap == NULL)
        <span class="kw">return</span>;

    <span class="dt">int</span> index = len / <span class="dv">2</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = index; i &gt;= <span class="dv">1</span>; i--)
        sift_down(heap, i, len);
}

<span class="co">// 去除字符串前后符号</span>
<span class="dt">void</span> handle_symbol(<span class="dt">char</span> *str, <span class="dt">int</span> n)
{
    <span class="kw">while</span> (str[n] &lt; &#39;<span class="dv">0</span>&#39; || (str[n] &gt; &#39;<span class="dv">9</span>&#39; &amp;&amp; str[n] &lt; &#39;A&#39;) || (str[n] &gt; &#39;Z&#39; &amp;&amp; str[n] &lt; &#39;a&#39;) || str[n] &gt; &#39;z&#39;)
    {
        str[n] = &#39;/<span class="dv">0</span>&#39;;
        n--;
    }

    <span class="kw">while</span> (str[<span class="dv">0</span>] &lt; &#39;<span class="dv">0</span>&#39; || (str[<span class="dv">0</span>] &gt; &#39;<span class="dv">9</span>&#39; &amp;&amp; str[<span class="dv">0</span>] &lt; &#39;A&#39;) || (str[<span class="dv">0</span>] &gt; &#39;Z&#39; &amp;&amp; str[<span class="dv">0</span>] &lt; &#39;a&#39;) || str[<span class="dv">0</span>] &gt; &#39;z&#39;)
    {
        <span class="dt">int</span> i = <span class="dv">0</span>;
        <span class="kw">while</span> (i &lt; n)
        {
            str[i] = str[i<span class="dv">+1</span>];
            i++;
        }
        str[i] = &#39;/<span class="dv">0</span>&#39;;
        n--;
    }
}

<span class="dt">int</span> main()
{
    <span class="dt">char</span> str[WORDLEN];
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; HASHLEN; i++)
        head[i] = NULL;

    <span class="co">// 将字符串用hash函数转换成一个整数并统计出现频率</span>
    FILE *fp_passage = fopen(<span class="st">&quot;string.txt&quot;</span>, <span class="st">&quot;r&quot;</span>);
    assert(fp_passage);
    <span class="kw">while</span> (fscanf(fp_passage, <span class="st">&quot;%s&quot;</span>, str) != EOF)
    {
        <span class="dt">int</span> n = strlen(str) - <span class="dv">1</span>;
        <span class="kw">if</span> (n &gt; <span class="dv">0</span>)
            handle_symbol(str, n);
        append_word(str);
    }
    fclose(fp_passage);

    <span class="co">// 将统计结果输入文件</span>
    write_to_file();

    <span class="dt">int</span> n = <span class="dv">10</span>;
    ptr_has_space heap = new node_has_space [n<span class="dv">+1</span>];

    <span class="dt">int</span> c;

    FILE *fp_word = fopen(<span class="st">&quot;result.txt&quot;</span>, <span class="st">&quot;r&quot;</span>);
    assert(fp_word);
    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= n; j++)
    {
        fscanf(fp_word, <span class="st">&quot;%s %d&quot;</span>, &amp;str, &amp;c);
        heap[j].count = c;
        strcpy(heap[j].word, str);
    }

    <span class="co">// 建立小根堆</span>
    build_min_heap(heap, n);

    <span class="co">// 查找出现频率最大的10个单词</span>
    <span class="kw">while</span> (fscanf(fp_word, <span class="st">&quot;%s %d&quot;</span>, &amp;str, &amp;c) != EOF)
    {
        <span class="kw">if</span> (c &gt; heap[<span class="dv">1</span>].count)
        {
            heap[<span class="dv">1</span>].count = c;
            strcpy(heap[<span class="dv">1</span>].word, str);
            sift_down(heap, <span class="dv">1</span>, n);
        }
    }
    fclose(fp_word);

    <span class="co">// 输出出现频率最大的单词</span>
    <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">1</span>; k &lt;= n; k++)
        cout &lt;&lt; heap[k].count &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; heap[k].word &lt;&lt; endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p><strong>程序测试</strong>：咱们接下来，来对下面的通过用户输入单词后，搜索引擎记录下来，“大量”单词记录进行统计（同时，令K=10，即要你找出10个最热门查询的单词）：</p>
<figure>
<img src="../images/3/3.1/3.1.2.jpg" />
</figure>
<p><strong>运行结果</strong>：根据程序的运行结果，可以看到，搜索引擎记录下来的查询次数最多的10个单词为（注，并未要求这10个数要有序输出）：in（312次），it（384次），a（432），that（456），MPQ（408），of（504），and（624），is（456），the（1008），to（936）。</p>
<figure>
<img src="../images/3/3.1/3.1.3.jpg" />
</figure>
<p><strong>读者反馈from 杨忠胜</strong>：3.1节的代码第38行 hash_function(char const *p)有误吧，这样的话，不能修改p的值（但是函数需要修改指针的值），要想不修改*p指向的内容，应该是const char *p; 此外，您程序中的/t, /n有误，C语言是,。<br />  感谢这位读者的来信，日后统一订正。谢谢。</p>
<h3 id="扩展统计出现次数最多的数据">扩展、统计出现次数最多的数据</h3>
<p><strong>题目描述</strong>： 给你上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</p>
<p>分析：上千万或上亿的数据，现在的机器的内存应该能存下（也许可以，也许不可以）。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了。当然，也可以堆实现。</p>
<p>ok，此题与上题类似，最好的方法是用hash_map统计出现的次数，然后再借用堆找出出现次数最多的N个数据。不过，上一题统计搜索引擎最热门的查询已经采用过hash表统计单词出现的次数，特此，本题咱们改用红黑树取代之前的用hash表，来完成最初的统计，然后用堆更新，找出出现次数最多的前N个数据。</p>
<h1 id="第三章再续快速选择select算法的深入分析与实现">第三章再续：快速选择SELECT算法的深入分析与实现</h1>
<h2 id="第一部分快速排序">第一部分、快速排序</h2>
<p>关于快速排序算法，本人已经写了3篇文章（可参见其中的两篇： 1、十二、快速排序算法之所有版本的c/c++实现， 2、一之续、快速排序算法的深入分析），</p>
<p>为何又要旧事重提列？正如很多事物都有相似的地方，而咱们面临的问题--快速选择算法中的划分过程等同于快速排序，所以，在分析快速选择SELECT算法之前，咱们先再来简单回顾和分析下快速排序，ok，今天看到Mark的数据结构与算法分析-c语言描述一书上对快速排序也有不错的介绍，所以为了增加点新鲜感，就不用自己以前的文章而改为直接引用Mark的叙述了：</p>
<p>As its name implies, quicksort is the fastest known sorting algorithm in practice. Its average running time is O(n log n)（快速排序是实践中已知的最快的排序算法，他的平均运行时间为O(N*logN)）. It is very fast, mainly due to a very tight and highly optimized inner loop. It has O(n^2) worst-case performance（最坏情形的性能为O(N^2)）, but this can be made exponentially unlikely with a little effort.</p>
<p>The quicksort algorithm is simple to understand and prove correct, although for many years it had the reputation of being an algorithm that could in theory be highly optimized but in practice was impossible to code correctly (no doubt because of FORTRAN).</p>
<p>Like mergesort, quicksort is a divide-and-conquer recursive algorithm（像归并排序一样，快速排序也是一种采取分治方法的递归算法）. The basic algorithm to sort an array S consists of the following four easy steps（通过下面的4个步骤将数组S排序的算法如下）:</p>
<ol type="1">
<li>If the number of elements in S is 0 or 1, then return（如果S中元素个数是0或1，则返回）.</li>
<li>Pick any element v in S. This is called the pivot（取S中任一元素v，作为枢纽元）.</li>
<li>Partition S - {v} (the remaining elements in S) into two disjoint groups（枢纽元v将S中其余的元素分成两个不相交的集合）: S1 = {x(- S-{v}| x &lt;= v}, and S2 = {x(- S-{v}| x &gt;= v}.</li>
<li>Return { quicksort(S1) followed by v followed by quicksort(S2)}.</li>
</ol>
<p>下面依据上述步骤对序列13,81,92,43,65,31,57,26,75,0 进行第一趟划分处理，可得到如下图所示的过程：</p>
<figure>
<img src="../images/3/3.2/3.2.1.jpg" />
</figure>
<p>1.2、选取枢纽元的几种方法 1、糟糕的方法 通常的做法是选择数组中第一个元素作为枢纽元，如果输入是随机的，那么这是可以接受的。但是，如果输入序列是预排序的或者是反序的，那么依据这样的枢纽元进行划分则会出现相当糟糕的情况，因为可能所有的元素不是被划入S1，就是都被划入S2中。 2、较好的方法 一个比较好的做法是随机选取枢纽元，一般来说，这种策略是比较妥当的。 3、三数取取中值方法 例如，输入序列为 8, 1, 4, 9, 6, 3, 5, 2, 7, 0 ，它的左边元素为8，右边元素为0，中间位置|<em>left+right）/2</em>|上的元素为6，于是枢纽元为6.显然，使用三数中值分割法消除了预排序输入的坏情形，并且减少了快速排序大约5%（此为前人实验所得数据，无法具体证明）的运行时间。</p>
<p>1.3、划分过程 下面，我们再对序列8, 1, 4, 9, 6, 3, 5, 2, 7, 0进行第一趟划分，我们要达到的划分目的就是为了把所有小于枢纽元（据三数取中分割法取元素6为枢纽元）的元素移到数组的左边，而把所有大于枢纽元的元素全部移到数组的右边。</p>
<p>此过程，如下述几个图所示：</p>
<pre><code>8  1  4  9  0  3  5  2  7  6
i                               j

8  1  4  9  0  3  5  2  7  6
i                           j</code></pre>
<pre><code>     After First Swap：
----------------------------
2  1  4  9  0  3  5  8  7  6
i                           j</code></pre>
<pre><code>     Before Second Swap：
----------------------------
2  1  4  9  0  3  5  8  7  6
     i           j</code></pre>
<pre><code>     After Second Swap：
----------------------------
2  1  4  5  0  3  9  8  7  6
     i           j</code></pre>
<pre><code>     Before Third Swap
----------------------------
2  1  4  5  0  3  9  8  7  6
     j   i   //i，j在元素3处碰头之后，i++指向了9，最后与6交换后，得到：</code></pre>
<pre><code>2  1  4  5  0  3  6  8  7  9
     i         pivot
</code></pre>
<p>至此，第一趟划分过程结束，枢纽元6将整个序列划分成了左小右大两个部分。</p>
<p>1.4、四个细节</p>
<p>下面，是4个值得你注意的细节问题： 1、我们要考虑一下，就是如何处理那些等于枢纽元的元素，问题在于当i遇到第一个等于枢纽元的关键字时，是否应该停止移动i，或者当j遇到一个等于枢纽元的元素时是否应该停止移动j。 答案是：如果i，j遇到等于枢纽元的元素，那么我们就让i和j都停止移动。</p>
<p>2、对于很小的数组，如数组的大小N&lt;=20时，快速排序不如插入排序好。</p>
<p>3、只通过元素间进行比较达到排序目的的任何排序算法都需要进行O（N<em>logN）次比较，如快速排序算法（最坏O（N^2），最好O（N</em>logN）），归并排序算法（最坏O（N*logN，不过归并排序的问题在于合并两个待排序的序列需要附加线性内存，在整个算法中，还要将数据拷贝到临时数组再拷贝回来这样一些额外的开销，放慢了归并排序的速度）等。</p>
<p>4、下面是实现三数取中的划分方法的程序：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//三数取中分割法</span>
input_type median3( input_type a[], <span class="dt">int</span> left, <span class="dt">int</span> right )
<span class="co">//下面的快速排序算法实现之一，及通过三数取中分割法寻找最小的k个数的快速选择SELECT算法都要调用这个median3函数</span>
{
    <span class="dt">int</span> center;
    center = (left + right) / <span class="dv">2</span>;

    <span class="kw">if</span>( a[left] &gt; a[center] )
        swap( &amp;a[left], &amp;a[center] );
    <span class="kw">if</span>( a[left] &gt; a[right] )
        swap( &amp;a[left], &amp;a[right] );
    <span class="kw">if</span>( a[center] &gt; a[right] )
        swap( &amp;a[center], &amp;a[right] );

    <span class="co">/* invariant: a[left] &lt;= a[center] &lt;= a[right] */</span>
    swap( &amp;a[center], &amp;a[right<span class="dv">-1</span>] );     <span class="co">/* hide pivot */</span>
    <span class="kw">return</span> a[right<span class="dv">-1</span>];                   <span class="co">/* return pivot */</span>
}</code></pre>
<p>下面的程序是利用上面的三数取中分割法而运行的快速排序算法：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//快速排序的实现之一</span>
<span class="dt">void</span> q_sort( input_type a[], <span class="dt">int</span> left, <span class="dt">int</span> right )
{
    <span class="dt">int</span> i, j;
    input_type pivot;
    <span class="kw">if</span>( left + CUTOFF &lt;= right )
    {
        pivot = median3( a, left, right );   <span class="co">//调用上面的实现三数取中分割法的median3函数</span>
        i=left; j=right<span class="dv">-1</span>;   <span class="co">//第8句</span>
        <span class="kw">for</span>(;;)
        {
            <span class="kw">while</span>( a[++i] &lt; pivot );
            <span class="kw">while</span>( a[--j] &gt; pivot );
            <span class="kw">if</span>( i &lt; j )
                swap( &amp;a[i], &amp;a[j] );
            <span class="kw">else</span>
                <span class="kw">break</span>;       <span class="co">//第16句</span>
        }
        swap( &amp;a[i], &amp;a[right<span class="dv">-1</span>] );   <span class="co">/*restore pivot*/</span>
        q_sort( a, left, i<span class="dv">-1</span> );
        q_sort( a, i<span class="dv">+1</span>, right );

        <span class="co">//如上所见，在划分过程（partition）后，快速排序需要两次递归，一次对左边递归</span>
        <span class="co">//一次对右边递归。下面，你将看到，快速选择SELECT算法始终只对一边进行递归。</span>
        <span class="co">//这从直观上也能反应出：此快速排序算法（O（N*logN））明显会比</span>
        <span class="co">//下面第二节中的快速选择SELECT算法（O（N））平均花费更多的运行时间。</span>
    }
}</code></pre>
<p>如果上面的第8-16句，改写成以下这样：</p>
<pre class="sourceCode c"><code class="sourceCode c">i = left + <span class="dv">1</span>;
j = right - <span class="dv">2</span>;
<span class="kw">for</span> (;;)
{
    <span class="kw">while</span> ( a[i] &lt; pivot ) i++;
    <span class="kw">while</span> ( a[j] &gt; pivot ) j--;
    <span class="kw">if</span> ( i &lt; j )
        swap( &amp;a[i], &amp;a[j] );
    <span class="kw">else</span>
        <span class="kw">break</span>;
}</code></pre>
<p>那么，当a[i] = a[j] = pivot则会产生无限，即死循环（相信，不用我多余解释，:D）。ok，接下来，咱们将进入正题--快速选择SELECT算法。</p>
<h2 id="第二部分线性期望时间的快速选择select算法">第二部分、线性期望时间的快速选择SELECT算法</h2>
<p>2.1、快速选择SELECT算法的介绍</p>
<p>Quicksort can be modified to solve the selection problem, which we have seen in chapters 1 and 6. Recall that by using a priority queue, we can find the kth largest (or smallest) element in O(n + k log n)（以用最小堆初始化数组，然后取这个优先队列前k个值，复杂度O(n)+k<em>O(log n)。实际上，最好采用最大堆寻找最小的k个数，那样，此时复杂度为n</em>logk。更多详情，请参见：狂想曲系列第三章、寻找最小的k个数）. For the special case of finding the median, this gives an O(n log n) algorithm.</p>
<p>Since we can sort the file in O(nlog n) time, one might expect to obtain a better time bound for selection. The algorithm we present to find the kth smallest element in a set S is almost identical to quicksort. In fact, the first three steps are the same. We will call this algorithm quickselect（叫做快速选择）. Let |Si| denote the number of elements in Si（令|Si|为Si中元素的个数）. The steps of quickselect are:</p>
<ol type="1">
<li>If |S| = 1, then k = 1 and return the elements in S as the answer. If a cutoff for small files is being used and |S| &lt;=CUTOFF, then sort S and return the kth smallest element.</li>
<li>Pick a pivot element, v (- S.（选取一个枢纽元v属于S）</li>
<li><p>Partition S - {v} into S1 and S2, as was done with quicksort. （ &gt; 集合S-{v}分割成S1和S2，就像我们在快速排序中所作的那样）</p></li>
<li><p>If k &lt;= |S1|, then the kth smallest element must be in S1. In this case, return quickselect (S1, k). If k = 1 + |S1|, then the pivot is the kth smallest element and we can return it as the answer. Otherwise, the kth smallest element lies in S2, and it is the (k - |S1| - 1)st smallest element in S2. We make a recursive call and return quickselect (S2, k - |S1| - 1). （ &gt; 果k&lt;=|S1|，那么第k个最小元素必然在S1中。在这种情况下，返回quickselect（S1,k）。如果k=1+|S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。否则，这第k个最小元素就在S2中，即S2中的第（k-|S1|-1）个最小元素，我们递归调用并返回quickselect（S2，k-|S1|-1））（下面几节的程序关于k的表述可能会有所出入，但无碍，抓住原理即ok）。</p></li>
</ol>
<p>In contrast to quicksort, quickselect makes only one recursive call instead of two. The worst case of quickselect is identical to that of quicksort and is O(n2). Intuitively, this is because quicksort's worst case is when one of S1 and S2 is empty; thus, quickselect（快速选择） is not really saving a recursive call. The average running time, however, is O(n)（不过，其平均运行时间为O（N）。看到了没，就是平均复杂度为O（N）这句话）. The analysis is similar to quicksort's and is left as an exercise.</p>
<p>The implementation of quickselect is even simpler than the abstract description might imply. The code to do this shown in Figure 7.16. When the algorithm terminates, the kth smallest element is in position k. This destroys the original ordering; if this is not desirable, then a copy must be made.</p>
<p>2.2、三数中值分割法寻找第k小的元素</p>
<p>第一节，已经介绍过此三数中值分割法，有个细节，你要注意，即数组元素索引是从“0...i”开始计数的，所以第k小的元素应该是返回a[i]=a[k-1].即k-1=i。换句话就是说，第k小元素，实际上应该在数组中对应下标为k-1。ok，下面给出三数中值分割法寻找第k小的元素的程序的两个代码实现：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//代码实现一</span>
<span class="co">//copyright@ mark allen weiss</span>
<span class="co">//July、updated，2011.05.05凌晨.</span>

<span class="co">//三数中值分割法寻找第k小的元素的快速选择SELECT算法</span>
<span class="dt">void</span> q_select( input_type a[], <span class="dt">int</span> k, <span class="dt">int</span> left, <span class="dt">int</span> right )
{
    <span class="dt">int</span> i, j;
    input_type pivot;
    <span class="kw">if</span>( left <span class="co">/*+ CUTOFF*/</span> &lt;= right )  <span class="co">//去掉CUTOFF常量，无用</span>
    {
       pivot = median3( a, left, right );   <span class="co">//调用1、4节里的实现三数取中分割法的median3函数</span>
       <span class="co">//取三数中值作为枢纽元，可以消除最坏情况而保证此算法是O（N）的。不过，这还只局限在理论意义上。</span>
       <span class="co">//稍后，您将看到另一种选取枢纽元的方法。</span>

       i=left; j=right<span class="dv">-1</span>;
       <span class="kw">for</span>(;;)  <span class="co">//此句到下面的九行代码，即为快速排序中的partition过程的实现之一</span>
       {
           <span class="kw">while</span>( a[++i] &lt; pivot ){}
           <span class="kw">while</span>( a[--j] &gt; pivot ){}
           <span class="kw">if</span> (i &lt; j )
               swap( &amp;a[i], &amp;a[j] );
           <span class="kw">else</span>
               <span class="kw">break</span>;
       }
       swap( &amp;a[i], &amp;a[right<span class="dv">-1</span>] ); <span class="co">/* restore pivot */</span>
       <span class="kw">if</span>( k &lt; i)
           q_select( a, k, left, i<span class="dv">-1</span> );
       <span class="kw">else</span>
           <span class="kw">if</span>( k<span class="dv">-1</span> &gt; i )  <span class="co">//此条语句相当于：if(k&gt;i+1)</span>
               q-select( a, k, i<span class="dv">+1</span>, right );
           <span class="co">//1、希望你已经看到，通过上面的if-else语句表明，此快速选择SELECT算法始终只对数组的一边进行递归，</span>
           <span class="co">//这也是其与第一节中的快速排序算法的本质性区别。</span>

           <span class="co">//2、这个区别则直接决定了：快速排序算法最快能达到O（N*logN），</span>
           <span class="co">//而快速选择SELECT算法则最坏亦能达到O（N）的线性时间复杂度。</span>
           <span class="co">//3、而确保快速选择算法最坏情况下能做到O（N）的根本保障在于枢纽元元素的选取，</span>
           <span class="co">//即采取稍后的2.3节里的五分化中项的中项，或2.4节里的中位数的中外位数的枢纽元选择方法达到O（N）的目的。</span>
           <span class="co">//后天老爸生日，孩儿深深祝福。July、updated，2011.05.19。</span>
    }
    <span class="kw">else</span>
       insert_sort(a, left, right-left<span class="dv">+1</span> );
}</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//代码实现二</span>
<span class="co">//copyright @ 飞羽</span>
<span class="co">//July、updated，2011.05.11。</span>
<span class="co">//三数中值分割法寻找第k小的元素</span>
bool median_select(<span class="dt">int</span> array[], <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> k)
{
    <span class="co">//第k小元素，实际上应该在数组中下标为k-1</span>
    <span class="kw">if</span> (k<span class="dv">-1</span> &gt; right || k<span class="dv">-1</span> &lt; left)
        <span class="kw">return</span> false;

    <span class="co">//三数中值作为枢纽元方法，关键代码就是下述六行：</span>
    <span class="dt">int</span> midIndex=(left+right)/<span class="dv">2</span>;
    <span class="kw">if</span>(array[left]&lt;array[midIndex])
        swap(array[left],array[midIndex]);
    <span class="kw">if</span>(array[right]&lt;array[midIndex])
        swap(array[right],array[midIndex]);
    <span class="kw">if</span>(array[right]&lt;array[left])
        swap(array[right],array[left]);
    swap(array[midIndex], array[right]);

    <span class="dt">int</span> pos = partition(array, left, right);

    <span class="kw">if</span> (pos == k<span class="dv">-1</span>)   <span class="co">//第k小元素，实际上应该在数组中下标为k-1</span>
        <span class="kw">return</span> true;
    <span class="kw">else</span> <span class="kw">if</span> (pos &gt; k<span class="dv">-1</span>)
        <span class="kw">return</span> median_select(array, left, pos<span class="dv">-1</span>, k);
    <span class="kw">else</span> <span class="kw">return</span> median_select(array, pos<span class="dv">+1</span>, right, k);
}</code></pre>
<p>上述程序使用三数中值作为枢纽元的方法可以使得最坏情况发生的概率几乎可以忽略不计。然而，稍后，您将看到：通过一种更好的方法，如“五分化中项的中项”，或“中位数的中位数”等方法选取枢纽元，我们将能彻底保证在最坏情况下依然是线性O（N）的复杂度。即，如稍后2.3节所示。</p>
<p>2.3、五分化中项的中项，确保O（N）</p>
<p>The selection problem requires us to find the kth smallest element in a list S of n elements（要求我们找出含N个元素的表S中的第k个最小的元素）. Of particular interest is the special case of finding the median. This occurs when k = |-n/2-|（向上取整）.（我们对找出中间元素的特殊情况有着特别的兴趣，这种情况发生在k=|-n/2-|的时候）</p>
<p>In Chapters 1, 6, 7 we have seen several solutions to the selection problem. The solution in Chapter 7 uses a variation of quicksort and runs in O(n) average time（第7章中的解法，即本文上面第1节所述的思路4，用到快速排序的变体并以平均时间O（N）运行）. Indeed, it is described in Hoare's original paper on quicksort.</p>
<p>Although this algorithm runs in linear average time, it has a worst case of O (n2)（但它有一个O（N^2）的最快情况）. Selection can easily be solved in O(n log n) worst-case time by sorting the elements, but for a long time it was unknown whether or not selection could be accomplished in O(n) worst-case time. The quickselect algorithm outlined in Section 7.7.6 is quite efficient in practice, so this was mostly a question of theoretical interest.</p>
<p>Recall that the basic algorithm is a simple recursive strategy. Assuming that n is larger than the cutoff point where elements are simply sorted, an element v, known as the pivot, is chosen. The remaining elements are placed into two sets, S1 and S2. S1 contains elements that are guaranteed to be no larger than v, and S2 contains elements that are no smaller than v. Finally, if k &lt;= |S1|, then the kth smallest element in S can be found by recursively computing the kth smallest element in S1. If k = |S1| + 1, then the pivot is the kth smallest element. Otherwise, the kth smallest element in S is the (k - |S1| -1 )st smallest element in S2. The main difference between this algorithm and quicksort is that there is only one subproblem to solve instead of two（这个快速选择算法与快速排序之间的主要区别在于，这里求解的只有一个子问题，而不是两个子问题）。</p>
<p>定理10.9 The running time of quickselect using median-of-median-of-five partitioning is O(n)。</p>
<p>The basic idea is still useful. Indeed, we will see that we can use it to improve the expected number of comparisons that quickselect makes. To get a good worst case, however, the key idea is to use one more level of indirection. Instead of finding the median from a sample of random elements, we will find the median from a sample of medians.</p>
<p>The basic pivot selection algorithm is as follows: 1. Arrange the n elements into |<em>n/5</em>| groups of 5 elements, ignoring the (at most four) extra elements. 2. Find the median of each group. This gives a list M of |<em>n/5</em>| medians. 3. Find the median of M. Return this as the pivot, v.</p>
<p>We will use the term median-of-median-of-five partitioning to describe the quickselect algorithm that uses the pivot selection rule given above. （我们将用术语“五分化中项的中项”来描述使用上面给出的枢纽元选择法的快速选择算法）。We will now show that median-of-median-of-five partitioning guarantees that each recursive subproblem is at most roughly 70 percent as large as the original（现在我们要证明，“五分化中项的中项”，得保证每个递归子问题的大小最多为原问题的大约70%）. We will also show that the pivot can be computed quickly enough to guarantee an O (n) running time for the entire selection algorithm（我们还要证明，对于整个选择算法，枢纽元可以足够快的算出，以确保O（N）的运行时间。看到了没，这再次佐证了我们的类似快速排序的partition过程的分治方法为O（N）的观点）（更多详细的证明，请参考：第三章、寻找最小的k个数）。</p>
<p>2.4、中位数的中位数，O（N）的再次论证</p>
<p>以下内容来自算法导论第九章第9.3节全部内容（最坏情况线性时间的选择），如下（我酌情对之参考原中文版做了翻译，下文中括号内的中文解释，为我个人添加）：</p>
<p>9.3 Selection in worst-case linear time（最坏情况下线性时间的选择算法）</p>
<p>We now examine a selection algorithm whose running time is O(n) in the worst case（现在来看，一个最坏情况运行时间为O（N）的选择算法SELECT）. Like RANDOMIZED-SELECT, the algorithm SELECT finds the desired element by recursively partitioning the input array. The idea behind the algorithm, however, is to guarantee a good split when the array is partitioned. SELECT uses the deterministic partitioning algorithm PARTITION from quicksort (see Section 7.1), modified to take the element to partition around as an input parameter（像RANDOMIZED-SELECT一样，SELECTT通过输入数组的递归划分来找出所求元素，但是，该算法的基本思想是要保证对数组的划分是个好的划分。SECLECT采用了取自快速排序的确定性划分算法partition，并做了修改，把划分主元元素作为其参数）.</p>
<p>The SELECT algorithm determines the ith smallest of an input array of n &gt; 1 elements by executing the following steps. (If n = 1, then SELECT merely returns its only input value as the ith smallest.)（算法SELECT通过执行下列步骤来确定一个有n&gt;1个元素的输入数组中的第i小的元素。（如果n=1，则SELECT返回它的唯一输入数值作为第i个最小值。））</p>
<p>Divide the n elements of the input array into ⌊n/5⌋ groups of 5 elements each and at most one group made up of the remaining n mod 5 elements.</p>
<p>Find the median of each of the ⌈n/5⌉ groups by first insertion sorting the elements of each group (of which there are at most 5) and then picking the median from the sorted list of group elements. Use SELECT recursively to find the median x of the ⌈n/5⌉ medians found in step 2. (If there are an even number of medians, then by our convention, x is the lower median.)</p>
<p>Partition the input array around the median-of-medians x using the modified version of PARTITION. Let k be one more than the number of elements on the low side of the partition, so that x is the kth smallest element and there are n-k elements on the high side of the partition.（利用修改过的partition过程，按中位数的中位数x对输入数组进行划分，让k比划低去的元素数目多1，所以，x是第k小的元素，并且有n-k个元素在划分的高区）</p>
<p>If i = k, then return x. Otherwise, use SELECT recursively to find the ith smallest element on the low side if i &lt; k, or the (i - k)th smallest element on the high side if i &gt; k.（如果要找的第i小的元素等于程序返回的k，即i=k，则返回x。否则，如果i &lt; k，则在低区递归调用SELECT以找出第i小的元素，如果i &gt; k，则在高区间找第（i-k）个最小元素）</p>
<p>（以上五个步骤，即本文上面的第四节末中所提到的所谓“五分化中项的中项”的方法。）</p>
<p>To analyze the running time of SELECT, we first determine a lower bound on the number of elements that are greater than the partitioning element x. （为了分析SELECT的运行时间，先来确定大于划分主元元素x的的元素数的一个下界）Figure 9.1 is helpful in visualizing this bookkeeping. At least half of the medians found in step 2 are greater than[1] the median-of-medians x. Thus, at least half of the ⌈n/5⌉ groups contribute 3 elements that are greater than x, except for the one group that has fewer than 5 elements if 5 does not divide n exactly, and the one group containing x itself. Discounting these two groups, it follows that the number of elements greater than x is at least：</p>
<p>Figure 9.1: 对上图的解释或称对SELECT算法的分析：n个元素由小圆圈来表示，并且每一个组占一纵列。组的中位数用白色表示，而各中位数的中位数x也被标出。（当寻找偶数数目元素的中位数时，使用下中位数）。箭头从比较大的元素指向较小的元素，从中可以看出，在x的右边，每一个包含5个元素的组中都有3个元素大于x，在x的左边，每一个包含5个元素的组中有3个元素小于x。大于x的元素以阴影背景表示。 ）</p>
<p>Similarly, the number of elements that are less than x is at least 3n/10 - 6. Thus, in the worst case, SELECT is called recursively on at most 7n/10 + 6 elements in step 5.</p>
<p>We can now develop a recurrence for the worst-case running time T(n) of the algorithm SELECT. Steps 1, 2, and 4 take O(n) time. (Step 2 consists of O(n) calls of insertion sort on sets of size O(1).) Step 3 takes time T(⌈n/5⌉), and step 5 takes time at most T(7n/10+ 6), assuming that T is monotonically increasing. We make the assumption, which seems unmotivated at first, that any input of 140 or fewer elements requires O(1) time; the origin of the magic constant 140 will be clear shortly. We can therefore obtain the recurrence：</p>
<p>We show that the running time is linear by substitution. More specifically, we will show that T(n) ≤ cn for some suitably large constant c and all n &gt; 0. We begin by assuming that T(n) ≤ cn for some suitably large constant c and all n ≤ 140; this assumption holds if c is large enough. We also pick a constant a such that the function described by the O(n) term above (which describes the non-recursive component of the running time of the algorithm) is bounded above by an for all n &gt; 0. Substituting this inductive hypothesis into the right-hand side of the recurrence yields</p>
<pre><code>T(n) ≤ c[n/5] + c(7n/10 + 6) + an
     ≤ cn/5 + c + 7cn/10 + 6c + an
     = 9cn/10 + 7c + an
     = cn + (-cn/10 + 7c + an) ,</code></pre>
<p>which is at most cn if</p>
<pre><code>-cn/10 + 7c + an &lt;= 0</code></pre>
<p>Inequality (9.2) is equivalent to the inequality c ≥ 10a(n/(n - 70)) when n &gt; 70. Because we assume that n ≥ 140, we have n/(n - 70) ≤ 2, and so choosing c ≥ 20a will satisfy inequality (9.2). (Note that there is nothing special about the constant 140; we could replace it by any integer strictly greater than 70 and then choose c accordingly.) The worst-case running time of SELECT is therefore linear（因此，此SELECT的最坏情况的运行时间是线性的）.</p>
<p>As in a comparison sort (see Section 8.1), SELECT and RANDOMIZED-SELECT determine information about the relative order of elements only by comparing elements. Recall from Chapter 8 that sorting requires Ω(n lg n) time in the comparison model, even on average (see Problem 8-1). The linear-time sorting algorithms in Chapter 8 make assumptions about the input. In contrast, the linear-time selection algorithms in this chapter do not require any assumptions about the input. They are not subject to the Ω(n lg n) lower bound because they manage to solve the selection problem without sorting.</p>
<p>（与比较排序（算法导论8.1节）中的一样，SELECT和RANDOMIZED-SELECT仅通过元素间的比较来确定它们之间的相对次序。在算法导论第8章中，我们知道在比较模型中，即使在平均情况下，排序仍然要O（n<em>logn）的时间。第8章得线性时间排序算法在输入上做了假设。相反地，本节提到的此类似partition过程的SELECT算法不需要关于输入的任何假设，它们不受下界O（n</em>logn）的约束，因为它们没有使用排序就解决了选择问题（看到了没，道出了此算法的本质阿））</p>
<p>Thus, the running time is linear because these algorithms do not sort; the linear-time behavior is not a result of assumptions about the input, as was the case for the sorting algorithms in Chapter 8. Sorting requires Ω(n lg n) time in the comparison model, even on average (see Problem 8-1), and thus the method of sorting and indexing presented in the introduction to this chapter is asymptotically inefficient.（所以，本节中的选择算法之所以具有线性运行时间，是因为这些算法没有进行排序；线性时间的结论并不需要在输入上所任何假设，即可得到。.....）</p>
<h2 id="第三部分快速选择select算法的实现">第三部分、快速选择SELECT算法的实现</h2>
<p>本节，咱们将依据下图所示的步骤，采取中位数的中位数选取枢纽元的方法来实现此SELECT算法，</p>
<p>不过，在实现之前，有个细节我还是必须要提醒你，即上文中2.2节开头处所述，“数组元素索引是从“0...i”开始计数的，所以第k小的元素应该是返回a[i]=a[k-1].即k-1=i。换句话就是说，第k小元素，实际上应该在数组中对应下标为k-1”这句话，我想，你应该明白了：返回数组中第k小的元素，实际上就是返回数组中的元素array[i]，即array[k-1]。ok，最后请看此快速选择SELECT算法的完整代码实现（据我所知，在此之前，从没有人采取中位数的中位数选取枢纽元的方法来实现过这个SELECT算法）：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@ yansha &amp;&amp; July &amp;&amp; 飞羽</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
using namespace std;

<span class="dt">const</span> <span class="dt">int</span> num_array = <span class="dv">13</span>;
<span class="dt">const</span> <span class="dt">int</span> num_med_array = num_array / <span class="dv">5</span> + <span class="dv">1</span>;
<span class="dt">int</span> array[num_array];
<span class="dt">int</span> midian_array[num_med_array];

<span class="co">//冒泡排序（晚些时候将修正为插入排序）</span>
<span class="co">/*void insert_sort(int array[], int left, int loop_times, int compare_times)</span>
<span class="co">{</span>
<span class="co">    for (int i = 0; i &lt; loop_times; i++)</span>
<span class="co">    {</span>
<span class="co">        for (int j = 0; j &lt; compare_times - i; j++)</span>
<span class="co">        {</span>
<span class="co">            if (array[left + j] &gt; array[left + j + 1])</span>
<span class="co">                swap(array[left + j], array[left + j + 1]);</span>
<span class="co">        }</span>
<span class="co">    }</span>
<span class="co">}</span></code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co">//插入排序算法伪代码</span>
<span class="co">INSERTION-SORT(A)                              cost    times</span>
<span class="co">1  for j ← 2 to length[A]                      c1      n</span>
<span class="co">2       do key ← A[j]                          c2      n - 1</span>
<span class="co">3          Insert A[j] into the sorted sequence A[1 ‥ j - 1].     0...n - 1</span>
<span class="co">4          i ← j - 1                           c4      n - 1</span>
<span class="co">5          while i &gt; 0 and A[i] &gt; key           c5</span>
<span class="co">6             do A[i + 1] ← A[i]               c6</span>
<span class="co">7             i ← i - 1                        c7</span>
<span class="co">8          A[i + 1] ← key                      c8      n - 1</span>
<span class="co">*/</span>
<span class="co">//已修正为插入排序，如下：</span>
<span class="dt">void</span> insert_sort(<span class="dt">int</span> array[], <span class="dt">int</span> left, <span class="dt">int</span> loop_times)
{
    <span class="kw">for</span> (<span class="dt">int</span> j = left; j &lt; left+loop_times; j++)
    {
        <span class="dt">int</span> key = array[j];
        <span class="dt">int</span> i = j<span class="dv">-1</span>;
        <span class="kw">while</span> ( i&gt;left &amp;&amp; array[i]&gt;key )
        {
            array[i<span class="dv">+1</span>] = array[i];
            i--;
        }
        array[i<span class="dv">+1</span>] = key;
    }
}

<span class="dt">int</span> find_median(<span class="dt">int</span> array[], <span class="dt">int</span> left, <span class="dt">int</span> right)
{
    <span class="kw">if</span> (left == right)
        <span class="kw">return</span> array[left];

    <span class="dt">int</span> index;
    <span class="kw">for</span> (index = left; index &lt; right - <span class="dv">5</span>; index += <span class="dv">5</span>)
    {
        insert_sort(array, index, <span class="dv">4</span>);
        <span class="dt">int</span> num = index - left;
        midian_array[num / <span class="dv">5</span>] = array[index + <span class="dv">2</span>];
    }

    <span class="co">// 处理剩余元素</span>
    <span class="dt">int</span> remain_num = right - index + <span class="dv">1</span>;
    <span class="kw">if</span> (remain_num &gt; <span class="dv">0</span>)
    {
        insert_sort(array, index, remain_num - <span class="dv">1</span>);
        <span class="dt">int</span> num = index - left;
        midian_array[num / <span class="dv">5</span>] = array[index + remain_num / <span class="dv">2</span>];
    }

    <span class="dt">int</span> elem_aux_array = (right - left) / <span class="dv">5</span> - <span class="dv">1</span>;
    <span class="kw">if</span> ((right - left) % <span class="dv">5</span> != <span class="dv">0</span>)
        elem_aux_array++;

    <span class="co">// 如果剩余一个元素返回，否则继续递归</span>
    <span class="kw">if</span> (elem_aux_array == <span class="dv">0</span>)
        <span class="kw">return</span> midian_array[<span class="dv">0</span>];
    <span class="kw">else</span>
        <span class="kw">return</span> find_median(midian_array, <span class="dv">0</span>, elem_aux_array);
}

<span class="co">// 寻找中位数的所在位置</span>
<span class="dt">int</span> find_index(<span class="dt">int</span> array[], <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> median)
{
    <span class="kw">for</span> (<span class="dt">int</span> i = left; i &lt;= right; i++)
    {
        <span class="kw">if</span> (array[i] == median)
        <span class="kw">return</span> i;
    }
    <span class="kw">return</span> -<span class="dv">1</span>;
}

<span class="dt">int</span> q_select(<span class="dt">int</span> array[], <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> k)
{
    <span class="co">// 寻找中位数的中位数</span>
    <span class="dt">int</span> median = find_median(array, left, right);

    <span class="co">// 将中位数的中位数与最右元素交换</span>
    <span class="dt">int</span> index = find_index(array, left, right, median);
    swap(array[index], array[right]);

    <span class="dt">int</span> pivot = array[right];

    <span class="co">// 申请两个移动指针并初始化</span>
    <span class="dt">int</span> i = left;
    <span class="dt">int</span> j = right - <span class="dv">1</span>;

    <span class="co">// 根据枢纽元素的值对数组进行一次划分</span>
    <span class="kw">while</span> (true)
    {
        <span class="kw">while</span>(array[i] &lt; pivot)
            i++;
        <span class="kw">while</span>(array[j] &gt; pivot)
            j--;
        <span class="kw">if</span> (i &lt; j)
            swap(array[i], array[j]);
        <span class="kw">else</span>
            <span class="kw">break</span>;
    }
    swap(array[i], array[right]);

    <span class="co">/* 对三种情况进行处理：(m = i - left + 1)</span>
<span class="co">    1、如果m=k，即返回的主元即为我们要找的第k小的元素，那么直接返回主元a[i]即可;</span>
<span class="co">    2、如果m&gt;k，那么接下来要到低区间A[0....m-1]中寻找，丢掉高区间;</span>
<span class="co">    3、如果m&lt;k，那么接下来要到高区间A[m+1...n-1]中寻找，丢掉低区间。</span>
<span class="co">    */</span>
    <span class="dt">int</span> m = i - left + <span class="dv">1</span>;
    <span class="kw">if</span> (m == k)
        <span class="kw">return</span> array[i];
    <span class="kw">else</span> <span class="kw">if</span>(m &gt; k)
        <span class="co">//上条语句相当于if( (i-left+1) &gt;k)，即if( (i-left) &gt; k-1 )，于此就与2.2节里的代码实现一、二相对应起来了。</span>
        <span class="kw">return</span> q_select(array, left, i - <span class="dv">1</span>, k);
    <span class="kw">else</span>
        <span class="kw">return</span> q_select(array, i + <span class="dv">1</span>, right, k - m);
}

<span class="dt">int</span> main()
{
    <span class="co">//srand(unsigned(time(NULL)));</span>
    <span class="co">//for (int j = 0; j &lt; num_array; j++)</span>
    <span class="co">//array[j] = rand();</span>

    <span class="dt">int</span> array[num_array]={<span class="dv">0</span>,<span class="dv">45</span>,<span class="dv">78</span>,<span class="dv">55</span>,<span class="dv">47</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">96</span>,<span class="dv">36</span>,<span class="dv">45</span>};
    <span class="co">// 寻找第k最小数</span>
    <span class="dt">int</span> k = <span class="dv">4</span>;
    <span class="dt">int</span> i = q_select(array, <span class="dv">0</span>, num_array - <span class="dv">1</span>, k);
    cout &lt;&lt; i &lt;&lt; endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h1 id="第三章三续求数组中给定下标区间内的第-k-小大元素">第三章三续：求数组中给定下标区间内的第 K 小(大)元素</h1>
<p>作者：July、上善若水、编程艺术室。</p>
<h2 id="第一节寻找给定区间内的第k小大的元素">第一节、寻找给定区间内的第k小（大）的元素</h2>
<p>给定数组，给定区间，求第K小的数如何处理？求最小的k个元素用最大堆，求最大的k的元素用最小堆。OK，常规方法请查阅：程序员编程艺术：第三章、寻找最小的k个数。</p>
<p>1、排序，快速排序。我们知道，快速排序平均所费时间为<code>n*logn</code>，从小到大排序这n个数，然后再遍历序列中后k个元素输出，即可，总的时间复杂度为<code>O(n*logn+k)=O(n*logn)</code>。</p>
<p>2、排序，选择排序。用选择或交换排序，即遍历n个数，先把最先遍历到得k个数存入大小为k的数组之中，对这k个数，利用选择或交换排序，找到k个数中的最大数kmax（kmax设为k个元素的数组中最大元素），用时<code>O(k)</code>（你应该知道，插入或选择排序查找操作需要<code>O(k)</code>的时间），后再继续遍历后<code>n-k</code>个数，x与kmax比较：如果<code>x&lt;kmax</code>，则x代替kmax，并再次重新找出k个元素的数组中最大元素kmax‘（多谢jiyeyuran 提醒修正）；如果<code>x&gt;kmax</code>，则不更新数组。这样，每次更新或不更新数组的所用的时间为<code>O(k)</code>或<code>O(0)</code>，整趟下来，总的时间复杂度平均下来为：<code>n*O(k)=O(n*k)</code>。</p>
<p>3、维护k个元素的最大堆，原理与上述第2个方案一致，即用容量为k的最大堆存储最先遍历到的k个数，并假设它们即是最小的k个数，建堆费时<code>O(k)</code>，有<code>k1&lt;k2&lt;...kmax</code>（kmax设为最大堆中的最小元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若<code>x&lt;kmax</code>，则更新堆（用时<code>logk</code>），否则不更新堆。这样下来，总费时<code>O(k+(n-k)*logk)=O(N*logK)</code>。此方法得益于在堆中，查找等各项操作时间复杂度均为<code>logk</code>（不然，就如上述思路2所述：直接用数组也可以找出最大的k个元素，用时<code>O(n*k)</code>）。</p>
<p>4、按编程之美上解法二的所述，类似快速排序的划分方法，N个数存储在数组S中，再从数组中随机选取一个数X，把数组划分为Sa和Sb俩部分，<code>Sa&lt;=X&lt;=Sb</code>，如果要查找的k个元素小于Sa的元素个数，则返回Sa中较小的k个元素，否则返回Sa中所有的元素+Sb中较小的<code>k-|Sa|</code>个元素。不断递归下去，把问题分解成更小的问题，平均时间复杂度为<code>O(N)</code>。</p>
<p>下面我们给出伴随数组解法。我们知道，通常来讲，寻找给定区间内的第k小（大）的元素的问题是ACM中一类常用的数据结构的一个典型例题，即划分树/逆向归并树，通常用线段树的结构存储。</p>
<p>当然这里暂且不表，尚不说划分树思想的神奇，就是线段树的结构，一般没有ACM基础的人也都觉得难以理解。所以，这里提供一个时间效率尚可，空间代价还要略小的巧妙解法—伴随数组。</p>
<p>首先，定义一个结构体，一个是数组元素，另一个是数组原来的标号，记录每个数在数组的原顺序。</p>
<p>我们以下面的测试数据举例（红体部分表示下标为2~5之间的数5,2,6,3，浅色部分表示数组中的数各自对应的数组下标，淡蓝色部分为给定的下标区间，注，这里，我们让数组下标从1开始）：</p>
<figure>
<img src="../images/3/3.3/3.3.1.png" />
</figure>
<p>现在，题目给定了下标区间，如在原序列中下标2~5（即下标为<code>2,3,4,5</code>）区间找到第3小的数。问题亦相当于要你找原序列里给定下标区间即第2个数到第5个数之中（<code>5,2,6,3</code>）第3小的数（当然，答案很明显，第3小的数就是5）。</p>
<p>那么对原数组进行排序，然后得到的序列应该是（<strong>注：原下标始终保持不变</strong>）：</p>
<figure>
<img src="../images/3/3.3/3.3.2.png" />
</figure>
<p>如上，既然数据现在已经从小到大排好了，那么，我们只需要进行一次检索，从最小的数到最大的数，我们找第k(k=3)小的数，当我们发现下标<code>a[i].num</code>等于原给定下标区间在2~5中，即<code>a[i].num==2 || 3 || 4 || 5</code>的时候，k--，那么当k==0的时候，我们也就找到了第k(3)小的数了。如下（红色部分表示原给定下标区间中的数，浅色部分依然是原各数对应的下标，淡蓝色部分为原来给定的下标区间所对应的索引）：</p>
<figure>
<img src="../images/3/3.3/3.3.3.png" />
</figure>
<p>故下标索引为2~5之间第k（3）小的数是5。</p>
<p>程序的构造与解释：由于排序后，我们能保证原序列已经从小到大的排好序了，所以，当遍历或扫描到原序列给定下标区间中的数时，则k--，最终能在k==0时，找到第k小的数，且这个数是在原来给定下标区间中的某一个数。</p>
<p>而这个伴随数组，或者说原序列各数的索引则帮我们或者说是帮电脑记下了原来的数，已让我们后来遍历时能识别排序后序列中的数是否是给定下标区间中的某一个数。如果是原给定下标区间中的数，则k--，否则k不变。</p>
<h3 id="第二节采用伴随数组方案的实现">第二节、采用伴随数组方案的实现</h3>
<p>上述采用伴随数组的方法巧妙且简单，也很好理解和实现，关键 就是在于题目要求是在给定下标区间中找寻第k小（大）的元素，所以，基本上在排序<code>n*logn</code>完了之后，总能 在<code>O(n)</code>的时间内找到想找的数。源代码如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@ 水 &amp;&amp; July  </span>
<span class="co">//总的时间复杂度为O（N*logN+N）= O（N*logN）。  </span>
<span class="co">//July、updated，2011.05.28.凌晨。  </span>
<span class="ot">#include&lt;iostream&gt;  </span>
<span class="ot">#include&lt;algorithm&gt;  </span>
<span class="kw">using</span> <span class="kw">namespace</span> std;  
  
<span class="kw">struct</span> node{  
    <span class="dt">int</span> num,data;  
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> node &amp;p) <span class="dt">const</span>   
    {  
        <span class="kw">return</span> data &lt; p.data;  
    }  
};  
node p[<span class="dv">100001</span>];  
  
<span class="dt">int</span> main()  
{  
    <span class="dt">int</span> n=<span class="dv">7</span>;  
    <span class="dt">int</span> i,j,a,b,c;<span class="co">//c：flag;  </span>
      
    <span class="kw">for</span>(i=<span class="dv">1</span>;i&lt;=n;i++)   
    {  
        scanf(<span class="st">&quot;%d&quot;</span>,&amp;p[i].data);  
        p[i].num = i;  
    }  
    sort(p<span class="dv">+1</span>,p<span class="dv">+1</span>+n);    <span class="co">//调用库函数sort完成排序，复杂度n*logn  </span>
      
    scanf(<span class="st">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);  
    <span class="kw">for</span>(i=<span class="dv">1</span>;i&lt;=n;i++)   <span class="co">//扫描一遍，复杂度n  </span>
    {  
        <span class="kw">if</span>(p[i].num&gt;=a &amp;&amp; p[i].num&lt;=b)   
            c--;   
        <span class="kw">if</span>(c == <span class="dv">0</span>)   
            <span class="kw">break</span>;  
    }  
    printf(<span class="st">&quot;%d/n&quot;</span>,p[i].data);  
    <span class="kw">return</span> <span class="dv">0</span>;  
}  </code></pre>
<p><strong>程序测试</strong>：输入的第1行数字<code>1 5 2 6 3 7 4</code>代表给定的数组，第二行的数字中，<code>2 5</code>代表给定的下标区间2<sub>5，<code>3</code>表示要在给定的下标区间2</sub>5中寻找第3小的数，第三行的<code>5</code>表示找到的第3小的数。程序运行结果如下：</p>
<figure>
<img src="../images/3/3.3/3.3.4.jpg" />
</figure>
<p>水原来写的代码（上面我的改造，是为了达到后来扫描时<code>O(N)</code>的视觉效果）：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@ 水  </span>
<span class="ot">#include&lt;iostream&gt;  </span>
<span class="ot">#include&lt;algorithm&gt;  </span>
<span class="kw">using</span> <span class="kw">namespace</span> std;  
  
<span class="kw">struct</span> node{  
    <span class="dt">int</span> num,data;  
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> node &amp;p) <span class="dt">const</span>   
    {  
        <span class="kw">return</span> data &lt; p.data;  
    }  
};  
node p[<span class="dv">100001</span>];  
  
<span class="dt">int</span> main()  
{  
    <span class="dt">int</span> n,m,i,j,a,b,c;<span class="co">//c：flag;  </span>
    <span class="kw">while</span>(scanf(<span class="st">&quot;%d %d&quot;</span>,&amp;n,&amp;m)!=EOF)   
    {  
        <span class="kw">for</span>(i=<span class="dv">1</span>;i&lt;=n;i++)   
        {  
            scanf(<span class="st">&quot;%d&quot;</span>,&amp;p[i].data);  
            p[i].num = i;  
        }  
        sort(p<span class="dv">+1</span>,p<span class="dv">+1</span>+n);  
          
        <span class="kw">for</span>(j=<span class="dv">1</span>;j&lt;=m;j++)   
        {  
            scanf(<span class="st">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);  
            <span class="kw">for</span>(i=<span class="dv">1</span>;i&lt;=n;i++)   
            {  
                <span class="kw">if</span>(p[i].num&gt;=a &amp;&amp; p[i].num&lt;=b)   
                    c--;   
                <span class="kw">if</span>(c == <span class="dv">0</span>)   
                    <span class="kw">break</span>;  
            }  
            printf(<span class="st">&quot;%d/n&quot;</span>,p[i].data);  
        }  
    }  
    <span class="kw">return</span> <span class="dv">0</span>;  
}  </code></pre>
<h3 id="第三节直接排序给定下标区间的数">第三节、直接排序给定下标区间的数</h3>
<p>你可能会忽略一个重要的事实，不知读者是否意识到。题目是要求我们在数组中求给定下标区间内某一第k小的数，即我们只要找到这个第k小的数，就够了。但上述程序显示的一个弊端，就是它先对整个数组进行了排序，然后采用伴随数组的解法寻找到第k小的数。而事实是，我们不需要对整个数组进行排序，我们只需要对我们要寻找的那个数的数组中给定下标区间的数进行部分排序，即可。</p>
<p>对，事情就是这么简单。我们摒弃掉伴随数组的方法，只需要直接对数组中给定的那部分下标区间中的数进行排序，而不是对整个数组进行排序。如此的话，算法的时间复杂度降到了<code>L*logK</code>。其中，<code>L=|b-a+1|</code>，L为给定下标区间的长度，相对整个数组的程度n，<code>L&lt;=n</code>。程序代码如下。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@ 苍狼  </span>
<span class="co">//直接对给定区间的数进行排序，没必要用伴随数组。  </span>
<span class="ot">#include&lt;iostream&gt;     </span>
<span class="ot">#include&lt;algorithm&gt;     </span>
<span class="kw">using</span> <span class="kw">namespace</span> std;     
  
<span class="kw">struct</span> node{     
    <span class="dt">int</span> data;     
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> node &amp;p) <span class="dt">const</span>      
    {     
        <span class="kw">return</span> data &lt; p.data;     
    }     
};     
node p[<span class="dv">100001</span>];     
  
<span class="dt">int</span> main()     
{     
    <span class="dt">int</span> n=<span class="dv">7</span>;     
    <span class="dt">int</span> i,a,b,c;<span class="co">//c：flag;     </span>
      
    <span class="kw">for</span>(i=<span class="dv">1</span>;i&lt;=n;i++)      
    {     
        scanf(<span class="st">&quot;%d&quot;</span>,&amp;p[i].data);        
    }  
      
    scanf(<span class="st">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);   <span class="co">//b，a为原数组的下标索引  </span>
    sort(p+a, p+b<span class="dv">+1</span>);     <span class="co">//直接对给定区间进行排序，|b-a+1|*log（b-a+1）  </span>
      
    printf(<span class="st">&quot;The number is %d/n&quot;</span>, p[a<span class="dv">-1</span>+c].data);      
    <span class="kw">return</span> <span class="dv">0</span>;     
}  </code></pre>
<p><strong>程序测试</strong>：我们同样采取第二节的测试用例。输入的第1行数字<code>1 5 2 6 3 7 4</code>代表给定的数组，第二行的数字中，<code>2 5</code>代表给定的下标区间2<sub>5，<code>3</code>表示要在给定的下标区间2</sub>5中的数，即从a[2]~a[5]中寻找第3小的数，第三行的<code>5</code>表示找到的第3小的数。程序运行结果如下。</p>
<figure>
<img src="../images/3/3.3/3.3.5.jpg" />
</figure>
<p>貌似上述直接对给定区间内的数进行排序，效率上较第二节的伴随数组方案更甚一筹。既然如此，那么伴随数组是不是多此一举呢?其实不然，<span class="citation" data-cites="水">@水</span>：假如，我对2-5之间进行了排序，那么数据就被摧毁了，怎么进行2次的操作？就是现在的2位置已经不是初始的2位置的数据了。也就是说，快排之后下标直接定位的方法明显只能用一次。</p>
<p>ok，更多请看下文第四节中的“百家争鸣”与“经典对白”。</p>
<h3 id="第四节伴随数组的优势所在">第四节、伴随数组的优势所在</h3>
<h4 id="百家争鸣">百家争鸣</h4>
<ul>
<li><p><span class="citation" data-cites="雨翔">@雨翔</span>：伴随数组这种方式确实比较新颖 ，伴随数组的前提是在排序后的 ，但总的复杂度<strong>还是 <code>O(N*logN+N)=O(N*logN)</code></strong>，找第K大的数的此类面试题都是有这几点限制：<strong>1、</strong>数很多，让你在内存中放不下，<strong>2、</strong>复杂度严格要求，即不能用排序。当然，即便第三节中，直接对给定下标区间进行排序，复杂度同样为<code>L*logL</code>，L为给定区间的长度。事实上，我们在解决 “从给定下标区间中的数找寻第k小（大）的元素” 这个问题，还是选择堆为好，在之前的基础上：入堆的时候 只需检测这个元素的下标是否是给定下标区间内的，不是则不入这样的复杂度会低，不需要排序。然后便是平均时间复杂度虽为O(N)，但并不常用的快速选择SELECT算法，参考：<a href="http://blog.csdn.net/v_JULY_v/article/details/6431001">第三章再续：快速选择SELECT算法的深入分析与实现</a>。</p></li>
<li><p><span class="citation" data-cites="水">@水</span>：伴随数组的解法是为了达到预处理开销换查找开销目的。直接对给定不同的下标区间的数进行排序，在小数据量处理时复杂度还可以接受，但当面临大数据量，即海量数据处理时，比如10G的数据量，每次取1G的段的问题，则使用伴随数组的方法会凸显优势，只不过预处理的开销的确是大了点。伴随数组的精髓就是稳定的时间之内解决对相同数据的多次访问查找。说白了，就是同一个数组，要不断查找数组中给定的不同下标区间中的第k小的数时优势明显。具体，还可以看看<a href="http://poj.org/problem?id=2104">这道题</a>。</p></li>
<li><p><span class="citation" data-cites="July">@July</span>：不用看我了，基本上同意上述水的观点。雨翔之所以认为伴随数组不可取，是因为没有考虑到水提出的问题，即如果要多次或不断的从数组中不同的下标区间中寻找第k小的数的情况。这时，伴随数组的优势就体现出来了。ok，读者还可以继续看下面的经典对白。相信，你能找到你想要的答案。</p></li>
</ul>
<h4 id="经典对白">经典对白</h4>
<ul>
<li><p>查找a[0]<sub>a[n-1]内第K小，然后再找a[1]</sub>a[n]内第K小，依次往复，找个几次就优势明显了。其实是比较采取伴随数组解法n log n +m<em>n的代价（m为给定不同区间的个数）和直接排序m</em>(L*log L )（L为给定下标区间的长度）的代价，哪个更低。其中，采用伴随数组查找最差情况是<code>nlogn + m(n-1)</code>，而直接排序代价，最差情况为<code>m * ((n-1)*log(n-1))</code>。当m&gt;&gt;0且n&gt;&gt;0时，排序时间 - 伴随时间 = <code>m*n*logn - n*logn - mn</code> = <code>(m-1)n*logn -mn</code>恒正，结论：即在需要不断的从不同给定下标区间中寻找第k小数的情况下，当数据规模大的时候伴随数组效果恒优于每次都直接对给定的下标区间的部分数进行排序。</p></li>
<li><p>是的，好比我现在给定不同的另外一个下标区间，要你从中查找第k小的数，你总不能每次都排序吧。而采取伴随数组的方案的话，由于伴随数组记下了各自给定的下标区间对应的数。所以，第二次在不同的下标区间中查找第k小的数时，还是只要扫描一遍即可找到，复杂度还是 <code>O(N)</code>。从而，给定不同的下标区间查找第k小的数，复杂度为<code>m*N</code>加上之前排序预处理的复杂度，<code>N*logN</code>，总的时间复杂度为<code>O(N*logN + m*N)</code>（m为给定不同区间的个数）。而直接对给定下标区间中的数进行排序的代价则为<code>l1*logl1 + l2*logl2 + ... + li*logli</code>。当m&gt;&gt;0且n&gt;&gt;0时，哪个复杂度谁大谁小，一眼就看出来了伴随数组所体现的巨大优势。</p></li>
<li><p>恩，实际样例是这样的，我们有每天超过100万次点击的网页，我们常见的来源有n种，然后，我们要确定每天的每个时段和一周乃至整个月的点击来源地分析。数据库的库存数据量庞大，copy花销很大，内排序花销更大，如果要做出这样的统计图，我擦泪，如果每次都排序，玩死了。</p></li>
</ul>
<h4 id="原例重现">原例重现</h4>
<p>ok，说了这么多，你可能还根本就不明白到底是怎么一回事。让我们从第一节举的那个例子说起。我们要找给定下标区间2~5的数中第3小的数。诚然，此时，我们有两种选择：<strong>1、</strong>如上第一节、第二节所述的伴随数组，<strong>2、</strong>直接对下标区间2-5的数进行排序。下面，只回顾下伴随数组的方案。</p>
<p><strong>伴随数组</strong></p>
<figure>
<img src="../images/3/3.3/3.3.1.png" />
</figure>
<p>第一次排序后：</p>
<figure>
<img src="../images/3/3.3/3.3.2.png" />
</figure>
<p>伴随数组方案查找：</p>
<figure>
<img src="../images/3/3.3/3.3.3.png" />
</figure>
<p>好的，那么现在，如果题目要求你在之前数组的下标区间3~6的数中找第3小的数呢（答案很明显，为6）?</p>
<figure>
<img src="../images/3/3.3/3.3.6.png" />
</figure>
<ol type="1">
<li><p>直接排序么?ok，退万一步讲，假设有的读者可能还是会依然选择直接排序下标3~6之间的数。但你是否可曾想到，每次对不同的下标区间所对应的数进行排序，你不但破坏了原有的数据，而且如果<strong>区间有覆盖</strong>的话，那么将使得我们无法再能依靠原有的直接的下标定位找到原来的数据，且每进行一次排序，都要花费平均时间复杂度为<code>O(N*logN)</code>的时间开销。如上面的经典对白所述，这样下去的开销将非常大，将为<code>l1*logl1 + l2*logl2 + ... + li*logli</code>。</p></li>
<li><p>那么，如果是采取伴随数组的方法，我们要怎么做呢?如下所示，我们在k=0的时候，同样找到了第3小的数6，如此是不是只要在之前的一次排序，以后不论是换各种不同的下标区间时都能扫描一遍<code>O(N)</code>搞定？复杂度为<code>O(N*logN + m*N)</code>（m为给定不同的下标区间的区间数）。</p></li>
<li><p>由上面的经典对白里面的内容，我们已经知道，当m&gt;&gt;0且n&gt;&gt;0时（m为给定不同的下标区间的区间数，n为数组大小），排序时间 - 伴随时间 = <code>m*n*logn - n*logn - mn</code> = <code>(m-1)n*logn -mn</code>恒正。yeah，相信，你已经明白了。</p></li>
</ol>
<p><strong>伴随数组</strong></p>
<p>第一次排序后：</p>
<figure>
<img src="../images/3/3.3/3.3.2.png" />
</figure>
<p>再次扫描，直接<code>O(N)</code>搞定：</p>
<figure>
<img src="../images/3/3.3/3.3.7.png" />
</figure>
<p>（而之前有的读者意识不到伴随数组的意义，是因为一般的人只考虑找一次，不会想到第二次或多次查找）</p>
<h4 id="编程独白">编程独白</h4>
<p>给你40分钟的时间，你可以思考十分钟，然后用三十分钟的时间来写代码，最后浪费在无谓的调试上；你也可以思考半个小时，彻底弄清问题的本质与程序的脉络，然后用十分钟的时间来编写代码，体会代码如行云流水而出的感觉。</p>
<p>本章完。</p>
<h1 id="第三章四续动态数据中求第-k-小大元素">第三章四续：动态数据中求第 K 小(大)元素</h1>
<h2 id="问题引入">问题引入：</h2>
<p>前面总结了怎么在一个静态数组中找出第i小的元素(TopK)，那么如果在一个动态数据集合，可以支持动态插入、删除，如何及时查找第i小的元素(TopK)？</p>
<h2 id="解决思路">解决思路：</h2>
<p>可以回想所学过的典型动态的数据结构：搜索二叉树，而红黑树是对搜索二叉树的改进，在保持了搜索二叉树的性质基础上保持了整棵树的平衡。我们可以通过红黑树这个已经存在的动态数据结构进行改进来设计一个求第i小(TopK)的算法。</p>
<h2 id="算法思考">算法思考：</h2>
<p>为了实现求第i小的树，最直接的想法是能否在每个树节点上维护自身的排名，但这种思路显然不行，因为这样一来当插入或删除一个节点时，最差情况是每个节点的排名信息都要被更新（插入或删除一个最小值的情况），时间复杂度O(N)，无法发挥树的优势。</p>
<p>利用搜索二叉树的性质，每个节点的左子树都是比自身小的节点，右子树都是比自身大的节点，因此左子树节点+1就是以自身为根节点的树中自身节点的排名，这个规律正好符合查找第i小元素的需求，因此想到可以在每个节点维护其左子树节点数，然后再根据以自己为根节点进行查找的树递归算法。</p>
<p>以下图为例： * 模型建立：一个节点分2个域，上域用字母表示节点的Key，下域用数字表示其左子树的节点数； * 2、查找Rank(i = 5)： - a) 引入i表示在以自己为根的子树中查找第i（i=5）小的节点，引入k表示该节点在以自己为根的子树中自己的排名； - b) 首先从整个树的根节点M开始，此时i=5,则k为当前节点M的下域(M左子树节点数)+1(M节点本身)=5+1=6，即M在树M中排名第6，6&gt;5，因此向其左子树中查找第i(i=5)小的节点； - c) 递归调用Rank(i = i)，此时i=5,则k=1+1=2，即C在树C中排名第2,5&gt;2，因此向其右子树中查找第i=i-k=5-2=3小的节点； - d) 递归调用Rank(i = i - k)，此时i=3,则k=1+1=2，3&gt;2，因此向其右子树中查找第i=i-k=3-2=1小的节点； - e) 递归调用Rank(i = i - k)，此时i=1，则k=0+1=1,1=1，即找到，则H就是整棵树中第5小的节点。</p>
<figure>
<img src="../images/3/3.4/1.jpg" />
</figure>
<p>图1：下域为其节点左子树总节点数的方案的查找算法</p>
<ul>
<li>3、插入 Insert()：</li>
<li><ol type="a">
<li>下图为例，插入Key=I，在红黑树的插入算法中加入维护节点下域的算法，当心插入的值x比当前节点key小，则先更新该节点的下域+1，再递归插入左子树。</li>
</ol></li>
</ul>
<figure>
<img src="../images/3/3.4/2.jpg" />
</figure>
<p>图2：下域为其节点左子树总节点数的方案的插入算法</p>
<ul>
<li><ol start="2" type="a">
<li>而红黑树的插入还有保持红黑树性质的修正操作：1、改变颜色2、旋转。改变颜色不影响下域，而旋转会影响下域，因此需要考虑旋转算法对下域的影响。以下图为例，当正常的旋转算法完成后，需要重新计算A和B的下域，但是B只能获取其左子树的左子树节点数为3，而不知道其左子树的右子树节点数，从而无法计算B的左子树总节点。</li>
</ol></li>
</ul>
<figure>
<img src="../images/3/3.4/3.jpg" />
</figure>
<p>图3：下域为其节点左子树总节点数的方案的节点旋转改进</p>
<ul>
<li><ol start="3" type="a">
<li>因此上面的方案在改造Insert()算法时候失败了，换个方案，考虑更换下域保存的信息，换为下域用（左右子树的总节点数+1）代替（左子树总节点数），这样在旋转以后就可以简单计算出新的下域。</li>
</ol></li>
</ul>
<figure>
<img src="../images/3/3.4/4.jpg" />
</figure>
<p>图4：下域为（其节点左右子树总节点数+1）的方案的节点旋转改进</p>
<p>由于更换下域保存的信息，重新考虑查找操作，根据上面的查找思路得出下图查找算法，过程略。</p>
<figure>
<img src="../images/3/3.4/5.jpg" />
</figure>
<p>图5：下域为（其节点左右子树总节点数+1）的方案的查找算法</p>
<ul>
<li>4、删除：类比插入操作，略。</li>
</ul>
<h2 id="算法总结">算法总结：</h2>
<p>插入、删除、查找算法都是在原红黑树的基础上进行适当修改，因此时间复杂度均为O(logN)。</p>
<h1 id="第四章现场编写类似strstrstrcpystrpbrk的函数">第四章：现场编写类似strstr/strcpy/strpbrk的函数</h1>
<h2 id="第一节字符串查找">第一节、字符串查找</h2>
<h3 id="题目描述-3">1.1题目描述：</h3>
<p>给定一个字符串A，要求在A中查找一个子串B。 如A=&quot;ABCDF&quot;，要你在A中查找子串B=“CD”。</p>
<p>分析：比较简单，相当于实现strstr库函数，主体代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//在字符串中查找指定字符串的第一次出现，不能找到则返回-1</span>
<span class="dt">int</span> strstr(<span class="dt">char</span> *string, <span class="dt">char</span> *substring)
{
    <span class="kw">if</span> (string == NULL || substring == NULL)
        <span class="kw">return</span> -<span class="dv">1</span>;

    <span class="dt">int</span> lenstr = strlen(string);
    <span class="dt">int</span> lensub = strlen(substring);

    <span class="kw">if</span> (lenstr &lt; lensub)
        <span class="kw">return</span> -<span class="dv">1</span>;

    <span class="dt">int</span> len = lenstr - lensub;
    <span class="dt">int</span> i,j;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt;= len; i++)   <span class="co">//复杂度为O(m*n)</span>
    {
        <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; lensub; j++)
        {
            <span class="kw">if</span> (string[i+j] != substring[j])
                <span class="kw">break</span>;
        }
        <span class="kw">if</span> (j == lensub)
            <span class="kw">return</span> i + <span class="dv">1</span>;
    }
    <span class="kw">return</span> -<span class="dv">1</span>;
}</code></pre>
<p>读者反馈@xiaohui5319：楼主啊，对于你那个strstr的函数，我觉得有点小问题。我查了一下C标准库的源码，它给的声明是这样的，两个参数都有const。</p>
<pre class="sourceCode c"><code class="sourceCode c">    <span class="dt">char</span> *
    STRSTR (<span class="dt">const</span> <span class="dt">char</span> *haystack_start, <span class="dt">const</span> <span class="dt">char</span> *needle_start)</code></pre>
<p>而且标准库中没有调用strlen函数，因为假如你是标准库的设计者，strlen()函数还没设计出来，你怎么去计算两个字符串的长度？是不是只能通过指针移动来实现，我觉得这些都是微软要考察的地方。</p>
<p>此外：还有<code>int lenstr=strlen(string);</code>这是不安全的？ strlen函数的返回类型是size_t型，也就是无符号整型，假如我的数组长度很长（假如是用堆分配的，可以很大很大），长过2的31次方减1的话，会发生溢出，你这lenstr就会变成负值了用size_t类型最保险。</p>
<p>以后，<strong>本编程艺术系列中有任何问题，暂未来得及及时修正，请读者多加思考，多加辨明</strong>。</p>
<p>上述程序已经实现了在字符串中查找第一个子串的功能，时间复杂度为O(n*m)，也可以用KMP算法，复杂度为O(m+n)。为人打通思路，提高他人创造力，我想，这是狂想曲与其它的面试解答所不同的地方，也是我们写狂想曲系列文章的意义与价值之所在。</p>
<h3 id="题目描述-4">1.2、题目描述</h3>
<p>在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。</p>
<p>代码则可以如下编写：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//查找第一个只出现一次的字符，</span>
<span class="co">//copyright@ yansha</span>
<span class="co">//July、updated，2011.04.24.</span>
<span class="dt">char</span> FirstNotRepeatChar(<span class="dt">char</span>* pString)
{
    <span class="kw">if</span>(!pString)
        <span class="kw">return</span> &#39;\<span class="dv">0</span>&#39;;

    <span class="dt">const</span> <span class="dt">int</span> tableSize = <span class="dv">256</span>;
    <span class="co">//有点要提醒各位注意，一般常数的空间消耗，如这里的256，我们也认为此空间复杂度为O（1）。</span>
    <span class="dt">int</span> hashTable[tableSize] = {<span class="dv">0</span>}; <span class="co">//存入数组，并初始化为0</span>

    <span class="dt">char</span>* pHashKey = pString;
    <span class="kw">while</span>(*(pHashKey) != &#39;\<span class="dv">0</span>&#39;)
        hashTable[*(pHashKey++)]++;

    <span class="kw">while</span>(*pString != &#39;\<span class="dv">0</span>&#39;)
    {
        <span class="kw">if</span>(hashTable[*pString] == <span class="dv">1</span>)
            <span class="kw">return</span> *pString;

        pString++;
    }
    <span class="kw">return</span> &#39;\<span class="dv">0</span>&#39;;  <span class="co">//没有找到满足条件的字符，退出</span>
}</code></pre>
<p>代码二，bitmap：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot"># include&lt;stdio.h&gt;</span>
<span class="ot"># include&lt;string.h&gt;</span>

<span class="dt">const</span> <span class="dt">int</span> N = <span class="dv">26</span>;
<span class="dt">int</span> bit_map[N];

<span class="dt">void</span> findNoRepeat(<span class="dt">char</span> *src)
{
    <span class="dt">int</span> pos;
    <span class="dt">char</span> *str = src;
    <span class="dt">int</span> i ,len = strlen(src);

    <span class="co">//统计</span>
    <span class="kw">for</span>(i = <span class="dv">0</span> ; i &lt; len ;i ++)
        bit_map[str[i]-&#39;a&#39;] ++;

    <span class="co">//从字符串开始遍历 其bit_map==1 那么就是结果</span>
    <span class="kw">for</span>(i = <span class="dv">0</span> ; i &lt; len ; i ++)
    {
        <span class="kw">if</span>(bit_map[str[i]-&#39;a&#39;] == <span class="dv">1</span>)
        {
            printf(<span class="st">&quot;%c&quot;</span>, str[i]);
            <span class="kw">return</span>;
        }
    }
}

<span class="dt">int</span> main()
{
    <span class="dt">char</span> *src = <span class="st">&quot;abaccdeff&quot;</span>;
    findNoRepeat(src);
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="第二节字符串拷贝">第二节、字符串拷贝</h2>
<p>题目描述：</p>
<p>要求实现库函数strcpy</p>
<p>原型声明: <code>extern char *strcpy(char *dest, char *src);</code></p>
<p>功能: 把src所指由NULL结束的字符串复制到dest所指的数组中。</p>
<p>说明: src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。 　</p>
<p>返回: 指向dest的指针。</p>
<p>分析: 如果编写一个标准strcpy函数的总分值为10，<strong>下面给出几个不同得分的答案</strong>:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//得2分</span>
<span class="dt">void</span> strcpy( <span class="dt">char</span> *strDest, <span class="dt">char</span> *strSrc )
{
    <span class="kw">while</span>( (*strDest++ = * strSrc++) != &#39;\<span class="dv">0</span>&#39; );
}

<span class="co">//得4分</span>
<span class="dt">void</span> strcpy( <span class="dt">char</span> *strDest, <span class="dt">const</span> <span class="dt">char</span> *strSrc )
{
    <span class="co">//将源字符串加const，表明其为输入参数，加2分</span>
    <span class="kw">while</span>( (*strDest++ = * strSrc++) != &#39;\<span class="dv">0</span>&#39; );
}

<span class="co">//得7分</span>
<span class="dt">void</span> strcpy(<span class="dt">char</span> *strDest, <span class="dt">const</span> <span class="dt">char</span> *strSrc)
{
    <span class="co">//对源地址和目的地址加非0断言，加3分</span>
    assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) );
    <span class="kw">while</span>( (*strDest++ = * strSrc++) != &#39;\<span class="dv">0</span>&#39; );
}

<span class="co">//得9分</span>
<span class="co">//为了实现链式操作，将目的地址返回，加2分！</span>
<span class="dt">char</span> * strcpy( <span class="dt">char</span> *strDest, <span class="dt">const</span> <span class="dt">char</span> *strSrc )
{
    assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) );
    <span class="dt">char</span> *address = strDest;
    <span class="kw">while</span>( (*strDest++ = * strSrc++) != &#39;\<span class="dv">0</span>&#39; );
    <span class="kw">return</span> address;
}

<span class="co">//得10分，基本上所有的情况，都考虑到了</span>
<span class="co">//如果有考虑到源目所指区域有重叠的情况，加1分！</span>
<span class="dt">char</span> * strcpy( <span class="dt">char</span> *strDest, <span class="dt">const</span> <span class="dt">char</span> *strSrc )
{
    <span class="kw">if</span>(strDest == strSrc) { <span class="kw">return</span> strDest; }
    assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) );
    <span class="dt">char</span> *address = strDest;
    <span class="kw">while</span>( (*strDest++ = * strSrc++) != &#39;\<span class="dv">0</span>&#39; );
    <span class="kw">return</span> address;
}</code></pre>
<h2 id="第三节其余库函数的实现">第三节、其余库函数的实现</h2>
<p>考察此类编写同库函数一样功能的函数经常见于大大小小的IT公司的面试题目中，以下是常见的字符串库函数的实现，希望，对你有所帮助，有任何问题，欢迎不吝指正：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//@heyaming</span>
<span class="co">//对原 strtok 的修改，根据MSDN,strToken可以为NULL.实际上第一次call strtok给定一字串，</span>
<span class="co">//再call strtok时可以输入NULL代表要接着处理给定字串。</span>
<span class="co">//所以需要用一 static 保存没有处理完的字串。同时也需要处理多个分隔符在一起的情况。</span>
<span class="dt">char</span> *strtok(<span class="dt">char</span> *strToken, <span class="dt">const</span> <span class="dt">char</span> *str)
{
    assert(str != NULL);
    <span class="dt">static</span> <span class="dt">char</span> *last;

    <span class="kw">if</span> (strToken == NULL &amp;&amp; (strToken = last) == NULL)
        <span class="kw">return</span> (NULL);

    <span class="dt">char</span> *s = strToken;
    <span class="dt">const</span> <span class="dt">char</span> *t = str;
    <span class="kw">while</span> (*s != &#39;\<span class="dv">0</span>&#39;)
    {
        t = str;
        <span class="kw">while</span> (*t != &#39;\<span class="dv">0</span>&#39;)
        {
            <span class="kw">if</span> (*s == *t)
            {
                last = s + <span class="dv">1</span>;
                <span class="kw">if</span> (s - strToken == <span class="dv">0</span>) {
                    strToken = last;
                    <span class="kw">break</span>;
                }
                *(strToken + (s - strToken)) = &#39;\<span class="dv">0</span>&#39;;
                <span class="kw">return</span> strToken;
            }
            ++ t;
        }
        ++ s;
    }
    <span class="kw">return</span> NULL;
}

<span class="co">//@big：</span>
<span class="co">//要处理src和dest有重叠的情况，不是从尾巴开始移动就没问题了。</span>
<span class="co">//一种情况是dest小于src有重叠，这个时候要从头开始移动，</span>
<span class="co">//另一种是dest大于src有重叠，这个时候要从尾开始移动。</span>
<span class="dt">void</span> *memmove(<span class="dt">void</span> *dest, <span class="dt">const</span> <span class="dt">void</span> *src, <span class="dt">unsigned</span> <span class="dt">int</span> count)
{
    assert(dest != NULL &amp;&amp; src != NULL);
    <span class="dt">char</span>* pdest = (<span class="dt">char</span>*) dest;
    <span class="dt">char</span>* psrc = (<span class="dt">char</span>*) src;

    <span class="co">//pdest在psrc后面，且两者距离小于count时，从尾部开始移动. 其他情况从头部开始移动</span>
    <span class="kw">if</span> (pdest &gt; psrc &amp;&amp; pdest - psrc &lt; count)
    {
        <span class="kw">while</span> (count--)
        {
            *(pdest + count) = *(psrc + count);
        }
    } 
    <span class="kw">else</span>
    {
        <span class="kw">while</span> (count--)
        {
            *pdest++ = *psrc++;
        }
    }
    <span class="kw">return</span> dest;
}</code></pre>
<p><strong>测试</strong>：以上所有的函数，都待进一步测试，有任何问题，欢迎任何人随时不吝指出。</p>
<h1 id="第五章寻找和为定值的两个或多个数">第五章：寻找和为定值的两个或多个数</h1>
<h2 id="前奏">前奏</h2>
<p>希望此编程艺术系列能给各位带来的是一种方法，一种创造力，一种举一反三的能力。本章依然同第四章一样，选取比较简单的面试题，恭祝各位旅途愉快。同样，有任何问题，欢迎不吝指正。谢谢。</p>
<h2 id="第一节寻找和为定值的两个数">第一节、寻找和为定值的两个数</h2>
<p>第14题（数组）：</p>
<p>题目：输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。</p>
<p>要求时间复杂度是O(N)。如果有多对数字的和等于输入的数字，输出任意一对即可。</p>
<p>例如输入数组1、2、4、7、11、15和数字15。由于4+11=15，因此输出4和11。</p>
<p>分析：</p>
<p>咱们试着一步一步解决这个问题（注意阐述中数列有序无序的区别）：</p>
<p>直接穷举，从数组中任意选取两个数，判定它们的和是否为输入的那个数字。此举复杂度为O(N^2)。很显然，我们要寻找效率更高的解法。</p>
<p>题目相当于，对每个a[i]，查找sum-a[i]是否也在原始序列中，每一次要查找的时间都要花费为O(N)，这样下来，最终找到两个数还是需要O（N^2）的复杂度。那如何提高查找判断的速度呢？ 答案是二分查找，可以将O(N)的查找时间提高到O(log N)，这样对于N个a[i]，都要花logN的时间去查找相对应的sum-a[i]是否在原始序列中，总的时间复杂度已降为O(N log N)，且空间复杂度为O(1)。 （如果有序，直接二分O(N log N)，如果无序，先排序后二分，复杂度同样为O（N log N + N log N）=O(N log N)，空间总为O(1)）。</p>
<p>有没有更好的办法呢？咱们可以依据上述思路2的思想，a[i]在序列中，如果a[i]+a[k]=sum的话，那么sum-a[i]（a[k])也必然在序列中。 举个例子，如下： 原始序列： 1、 2、 4、 7、11、15 用输入数字15减一下各个数，得到对应的序列为： 14、13、11、8、4、 0</p>
<p>第一个数组以一指针i 从数组最左端开始向右扫描，第二个数组以一指针j 从数组最右端开始向左扫描，如果下面出现了和上面一样的数，即a[*i]=a[*j]，就找出这俩个数来了。 如上，i，j最终在第一个，和第二个序列中找到了相同的数4和11，所以符合条件的两个数，即为4+11=15。 怎么样，两端同时查找，时间复杂度瞬间缩短到了O(N)，但却同时需要O(N)的空间存储第二个数组（<span class="citation" data-cites="飞羽">@飞羽</span>：要达到O(N)的复杂度，第一个数组以一指针i 从数组最左端开始向右扫描，第二个数组以一指针j 从数组最右端开始向左扫描，首先初始i指向元素1，j指向元素0，谁指的元素小，谁先移动，由于1(i)&gt; 0(j)，所以i不动，j向左移动。然后j移动到元素4发现大于元素1，故而停止移动j，开始移动i，直到i指向4，这时,i指向的元素与j指向的元素相，故而判断4是满足条件的第一个数；然后同时移动i,j再进行判断，直到它们到达边界）。</p>
<p>当然，你还可以构造hash表，正如编程之美上的所述，给定一个数字，根据hash映射查找另一个数字是否也在数组中，只需用O(1)的时间，这样的话，总体的算法通上述思路3 一样，也能降到O(N)，但有个缺陷，就是构造hash额外增加了O(N)的空间，此点同上述思路 3。不过，空间换时间，仍不失为在时间要求较严格的情况下的一种好办法。</p>
<p>如果数组是无序的，先排序(N log N)，然后用两个指针i，j，各自指向数组的首尾两端，令i=0，j=n-1，然后i++，j--，逐次判断a[i]+a[j]?=sum，如果某一刻a[i]+a[j] &gt; sum，则要想办法让sum的值减小，所以此刻i不动，j--，如果某一刻a[i]+a[j] &lt; sum，则要想办法让sum的值增大，所以此刻i++，j不动。所以，数组无序的时候，时间复杂度最终为O(N log N + N）=O(N log N)，若原数组是有序的，则不需要事先的排序，直接O(N)搞定，且空间复杂度还是O(1)，此思路是相对于上述所有思路的一种改进。（如果有序，直接两个指针两端扫描，时间O(N)，如果无序，先排序后两端扫描，时间O(N log N + N)=O(N log N)，空间始终都为O(1)）。（与上述思路2相比，排序后的时间开销由之前的二分的n*logn降到了扫描的O(N)）。</p>
<p>总结：</p>
<p>不论原序列是有序还是无序，解决这类题有以下三种办法：1、二分（若无序，先排序后二分），时间复杂度总为O(N log N)，空间复杂度为O（1）；2、扫描一遍X-S[i] 映射到一个数组或构造hash表，时间复杂度为O(N)，空间复杂度为O(N)；3、两个指针两端扫描（若无序，先排序后扫描），时间复杂度最后为：有序O(N)，无序O(N log N + N)=O(N log N)，空间复杂度都为O(1)。</p>
<p>所以，要想达到时间O(N)，空间O(1)的目标，除非原数组是有序的（指针扫描法），不然，当数组无序的话，就只能先排序，后指针扫描法或二分（时间 O(N log N)，空间O(1)），或映射或hash（时间O(N)，空间O(N)）。时间或空间，必须牺牲一个，自个权衡吧。</p>
<p>综上，若是数组有序的情况下，优先考虑两个指针两端扫描法，以达到最佳的时（O(N)），空（O(1)）效应。否则，如果要排序的话，时间复杂度最快当然是只能达到O(N log N)，空间O(1)则是不在话下。</p>
<p>代码：</p>
<p>ok，在进入第二节之前，咱们先来实现思路5（这里假定数组已经是有序的），代码可以如下编写（两段代码实现）：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//代码一</span>
<span class="co">//O（N）</span>
Pair findSum(<span class="dt">int</span> *s, <span class="dt">int</span> n, <span class="dt">int</span> x)
{
    <span class="co">//sort(s, s+n);   如果数组非有序的，那就事先排好序O(N log N)</span>

    <span class="dt">int</span> *begin = s;
    <span class="dt">int</span> *end = s+n<span class="dv">-1</span>;

    <span class="kw">while</span>(begin &lt; end)    <span class="co">//俩头夹逼，或称两个指针两端扫描法，很经典的方法，O(N)</span>
    {
        <span class="kw">if</span>(*begin + *end &gt; x)
        {
            --end;
        }
        <span class="kw">else</span> <span class="kw">if</span>(*begin + *end &lt; x)
        {
            ++begin;
        }
        <span class="kw">else</span>
        {
            <span class="kw">return</span> Pair(*begin, *end);
        }
    }

    <span class="kw">return</span> Pair(-<span class="dv">1</span>, -<span class="dv">1</span>);
}

<span class="co">//或者如下编写，</span>
<span class="co">//代码二</span>
<span class="co">//copyright@ zhedahht &amp;&amp; yansha</span>
<span class="co">//July、updated，2011.05.14。</span>
bool find_num(<span class="dt">int</span> data[], <span class="dt">unsigned</span> <span class="dt">int</span> length, <span class="dt">int</span> sum, <span class="dt">int</span>&amp; first_num, <span class="dt">int</span>&amp; second_num)
{
    <span class="kw">if</span>(length &lt; <span class="dv">1</span>)
        <span class="kw">return</span> true;

    <span class="dt">int</span> begin = <span class="dv">0</span>;
    <span class="dt">int</span> end = length - <span class="dv">1</span>;

    <span class="kw">while</span>(end &gt; begin)
    {
        <span class="dt">long</span> current_sum = data[begin] + data[end];

        <span class="kw">if</span>(current_sum == sum)
        {
            first_num = data[begin];
            second_num = data[end];
            <span class="kw">return</span> true;
        }
        <span class="kw">else</span> <span class="kw">if</span>(current_sum &gt; sum)
            end--;
        <span class="kw">else</span>
            begin++;
    }
    <span class="kw">return</span> false;
}</code></pre>
<p>扩展：</p>
<ol type="1">
<li>如果在返回找到的两个数的同时，还要求你返回这两个数的位置列?</li>
<li>如果把题目中的要你寻找的两个数改为“多个数”，或任意个数列?（请看下面第二节）</li>
<li>二分查找时： <code>left &lt;= right，right = middle - 1;left &lt; right，right = middle;</code></li>
</ol>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//算法所操作的区间,是左闭右开区间,还是左闭右闭区间,这个区间,需要在循环初始化,</span>
<span class="co">//循环体是否终止的判断中,以及每次修改left,right区间值这三个地方保持一致,否则就可能出错.</span>

<span class="co">//二分查找实现一</span>
<span class="dt">int</span> search(<span class="dt">int</span> array[], <span class="dt">int</span> n, <span class="dt">int</span> v)
{
    <span class="dt">int</span> left, right, middle;

    left = <span class="dv">0</span>, right = n - <span class="dv">1</span>;

    <span class="kw">while</span> (left &lt;= right)
    {
        middle = left + (right - left) / <span class="dv">2</span>;
        <span class="kw">if</span> (array[middle] &gt; v)
        {
            right = middle - <span class="dv">1</span>;
        }
        <span class="kw">else</span> <span class="kw">if</span> (array[middle] &lt; v)
        {
            left = middle + <span class="dv">1</span>;
        }
        <span class="kw">else</span>
        {
            <span class="kw">return</span> middle;
        }
    }

    <span class="kw">return</span> -<span class="dv">1</span>;
}

<span class="co">//二分查找实现二</span>
<span class="dt">int</span> search(<span class="dt">int</span> array[], <span class="dt">int</span> n, <span class="dt">int</span> v)
{
    <span class="dt">int</span> left, right, middle;

    left = <span class="dv">0</span>, right = n;

    <span class="kw">while</span> (left &lt; right)
    {
        middle = left + (right - left) / <span class="dv">2</span>;

        <span class="kw">if</span> (array[middle] &gt; v)
        {
            right = middle;
        }
        <span class="kw">else</span> <span class="kw">if</span> (array[middle] &lt; v)
        {
            left = middle + <span class="dv">1</span>;
        }
        <span class="kw">else</span>
        {
            <span class="kw">return</span> middle;
        }
    }

    <span class="kw">return</span> -<span class="dv">1</span>;
}</code></pre>
<h2 id="第二节寻找和为定值的多个数">第二节、寻找和为定值的多个数</h2>
<p>第21题（数组）</p>
<p>2010年中兴面试题</p>
<p>编程求解：</p>
<p>输入两个整数 n 和 m，从数列1，2，3.......n 中 随意取几个数,</p>
<p>使其和等于 m ,要求将其中所有的可能组合列出来。</p>
<p>解法一</p>
<p>我想，稍后给出的程序已经足够清楚了，就是要注意到放n，和不放n个区别，即可，代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// 21题递归方法</span>
<span class="co">//copyright@ July &amp;&amp; yansha</span>
<span class="co">//July、yansha，updated。</span>
<span class="ot">#include&lt;list&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
using namespace std;

list&lt;<span class="dt">int</span>&gt;list1;
<span class="dt">void</span> find_factor(<span class="dt">int</span> sum, <span class="dt">int</span> n)
{
    <span class="co">// 递归出口</span>
    <span class="kw">if</span>(n &lt;= <span class="dv">0</span> || sum &lt;= <span class="dv">0</span>)
        <span class="kw">return</span>;

    <span class="co">// 输出找到的结果</span>
    <span class="kw">if</span>(sum == n)
    {
        <span class="co">// 反转list</span>
        list1.reverse();
        <span class="kw">for</span>(list&lt;<span class="dt">int</span>&gt;::iterator iter = list1.begin(); iter != list1.end(); iter++)
            cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot; + &quot;</span>;
        cout &lt;&lt; n &lt;&lt; endl;
        list1.reverse();
    }

    list1.push_front(n);      <span class="co">//典型的01背包问题</span>
    find_factor(sum-n, n<span class="dv">-1</span>);   <span class="co">//放n，n-1个数填满sum-n</span>
    list1.pop_front();
    find_factor(sum, n<span class="dv">-1</span>);     <span class="co">//不放n，n-1个数填满sum</span>
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sum, n;
    cout &lt;&lt; <span class="st">&quot;请输入你要等于多少的数值sum:&quot;</span> &lt;&lt; endl;
    cin &gt;&gt; sum;
    cout &lt;&lt; <span class="st">&quot;请输入你要从1.....n数列中取值的n：&quot;</span> &lt;&lt; endl;
    cin &gt;&gt; n;
    cout &lt;&lt; <span class="st">&quot;所有可能的序列，如下：&quot;</span> &lt;&lt; endl;
    find_factor(sum,n);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h1 id="解法二">解法二</h1>
<p><span class="citation" data-cites="zhouzhenren">@zhouzhenren</span>：</p>
<p>这个问题属于子集和问题（也是背包问题）。本程序采用 回溯法+剪枝</p>
<p>X数组是解向量，t=∑(1,..,k-1)Wi*Xi, r=∑(k,..,n)Wi</p>
<p>若t+Wk+W(k+1)&lt;=M,则Xk=true，递归左儿子(X1,X2,..,X(k-1),1)；否则剪枝；</p>
<p>若t+r-Wk&gt;=M &amp;&amp; t+W(k+1)&lt;=M,则置Xk=0，递归右儿子(X1,X2,..,X(k-1),0)；否则剪枝；</p>
<p>本题中W数组就是(1,2,..,n),所以直接用k代替WK值。</p>
<p>代码编写如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@ 2011 zhouzhenren</span>

<span class="co">//输入两个整数 n 和 m，从数列1，2，3.......n 中 随意取几个数,</span>
<span class="co">//使其和等于 m ,要求将其中所有的可能组合列出来。</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>

<span class="co">/**</span>
<span class="co"> * 输入t， r， 尝试Wk</span>
<span class="co"> */</span>
<span class="dt">void</span> sumofsub(<span class="dt">int</span> t, <span class="dt">int</span> k ,<span class="dt">int</span> r, <span class="dt">int</span>&amp; M, bool&amp; flag, bool* X)
{
    X[k] = true;   <span class="co">// 选第k个数</span>
    <span class="kw">if</span> (t + k == M) <span class="co">// 若找到一个和为M，则设置解向量的标志位，输出解</span>
    {
        flag = true;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= k; ++i)
        {
            <span class="kw">if</span> (X[i] == <span class="dv">1</span>)
            {
                printf(<span class="st">&quot;%d &quot;</span>, i);
            }
        }
        printf(<span class="st">&quot;/n&quot;</span>);
    }
    <span class="kw">else</span>
    {   <span class="co">// 若第k+1个数满足条件，则递归左子树</span>
        <span class="kw">if</span> (t + k + (k<span class="dv">+1</span>) &lt;= M)
        {
            sumofsub(t + k, k + <span class="dv">1</span>, r - k, M, flag, X);
        }
        <span class="co">// 若不选第k个数，选第k+1个数满足条件，则递归右子树</span>
        <span class="kw">if</span> ((t + r - k &gt;= M) &amp;&amp; (t + (k<span class="dv">+1</span>) &lt;= M))
        {
            X[k] = false;
            sumofsub(t, k + <span class="dv">1</span>, r - k, M, flag, X);
        }
    }
}

<span class="dt">void</span> search(<span class="dt">int</span>&amp; N, <span class="dt">int</span>&amp; M)
{
    <span class="co">// 初始化解空间</span>
    bool* X = (bool*) malloc(<span class="kw">sizeof</span>(bool) * (N<span class="dv">+1</span>));
    memset(X, false, <span class="kw">sizeof</span>(bool) * (N<span class="dv">+1</span>));
    <span class="dt">int</span> sum = (N + <span class="dv">1</span>) * N * <span class="fl">0.</span>5f;
    <span class="kw">if</span> (<span class="dv">1</span> &gt; M || sum &lt; M) <span class="co">// 预先排除无解情况</span>
    {
        printf(<span class="st">&quot;not found/n&quot;</span>);
        <span class="kw">return</span>;
    }
    bool f = false;
    sumofsub(<span class="dv">0</span>, <span class="dv">1</span>, sum, M, f, X);
    <span class="kw">if</span> (!f)
    {
        printf(<span class="st">&quot;not found/n&quot;</span>);
    }
    free(X);
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> N, M;
    printf(<span class="st">&quot;请输入整数N和M/n&quot;</span>);
    scanf(<span class="st">&quot;%d%d&quot;</span>, &amp;N, &amp;M);
    search(N, M);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>扩展：</p>
<p>1、从一列数中筛除尽可能少的数使得从左往右看，这些数是从小到大再从大到小的（网易）。</p>
<p>2、有两个序列a,b，大小都为n,序列元素的值任意整数，无序；</p>
<p>要求：通过交换a,b中的元素，使[序列a元素的和]与[序列b元素的和]之间的差最小。</p>
<p>例如:</p>
<p>var a=[100,99,98,1,2, 3];</p>
<p>var b=[1, 2, 3, 4,5,40];（微软100题第32题）。</p>
<p><span class="citation" data-cites="well">@well</span>：[fairywell]:</p>
<p>给出扩展问题 1 的一个解法：</p>
<p>1、从一列数中筛除尽可能少的数使得从左往右看，这些数是从小到大再从大到小的（网易）。</p>
<p>双端 LIS 问题，用 DP 的思想可解，目标规划函数 max{ b[i] + c[i] - 1 }, 其中 b[i] 为从左到右， 0 ~ i 个数之间满足递增的数字个数； c[i] 为从右到左， n-1 ~ i 个数之间满足递增的数字个数。最后结果为 n - max + 1。其中 DP 的时候，可以维护一个 inc[] 数组表示递增数字序列，inc[i] 为从小到大第 i 大的数字，然后在计算 b[i] c[i] 的时候使用二分查找在 inc[] 中找出区间 inc[0] ~ inc[i-1] 中小于 a[i] 的元素个数（low）。 源代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/**</span>
<span class="co">* The problem:</span>
<span class="co">* 从一列数中筛除尽可能少的数使得从左往右看，这些数是从小到大再从大到小的（网易）。</span>
<span class="co">* use binary search, perhaps you should compile it with -std=c99</span>
<span class="co">* fairywell 2011</span>
<span class="co">*/</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#define MAX_NUM    (1U&lt;&lt;31)</span>

<span class="dt">int</span>
main()
{
    <span class="dt">int</span> i, n, low, high, mid, max;

    printf(<span class="st">&quot;Input how many numbers there are: &quot;</span>);
    scanf(<span class="st">&quot;%d/n&quot;</span>, &amp;n);
    <span class="co">/* a[] holds the numbers, b[i] holds the number of increasing numbers</span>
<span class="co">    * from a[0] to a[i], c[i] holds the number of increasing numbers</span>
<span class="co">    * from a[n-1] to a[i]</span>
<span class="co">    * inc[] holds the increasing numbers</span>
<span class="co">    * VLA needs c99 features, compile with -stc=c99</span>
<span class="co">    */</span>
    <span class="dt">double</span> a[n], b[n], c[n], inc[n];

    printf(<span class="st">&quot;Please input the numbers:/n&quot;</span>);
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i) scanf(<span class="st">&quot;%lf&quot;</span>, &amp;a[i]);

    <span class="co">// update array b from left to right</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i) inc[i] = (<span class="dt">unsigned</span>) MAX_NUM;
    <span class="co">//b[0] = 0;</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i) {
        low = <span class="dv">0</span>; high = i;
        <span class="kw">while</span> (low &lt; high) {
            mid = low + (high-low)*<span class="fl">0.5</span>;
            <span class="kw">if</span> (inc[mid] &lt; a[i]) low = mid + <span class="dv">1</span>;
            <span class="kw">else</span> high = mid;
        }
        b[i] = low + <span class="dv">1</span>;
        inc[low] = a[i];
    }

    <span class="co">// update array c from right to left</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i) inc[i] = (<span class="dt">unsigned</span>) MAX_NUM;
    <span class="co">//c[0] = 0;</span>
    <span class="kw">for</span> (i = n<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; --i) {
        low = <span class="dv">0</span>; high = i;
        <span class="kw">while</span> (low &lt; high) {
            mid = low + (high-low)*<span class="fl">0.5</span>;
            <span class="kw">if</span> (inc[mid] &lt; a[i]) low = mid + <span class="dv">1</span>;
            <span class="kw">else</span> high = mid;
        }
        c[i] = low + <span class="dv">1</span>;
        inc[low] = a[i];
    }

    max = <span class="dv">0</span>;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i )
        <span class="kw">if</span> (b[i]+c[i] &gt; max) max = b[i] + c[i];
        printf(<span class="st">&quot;%d number(s) should be erased at least./n&quot;</span>, n<span class="dv">+1</span>-max);
        <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p><span class="citation" data-cites="yansha">@yansha</span>：fairywell的程序很赞，时间复杂度O(N log N)，这也是我能想到的时间复杂度最优值了。不知能不能达到O(N)。</p>
<p>扩展题第2题</p>
<p>当前数组a和数组b的和之差为</p>
<p><code>A = sum(a) - sum(b)</code></p>
<p>a的第i个元素和b的第j个元素交换后，a和b的和之差为</p>
<pre><code>A&#39; = sum(a) - a[i] + b[j] - （sum(b) - b[j] + a[i])

       = sum(a) - sum(b) - 2 (a[i] - b[j])

       = A - 2 (a[i] - b[j])</code></pre>
<p>设x = a[i] - b[j]，得</p>
<p><code>|A| - |A'| = |A| - |A-2x|</code></p>
<p>假设A &gt; 0,</p>
<p>当x 在 (0,A)之间时，做这样的交换才能使得交换后的a和b的和之差变小，x越接近A/2效果越好,</p>
<p>如果找不到在(0,A)之间的x，则当前的a和b就是答案。</p>
<p>所以算法大概如下：</p>
<p>在a和b中寻找使得x在(0,A)之间并且最接近A/2的i和j，交换相应的i和j元素，重新计算A后，重复前面的步骤直至找不到(0,A)之间的x为止。</p>
<p>接上，<span class="citation" data-cites="yuan">@yuan</span>：</p>
<p>a[i]-b[j]要接近A/2，则可以这样想，</p>
<p>我们可以对于a数组的任意一个a[k],在数组b中找出与a[k]-C最接近的数（C就是常数，也就是0.5*A）</p>
<p>这个数要么就是a[k]-C，要么就是比他稍大，要么比他稍小，所以可以要二分查找。</p>
<p>查找最后一个小于等于a[k]-C的数和第一个大于等于a[k]-C的数，</p>
<p>然后看哪一个与a[k]-C更加接近，所以T(N) = N log N。</p>
<p>除此之外，受本文读者xiafei1987128启示，有朋友在stacoverflow上也问过一个类似的题，:-)，见此：<a href="http://stackoverflow.com/questions/9047908/swap-the-elements-of-two-sequences-such-that-the-difference-of-the-element-sums">http://stackoverflow.com/questions/9047908/swap-the-elements-of-two-sequences-such-that-the-difference-of-the-element-sums</a>。感兴趣的可以看看。</p>
<h1 id="第六章亲和数问题--求解500万以内的亲和数">第六章：亲和数问题--求解500万以内的亲和数</h1>
<p>作者：上善若水、July、yansha</p>
<h2 id="前奏-1">前奏</h2>
<p>本章陆续开始，除了继续保持原有的字符串、数组等面试题之外，会有意识的间断性节选一些有关数字趣味小而巧的面试题目，重在突出思路的“巧”，和“妙”。本章亲和数问题之关键字，“500万”，“线性复杂度”。</p>
<h2 id="第一节亲和数问题">第一节、亲和数问题</h2>
<p>题目描述：</p>
<p>求500万以内的所有亲和数</p>
<p>如果两个数a和b，a的所有真因数之和等于b,b的所有真因数之和等于a,则称a,b是一对亲和数。 例如220和284，1184和1210，2620和2924。</p>
<p><strong>分析</strong>：</p>
<p>首先得明确到底是什么是亲和数?</p>
<p>亲和数问题最早是由毕达哥拉斯学派发现和研究的。他们在研究数字的规律的时候发现有以下性质特点的两个数:</p>
<p>220的真因子是：1、2、4、5、10、11、20、22、44、55、110；</p>
<p>284的真因子是：1、2、4、71、142。</p>
<p>而这两个数恰恰等于对方的真因子各自加起来的和（sum[i]表示数i 的各个真因子的和），即</p>
<p>220=1+2+4+71+142=sum[284],</p>
<p>284=1+2+4+5+10+11+20+22+44+55+110=sum[220]。</p>
<p>得284的真因子之和sum[284]=220，且220的真因子之和sum[220]=284，即有sum[220]=sum[sum[284]]=284。</p>
<p>如此，是否已看出丝毫端倪?</p>
<p>如上所示，考虑到1是每个整数的因子，把出去整数本身之外的所有因子叫做这个数的“真因子”。如果两个整数，其中每一个真因子的和都恰好等于另一个数，那么这两个数，就构成一对“亲和数”（有关亲和数的更多讨论，可参考<a href="http://t.cn/hesH09">这里</a>)。</p>
<p><strong>求解</strong>: 了解了什么是亲和数，接下来咱们一步一步来解决上面提出的问题（以下内容大部引自水的原话，同时水哥有一句原话，<strong>“在你真正弄弄懂这个范例之前，你不配说你懂数据结构和算法”</strong>）。</p>
<ol type="1">
<li>看到这个问题后，第一想法是什么？模拟搜索+剪枝？回溯？时间复杂度有多大？其中bn为an的伪亲和数，即bn是an的真因数之和大约是多少？至少是10<sup>13（<span class="citation" data-cites="iicup">@iicup</span>：N</sup>1.5 对于5*10^6 , 次数大致 10^10 而不是 10^13.）的数量级的。那么对于每秒千万次运算的计算机来说，大概在1000多天也就是3年内就可以搞定了（iicup的计算: 10^13 / 10^7 =1000000(秒) 大约 278 小时. ）。如果是基于这个基数在优化，你无法在一天内得到结果的。</li>
<li>一个不错的算法应该在半小时之内搞定这个问题，当然这样的算法有很多。节约时间的做法是可以生成伴随数组，也就是空间换时间，但是那样，空间代价太大，因为数据规模庞大。</li>
<li>在稍后的算法中，依然使用的伴随数组，只不过，因为题目的特殊性，只是它方便和巧妙地利用了下标作为伴随数组，来节约时间。同时，将回溯的思想换成递推的思想(预处理数组的时间复杂度为<strong>O(N*logN)</strong>(logN为调和级数)，扫描数组的时间复杂度为线性<strong>O(N)</strong>。所以，总的时间复杂度为<strong>O(N*logN+N)</strong>(其中logN为调和级数))。</li>
</ol>
<h2 id="第二节伴随数组线性遍历">第二节、伴随数组线性遍历</h2>
<p>依据上文中的第3点思路，编写如下代码：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//求解亲和数问题</span>

<span class="co">//第一个for和第二个for循环是logN*N（调和级数）次遍历,第三个for循环扫描O(N)。</span>
<span class="co">//所以总的时间复杂度为 O(N*logN) + O(n) =O(N*logN+N)（其中logN为调和级数）。</span>

<span class="co">//关于第一个for和第二个for寻找中，调和级数的说明：</span>
<span class="co">//比如给2的倍数加2，那么应该是  n/2次，3的倍数加3 应该是 n/3次，...</span>
<span class="co">//那么其实就是n*（1+1/2+1/3+1/4+...1/(n/2)）=n*（调和级数）=n*logn。</span>

<span class="co">//copyright@ 上善若水</span>
<span class="co">//July、updated，2011.05.24。</span>
<span class="ot">#include&lt;stdio.h&gt;</span>

<span class="dt">int</span> sum[<span class="dv">5000010</span>];   <span class="co">//为防越界</span>

<span class="dt">int</span> main()
{
    <span class="dt">int</span> i, j;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt;= <span class="dv">5000000</span>; i++)
        sum[i] = <span class="dv">1</span>;  <span class="co">//1是所有数的真因数所以全部置1</span>

    <span class="kw">for</span> (i = <span class="dv">2</span>; i + i &lt;= <span class="dv">5000000</span>; i++)  <span class="co">//预处理，预处理是logN（调和级数）*N。</span>
        <span class="co">//@litaoye：调和级数1/2 + 1/3 + 1/4......的和近似为ln(n)，</span>
        <span class="co">//因此O(n *(1/2 + 1/3 + 1/4......)) = O(n * ln(n)) = O(N*log(N))。</span>
    {
        <span class="co">//5000000以下最大的真因数是不超过它的一半的</span>
        j = i + i;  <span class="co">//因为真因数，所以不能算本身，所以从它的2倍开始</span>
        <span class="kw">while</span> (j &lt;= <span class="dv">5000000</span>)
        {
            <span class="co">//将所有i的倍数的位置上加i</span>
            sum[j] += i;
            j += i;
        }
    }

    <span class="kw">for</span> (i = <span class="dv">220</span>; i &lt;= <span class="dv">5000000</span>; i++)   <span class="co">//扫描，O（N）。</span>
    {
        <span class="co">// 一次遍历，因为知道最小是220和284因此从220开始</span>
        <span class="kw">if</span> (sum[i] &gt; i &amp;&amp; sum[i] &lt;= <span class="dv">5000000</span> &amp;&amp; sum[sum[i]] == i)
        {
            <span class="co">//去重，不越界，满足亲和</span>
            printf(<span class="st">&quot;%d %d/n&quot;</span>,i,sum[i]);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p><strong>运行结果</strong>:</p>
<p><img src="../images/6.1.jpg" /> &gt; <span class="citation" data-cites="上善若水">@上善若水</span>： &gt; &gt; 1、可能大家理解的还不是很清晰，我们建立一个5 000 000 的数组，从1到2 500 000开始，在每一个下标是i的倍数的位置上加上i，那么在循环结束之后，我们得到的是什么？是类似埃斯托拉晒求素数的数组（当然里面有真的亲和数），然后只需要一次遍历就可以轻松找到所有的亲和数了。时间复杂度，线性。</p>
<blockquote>
<p>2、我们可以清晰的发现连续数据的映射可以通过数组结构本身的特点替代，用来节约空间，这是数据结构的艺术。在大规模连续数据的回溯处理上，可以通过转化为递推生成的方法，逆向思维操作，这是算法的艺术。</p>
</blockquote>
<blockquote>
<p>3、把最简单的东西运用的最巧妙的人，要比用复杂方法解决复杂问题的人要头脑清晰。</p>
</blockquote>
<h2 id="第三节程序的构造与解释">第三节、程序的构造与解释</h2>
<p>我再来具体解释下上述程序的原理，ok，举个例子，假设是求10以内的亲和数，求解步骤如下：</p>
<p>因为所有数的真因数都包含1，所以，先在各个数的下方全部置1</p>
<p>1. 然后取i=2,3,4,5（i&lt;=10/2），j依次对应的位置为j=（4、6、8、10），（6、9）,（8）,（10）各数所对应的位置。依据j所找到的位置，在j所指的各个数的下面加上各个真因子i（i=2、3、4、5）。</p>
<p>2. 整个过程，即如下图所示（如sum[6]=1+2+3=6，sum[10]=1+2+5=8.）:</p>
<figure>
<img src="../images/6.2.jpg" />
</figure>
<p>3. 然后一次遍历i从220开始到5000000，i每遍历一个数后, 将i对应的数下面的各个真因子加起来得到一个和sum[i]，如果这个和sum[i]==某个i’，且sum[i‘]=i， 那么这两个数i和i’，即为一对亲和数。</p>
<p>4. i=2；sum[4]+=2，sum[6]+=2，sum[8]+=2，sum[10]+=2，sum[12]+=2... i=3，sum[6]+=3，sum[9]+=3...</p>
<p>5. i=220时，sum[220]=284，i=284时，sum[284]=220；即sum[220]=sum[sum[284]]=284， 得出220与284是一对亲和数。所以，最终输出220、284，...</p>
<p><strong>特别鸣谢</strong></p>
<blockquote>
<p>litaoye专门为本亲和数问题开帖子继续阐述，有兴趣的朋友可继续参见<a href="http://topic.csdn.net/u/20110526/21/129c2235-1f44-42e9-a55f-878920c21e19.html">这里</a>。同时，任何人对本亲和数问题有任何问题，也可以回复到上述帖子上。</p>
</blockquote>
<pre class="csharp"><code>//求解亲和数问题
//copyright@ litaoye
//July、胡滨，updated，2011.05.26。
using System;
using System.Collections.Generic;

namespace CSharpTest
{
    class Program
    {
        public static void Main()
        {
            int max = 5000000;
            DateTime start = DateTime.Now;
            int[] counter = CreateCounter(max);

            for (int i = 0; i &lt; counter.Length; i++)
            {
                int num = counter[i] - i;
                if (num &lt; counter.Length &amp;&amp; num &gt; i &amp;&amp; counter[num] == counter[i])
                    Console.WriteLine(&quot;{0} {1}&quot;, i, num);
            }
            Console.WriteLine((DateTime.Now - start).TotalSeconds);

            Console.ReadKey();
        }

        static int[] CreateCounter(int n)
        {
            List&lt;int&gt; primes = new List&lt;int&gt;();
            int[] counter = new int[n + 1];
            counter[1] = 1;

            for (int i = 2; i &lt;= n; i++)
            {
                if (counter[i] == 0)
                {
                    counter[i] = i + 1;
                    primes.Add(i);
                }

                for (int j = 0; j &lt; primes.Count; j++)
                {
                    if (primes[j] * i &gt; n)
                        break;

                    if (i % primes[j] == 0)
                    {
                        int k = i;
                        int l = primes[j] * primes[j];

                        while (k % primes[j] == 0)
                        {
                            l *= primes[j];
                            k /= primes[j];
                        }

                        counter[primes[j] * i] = counter[k] * (l - 1) / (primes[j] - 1);
                        break;
                    }
                    else
                        counter[primes[j] * i] = counter[i] * (primes[j] + 1);
                }
            }

            return counter;
        }
    }
}

/*
测试结果：
0.484375
0.484375
0.46875
单位second。
*/</code></pre>
<h1 id="第七章求连续子数组的最大和">第七章：求连续子数组的最大和</h1>
<h2 id="第一节-求子数组的最大和">第一节 求子数组的最大和</h2>
<p><strong>题目描述：</strong> 输入一个整形数组，数组里有正数也有负数。 数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
<p>例如输入的数组为<code>1, -2, 3, 10, -4, 7, 2, -5</code>，和最大的子数组为<code>3, 10, -4, 7, 2</code>， 因此输出为该子数组的和18。</p>
<p>这个问题在各大公司面试中出现频率之频繁，被人引用次数之多，非一般面试题可与之匹敌。单凭这点，就没有理由不入选狂想曲系列中了。此题曾作为本人之前整理的微软100题中的第3题，至今反响也很大。ok，下面，咱们来一步一步分析这个题。</p>
<p><strong>分析：</strong> 1、求一个数组的最大子数组和，如此序列<code>1, -2, 3, 10, -4, 7, 2, -5</code>，我想最最直观也是最野蛮的办法便是，三个for循环三层遍历，求出数组中每一个子数组的和，最终求出这些子数组的最大的一个值。 记Sum[i, …, j]为数组A中第i个元素到第j个元素的和（其中0 &lt;= i &lt;= j &lt; n），遍历所有可能的Sum[i, …, j]，那么时间复杂度为O(N^3)：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//本段代码引自编程之美</span>
<span class="dt">int</span> MaxSum(<span class="dt">int</span>* A, <span class="dt">int</span> n)
{
    <span class="dt">int</span> maximum = -INF;
    <span class="dt">int</span> sum = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
    {
        <span class="kw">for</span> (<span class="dt">int</span> j = i; j &lt; n; j++)
        {
            <span class="kw">for</span> (<span class="dt">int</span> k = i; k &lt;= j; k++)
            {
                sum += A[k];
            }
            <span class="kw">if</span> (sum &gt; maximum)
                maximum = sum;

            sum = <span class="dv">0</span>; <span class="co">//这里要记得清零，否则的话sum最终存放的是所有子数组的和。也就是编程之美上所说的bug。多谢苍狼。</span>
        }
    }
    <span class="kw">return</span> maximum;
}</code></pre>
<p>2、其实这个问题，在我之前上传的微软100题，答案V0.2版[第1-20题答案]，便直接给出了以下O(N)的算法：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@ July 2010/10/18</span>
<span class="co">//updated，2011.05.25.</span>
<span class="ot">#include &lt;iostream.h&gt;</span>

<span class="dt">int</span> maxSum(<span class="dt">int</span>* a, <span class="dt">int</span> n)
{
    <span class="dt">int</span> sum = <span class="dv">0</span>;
    <span class="co">//其实要处理全是负数的情况，很简单，如稍后下面第3点所见，直接把这句改成：&quot;int sum=a[0]&quot;即可</span>
    <span class="co">//也可以不改，当全是负数的情况，直接返回0，也不见得不行。</span>
    <span class="dt">int</span> b = <span class="dv">0</span>;

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
    {
        <span class="kw">if</span> (b &lt; <span class="dv">0</span>)
            b = a[i];
        <span class="kw">else</span>
            b += a[i];
        <span class="kw">if</span> (sum &lt; b)
            sum = b;
    }
    <span class="kw">return</span> sum;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">10</span>] = {<span class="dv">1</span>, -<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">10</span>, -<span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">2</span>, -<span class="dv">5</span>};
    <span class="co">//int a[] = {-1,-2,-3,-4};  //测试全是负数的用例</span>
    cout &lt;&lt; maxSum(a, <span class="dv">8</span>) &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">/*-------------------------------------</span>
<span class="co">  解释下：</span>
<span class="co">  例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，</span>
<span class="co">  那么最大的子数组为3, 10, -4, 7, 2，</span>
<span class="co">  因此输出为该子数组的和18。</span>

<span class="co">  所有的东西都在以下俩行，</span>
<span class="co">  即：</span>
<span class="co">  b  ：  0  1  -1  3  13   9  16  18  13</span>
<span class="co">  sum：  0  1   1  3  13  13  16  18  18</span>

<span class="co">  其实算法很简单，当前面的几个数，加起来后，b&lt;0后，</span>
<span class="co">  把b重新赋值，置为下一个元素，b=a[i]。</span>
<span class="co">  当b&gt;sum，则更新sum=b;</span>
<span class="co">  若b&lt;sum，则sum保持原值，不更新。。July、10/31。</span>
<span class="co">  ----------------------------------*/</span></code></pre>
<p>3、不少朋友看到上面的答案之后，认为上述思路2的代码，没有处理全是负数的情况，当全是负数的情况时，我们可以让程序返回0，也可以让其返回最大的那个负数，下面便是前几日重写的，修改后的处理全是负数情况（返回最大的负数）的代码：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@ July</span>
<span class="co">//July、updated，2011.05.25。</span>
<span class="ot">#include &lt;iostream.h&gt;</span>
<span class="ot">#define n 4           </span><span class="co">//多定义了一个变量</span>

<span class="dt">int</span> maxsum(<span class="dt">int</span> a[n])
<span class="co">//于此处，你能看到上述思路2代码（指针）的优势</span>
{
    <span class="dt">int</span> max = a[<span class="dv">0</span>];       <span class="co">//全负情况，返回最大数</span>
    <span class="dt">int</span> sum = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)
    {
        <span class="kw">if</span> (sum &gt;= <span class="dv">0</span>)    <span class="co">//如果加上某个元素，sum&gt;=0的话，就加</span>
            sum += a[j];
        <span class="kw">else</span>
            sum = a[j];  <span class="co">//如果加上某个元素，sum&lt;0了，就不加</span>
        <span class="kw">if</span> (sum &gt; max)
            max = sum;
    }
    <span class="kw">return</span> max;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a[] = { -<span class="dv">1</span>, -<span class="dv">2</span>, -<span class="dv">3</span>, -<span class="dv">4</span>};
    cout &lt;&lt; maxsum(a) &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>4、DP解法的具体方程：@ flyinghearts：设sum[i] 为前i个元素中，包含第i个元素且和最大的连续子数组，result 为已找到的子数组中和最大的。对第i+1个元素有两种选择：做为新子数组的第一个元素、放入前面找到的子数组。</p>
<pre><code>sum[i+1] = max(a[i+1], sum[i] + a[i+1])
result = max(result, sum[i])</code></pre>
<p><strong>扩展：</strong></p>
<ol type="1">
<li>如果数组是二维数组，同样要你求最大子数组的和列?</li>
<li>如果是要你求子数组的最大乘积列?</li>
<li>如果同时要求输出子段的开始和结束列?</li>
</ol>
<h2 id="第二节-data-structures-and-algorithm-analysis-in-c">第二节 Data structures and Algorithm analysis in C</h2>
<p>下面给出《Data structures and Algorithm analysis in C》中4种实现。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//感谢网友firo</span>
<span class="co">//July、2010.06.05。</span>

<span class="co">//Algorithm 1:时间效率为O(n*n*n)</span>
<span class="dt">int</span> MaxSubsequenceSum1(<span class="dt">const</span> <span class="dt">int</span> A[], <span class="dt">int</span> N)
{
    <span class="dt">int</span> ThisSum = <span class="dv">0</span> , MaxSum = <span class="dv">0</span>, i, j, k;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; N; i++)
        <span class="kw">for</span> (j = i; j &lt; N; j++)
        {
            ThisSum = <span class="dv">0</span>;
            <span class="kw">for</span> (k = i; k &lt; j; k++)
                ThisSum += A[k];

            <span class="kw">if</span> (ThisSum &gt; MaxSum)
                MaxSum = ThisSum;
        }
    <span class="kw">return</span> MaxSum;
}

<span class="co">//Algorithm 2:时间效率为O(n*n)</span>
<span class="dt">int</span> MaxSubsequenceSum2(<span class="dt">const</span> <span class="dt">int</span> A[], <span class="dt">int</span> N)
{
    <span class="dt">int</span> ThisSum = <span class="dv">0</span>, MaxSum = <span class="dv">0</span>, i, j, k;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; N; i++)
    {
        ThisSum = <span class="dv">0</span>;
        <span class="kw">for</span> (j = i; j &lt; N; j++)
        {
            ThisSum += A[j];
            <span class="kw">if</span> (ThisSum &gt; MaxSum)
                MaxSum = ThisSum;
        }
    }
    <span class="kw">return</span> MaxSum;
}

<span class="co">//Algorithm 3:时间效率为O(n*log n)</span>
<span class="co">//算法3的主要思想：采用二分策略，将序列分成左右两份。</span>
<span class="co">//那么最长子序列有三种可能出现的情况，即</span>
<span class="co">//【1】只出现在左部分.</span>
<span class="co">//【2】只出现在右部分。</span>
<span class="co">//【3】出现在中间，同时涉及到左右两部分。</span>
<span class="co">//分情况讨论之。</span>
<span class="dt">static</span> <span class="dt">int</span> MaxSubSum(<span class="dt">const</span> <span class="dt">int</span> A[], <span class="dt">int</span> Left, <span class="dt">int</span> Right)
{
    <span class="dt">int</span> MaxLeftSum, MaxRightSum;             <span class="co">//左、右部分最大连续子序列值。对应情况【1】、【2】</span>
    <span class="dt">int</span> MaxLeftBorderSum, MaxRightBorderSum; <span class="co">//从中间分别到左右两侧的最大连续子序列值，对应case【3】。</span>
    <span class="dt">int</span> LeftBorderSum, RightBorderSum;
    <span class="dt">int</span> Center, i;
    <span class="kw">if</span> (Left == Right)Base Case
        <span class="kw">if</span> (A[Left] &gt; <span class="dv">0</span>)
            <span class="kw">return</span> A[Left];
        <span class="kw">else</span>
            <span class="kw">return</span> <span class="dv">0</span>;
    Center = (Left + Right) / <span class="dv">2</span>;
    MaxLeftSum = MaxSubSum(A, Left, Center);
    MaxRightSum = MaxSubSum(A, Center + <span class="dv">1</span>, Right);
    MaxLeftBorderSum = <span class="dv">0</span>;
    LeftBorderSum = <span class="dv">0</span>;
    <span class="kw">for</span> (i = Center; i &gt;= Left; i--)
    {
        LeftBorderSum += A[i];
        <span class="kw">if</span> (LeftBorderSum &gt; MaxLeftBorderSum)
            MaxLeftBorderSum = LeftBorderSum;
    }
    MaxRightBorderSum = <span class="dv">0</span>;
    RightBorderSum = <span class="dv">0</span>;
    <span class="kw">for</span> (i = Center + <span class="dv">1</span>; i &lt;= Right; i++)
    {
        RightBorderSum += A[i];
        <span class="kw">if</span> (RightBorderSum &gt; MaxRightBorderSum)
            MaxRightBorderSum = RightBorderSum;
    }
    <span class="dt">int</span> max1 = MaxLeftSum &gt; MaxRightSum ? MaxLeftSum : MaxRightSum;
    <span class="dt">int</span> max2 = MaxLeftBorderSum + MaxRightBorderSum;
    <span class="kw">return</span> max1 &gt; max2 ? max1 : max2;
}

<span class="co">//Algorithm 4:时间效率为O(n)</span>
<span class="co">//同上述第一节中的思路3、和4。</span>
<span class="dt">int</span> MaxSubsequenceSum(<span class="dt">const</span> <span class="dt">int</span> A[], <span class="dt">int</span> N)
{
    <span class="dt">int</span> ThisSum, MaxSum, j;
    ThisSum = MaxSum = <span class="dv">0</span>;
    <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; N; j++)
    {
        ThisSum += A[j];
        <span class="kw">if</span> (ThisSum &gt; MaxSum)
            MaxSum = ThisSum;
        <span class="kw">else</span> <span class="kw">if</span> (ThisSum &lt; <span class="dv">0</span>)
            ThisSum = <span class="dv">0</span>;
    }
    <span class="kw">return</span> MaxSum;
}</code></pre>
<p>原第8章：http://blog.csdn.net/v_JULY_v/article/details/6446364 ，将废掉重写另外的议题。</p>
<p>原第9章：http://blog.csdn.net/v_JULY_v/article/details/6447013， 将废掉，重新写新的议题。</p>
<h1 id="第十章如何给107个数据量的磁盘文件排序">第十章：如何给10^7个数据量的磁盘文件排序</h1>
<p>作者:July，yansha，5，编程艺术室。</p>
<h2 id="前奏-2">前奏</h2>
<p>经过几天的痛苦沉思，最终决定，把原程序员面试题狂想曲系列正式更名为程序员编程艺术系列，同时，狂想曲创作组更名为编程艺术室。之所以要改名，我们考虑到三点：1、为面试服务不能成为我们最终或最主要的目的，2、我更愿把解答一道道面试题，ACM题等各类程序设计题目的过程，当做一种艺术来看待，3、艺术的提炼本身是一个非常非常艰难的过程，但我们乐意接受这个挑战。</p>
<p>ok，如果任何人对本编程艺术系列有任何意见，或发现了本编程艺术系列任何问题，漏洞，bug，欢迎随时提出，我们将虚心接受并感激不尽，以为他人创造更好的价值，更好的服务。</p>
<h2 id="第一节如何给磁盘文件排序">第一节、如何给磁盘文件排序</h2>
<p>问题描述： 输入：给定一个文件，里面最多含有n个不重复的正整数（也就是说可能含有少于n个不重复正整数），且其中每个数都小于等于n，n=10^7。 输出：得到按从小到大升序排列的包含所有输入的整数的列表。 条件：最多有大约1MB的内存空间可用，但磁盘空间足够。且要求运行时间在5分钟以下，10秒为最佳结果。</p>
<p>分析：下面咱们来一步一步的解决这个问题，</p>
<h3 id="归并排序">1. 归并排序</h3>
<p>你可能会想到把磁盘文件进行归并排序，但题目要求你只有1MB的内存空间可用，所以，归并排序这个方法不行。</p>
<h3 id="位图方案">2. 位图方案</h3>
<p>熟悉位图的朋友可能会想到用位图来表示这个文件集合。例如正如编程珠玑一书上所述，用一个20位长的字符串来表示一个所有元素都小于20的简单的非负整数集合，边框用如下字符串来表示集合{1,2,3,5,8,13}：</p>
<pre><code>0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0</code></pre>
<p>上述集合中各数对应的位置则置1，没有对应的数的位置则置0。</p>
<p>参考编程珠玑一书上的位图方案，针对我们的10^7个数据量的磁盘文件排序问题，我们可以这么考虑，由于每个7位十进制整数表示一个小于1000万的整数。我们可以使用一个具有1000万个位的字符串来表示这个文件，其中，当且仅当整数i在文件中存在时，第i位为1。采取这个位图的方案是因为我们面对的这个问题的特殊性：</p>
<ol type="1">
<li>输入数据限制在相对较小的范围内，</li>
<li>数据没有重复，</li>
<li>其中的每条记录都是单一的整数，没有任何其它与之关联的数据。</li>
</ol>
<p>所以，此问题用位图的方案分为以下三步进行解决：</p>
<ul>
<li>第一步，将所有的位都置为0，从而将集合初始化为空。</li>
<li>第二步，通过读入文件中的每个整数来建立集合，将每个对应的位都置为1。</li>
<li>第三步，检验每一位，如果该位为1，就输出对应的整数。</li>
</ul>
<p>经过以上三步后，产生有序的输出文件。令n为位图向量中的位数（本例中为1000 0000），程序可以用伪代码表示如下：</p>
<pre><code>//磁盘文件排序位图方案的伪代码  
//copyright@ Jon Bentley  
//July、updated，2011.05.29。  
  
//第一步，将所有的位都初始化为0  
for i ={0,....n}      
   bit[i]=0;  
//第二步，通过读入文件中的每个整数来建立集合，将每个对应的位都置为1。  
for each i in the input file     
   bit[i]=1;  
  
//第三步，检验每一位，如果该位为1，就输出对应的整数。  
for i={0...n}      
  if bit[i]==1        
    write i on the output file  </code></pre>
<p>上面只是为了简单介绍下位图算法的伪代码之抽象级描述。显然，咱们面对的问题，可不是这么简单。下面，我们试着针对这个要分两趟给磁盘文件排序的具体问题编写完整代码，如下。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@ yansha  </span>
<span class="co">//July、2010.05.30。  </span>
<span class="co">//位图方案解决10^7个数据量的文件的排序问题  </span>
<span class="co">//如果有重复的数据，那么只能显示其中一个 其他的将被忽略  </span>
<span class="ot">#include &lt;iostream&gt;  </span>
<span class="ot">#include &lt;bitset&gt;  </span>
<span class="ot">#include &lt;assert.h&gt;  </span>
<span class="ot">#include &lt;time.h&gt;  </span>
<span class="kw">using</span> <span class="kw">namespace</span> std;  

<span class="dt">const</span> <span class="dt">int</span> max_each_scan = <span class="dv">5000000</span>;  

<span class="dt">int</span> main()  
{  
    clock_t begin = clock();
    bitset&lt;max_each_scan&gt; bit_map;
    bit_map.reset();

    <span class="co">// open the file with the unsorted data</span>
    FILE *fp_unsort_file = fopen(<span class="st">&quot;data.txt&quot;</span>, <span class="st">&quot;r&quot;</span>);
    assert(fp_unsort_file);
    <span class="dt">int</span> num;

    <span class="co">// the first time scan to sort the data between 0 - 4999999</span>
    <span class="kw">while</span> (fscanf(fp_unsort_file, <span class="st">&quot;%d &quot;</span>, &amp;num) != EOF)
    {
        <span class="kw">if</span> (num &lt; max_each_scan)
        bit_map.set(num, <span class="dv">1</span>);
    }

    FILE *fp_sort_file = fopen(<span class="st">&quot;sort.txt&quot;</span>, <span class="st">&quot;w&quot;</span>);
    assert(fp_sort_file);
    <span class="dt">int</span> i;

    <span class="co">// write the sorted data into file</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; max_each_scan; i++)
    {
        <span class="kw">if</span> (bit_map[i] == <span class="dv">1</span>)
        fprintf(fp_sort_file, <span class="st">&quot;%d &quot;</span>, i);
    }

    <span class="co">// the second time scan to sort the data between 5000000 - 9999999</span>
    <span class="dt">int</span> result = fseek(fp_unsort_file, <span class="dv">0</span>, SEEK_SET);
    <span class="kw">if</span> (result)
        cout &lt;&lt; <span class="st">&quot;fseek failed!&quot;</span> &lt;&lt; endl;
    <span class="kw">else</span>
    {
        bit_map.reset();
        <span class="kw">while</span> (fscanf(fp_unsort_file, <span class="st">&quot;%d &quot;</span>, &amp;num) != EOF)
        {
            <span class="kw">if</span> (num &gt;= max_each_scan &amp;&amp; num &lt; <span class="dv">10000000</span>)
            {
                num -= max_each_scan;
                bit_map.set(num, <span class="dv">1</span>);
            }
        }
        <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; max_each_scan; i++)
        {
            <span class="kw">if</span> (bit_map[i] == <span class="dv">1</span>)
                fprintf(fp_sort_file, <span class="st">&quot;%d &quot;</span>, i + max_each_scan);
        }
    }

    clock_t end = clock();
    cout&lt;&lt;<span class="st">&quot;用位图的方法，耗时：&quot;</span>&lt;&lt;endl;
    cout &lt;&lt; (end - begin) / CLK_TCK &lt;&lt; <span class="st">&quot;s&quot;</span> &lt;&lt; endl;
    fclose(fp_sort_file);
    fclose(fp_unsort_file);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>而后测试了一下上述程序的运行时间，采取位图方案耗时14s，即14000ms：</p>
<figure>
<img src="../images/10/10.1.jpg" />
</figure>
<p>本章中，生成大数据量（1000w）的程序如下，下文第二节的多路归并算法的c++实现和第三节的磁盘文件排序的编程实现中，生成的1000w数据量也是用本程序产生的，且本章内生成的1000w数据量的数据文件统一命名为“data.txt”。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//purpose:  生成随机的不重复的测试数据</span>
<span class="co">//copyright@ 2011.04.19 yansha</span>
<span class="co">//1000w数据量，要保证生成不重复的数据量，一般的程序没有做到。</span>
<span class="co">//但，本程序做到了。</span>
<span class="co">//July、2010.05.30。</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
<span class="ot">#include &lt;assert.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> size = <span class="dv">10000000</span>;
<span class="dt">int</span> num[size];

<span class="dt">int</span> main()
{
    <span class="dt">int</span> n;
    FILE *fp = fopen(<span class="st">&quot;data.txt&quot;</span>, <span class="st">&quot;w&quot;</span>);
    assert(fp);

    <span class="kw">for</span> (n = <span class="dv">1</span>; n &lt;= size; n++)
        <span class="co">//之前此处写成了n=0;n&lt;size。导致下面有一段小程序的测试数据出现了0，特此订正。</span>
        num[n] = n;
    srand((<span class="dt">unsigned</span>)time(NULL));
    <span class="dt">int</span> i, j;

    <span class="kw">for</span> (n = <span class="dv">0</span>; n &lt; size; n++)
    {
        i = (rand() * RAND_MAX + rand()) % <span class="dv">10000000</span>;
        j = (rand() * RAND_MAX + rand()) % <span class="dv">10000000</span>;
        swap(num[i], num[j]);
    }

    <span class="kw">for</span> (n = <span class="dv">0</span>; n &lt; size; n++)
        fprintf(fp, <span class="st">&quot;%d &quot;</span>, num[n]);
    fclose(fp);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>不过很快，我们就将意识到，用此位图方法，严格说来还是不太行，空间消耗10^7/8还是大于1M（1M=1024*1024空间，小于10^7/8）。</p>
<p>既然如果用位图方案的话，我们需要约1.25MB（若每条记录是8位的正整数的话，则10000000/(1024<em>1024</em>8) ~= 1.2M）的空间，而现在只有1MB的可用存储空间，那么究竟该作何处理呢?</p>
<p>updated &amp;&amp; correct：</p>
<p><span class="citation" data-cites="yansha">@yansha</span>： 上述的位图方案，共需要扫描输入数据两次，具体执行步骤如下：</p>
<p>第一次，只处理1—4999999之间的数据，这些数都是小于5000000的，对这些数进行位图排序，只需要约5000000/8=625000Byte，也就是0.625M，排序后输出。 第二次，扫描输入文件时，只处理4999999-10000000的数据项，也只需要0.625M（可以使用第一次处理申请的内存）。 因此，总共也只需要0.625M 位图的的方法有必要强调一下，就是位图的适用范围为针对不重复的数据进行排序，若数据有重复，位图方案就不适用了。</p>
<h3 id="多路归并">3、多路归并</h3>
<p>诚然，在面对本题时，还可以通过计算分析出可以用如2的位图法解决，但实际上，很多的时候，我们都面临着这样一个问题，文件太大，无法一次性放入内存中计算处理，那这个时候咋办呢？分而治之，大而化小，也就是把整个大文件分为若干大小的几块，然后分别对每一块进行排序，最后完成整个过程的排序。k趟算法可以在kn的时间开销内和n/k的空间开销内完成对最多n个小于n的无重复正整数的排序。</p>
<p>比如可分为2块（k=2，1趟反正占用的内存只有1.25/2M），1<sub>4999999，和5000000</sub>9999999。先遍历一趟，首先排序处理1<sub>4999999之间的整数（用5000000/8=625000个字的存储空间来排序0</sub>4999999之间的整数），然后再第二趟，对5000001~1000000之间的整数进行排序处理。在稍后的第二节、第三节、第四节，我们将详细阐述并实现这种多路归并排序磁盘文件的方案。</p>
<h3 id="读者思考">4、读者思考</h3>
<p>经过上述思路3的方案之后，现在有两个局部有序的数组了，那么要得到一个完整的排序的数组，接下来改怎么做呢?或者说，如果是K路归并，得到k个排序的子数组，把他们合并成一个完整的排序数组，如何优化？或者，我再问你一个问题，K路归并用败者树 和 胜者树 效率有什么差别?这些问题，请读者思考。</p>
<h2 id="第二节多路归并算法的c实现">第二节、多路归并算法的c++实现</h2>
<p>本节咱们暂抛开咱们的问题，阐述下有关多路归并算法的c++实现问题。在稍后的第三节，咱们再来具体针对咱们的磁盘文件排序问题阐述与实现。</p>
<p>在了解多路归并算法之前，你还得了解归并排序的过程，因为下面的多路归并算法就是基于这个流程的。其实归并排序就是2路归并，而多路归并算法就是把2换成了k，即多（k）路归并。下面，举个例子来说明下此归并排序算法，如下图所示，我们对数组8 3 2 6 7 1 5 4进行归并排序：</p>
<figure>
<img src="../images/10/10.2.jpg" />
</figure>
<p><strong>归并排序算法简要介绍：</strong></p>
<p>一、思路描述：</p>
<p>设两个有序的子文件(相当于输入堆)放在同一向量中相邻的位置上：R[low..m]，R[m+1..high]，先将它们合并到一个局部的暂存向量R1(相当于输出堆)中，待合并完成后将R1复制回R[low..high]中。</p>
<p>二路归并排序的过程是：</p>
<pre><code>(1)把无序表中的每一个元素都看作是一个有序表，则有n个有序子表；
(2)把n个有序子表按相邻位置分成若干对（若n为奇数，则最后一个子表单独作为一组），每对中的两个子表进行归并，归并后子表数减少一半；
(3)反复进行这一过程，直到归并为一个有序表为止。</code></pre>
<p>二路归并排序过程的核心操作是将一维数组中相邻的两个有序表归并为一个有序表。</p>
<p>二、分类：</p>
<p>归并排序可分为：多路归并排序、两路归并排序 。 若归并的有序表有两个，叫做二路归并。一般地，若归并的有序表有k个，则称为k路归并。二路归并最为简单和常用，既适用于内部排序，也适用于外部排序。本文着重讨论外部排序下的多（K）路归并算法。</p>
<p>三、算法分析：</p>
<pre><code>1、稳定性:归并排序是一种稳定的排序。
2、存储结构要求:可用顺序存储结构。也易于在链表上实现。
3、时间复杂度: 对长度为n的文件，需进行lgn趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。。
4、空间复杂度:需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。
   注意:若用单链表做存储结构，很容易给出就地的归并排序。</code></pre>
<p>总结：与快速排序相比，归并排序的最大特点是，它是一种稳定的排序方法。归并排序一般多用于外排序。但它在内排方面也占有重要地位，因为它是基于比较的时间复杂度为O(N*Log(N))的排序算法中唯一稳定的排序，所以在需要稳定内排序时通常会选择归并排序。归并排序不要求对序列可以很快地进行随机访问，所以在链表排序的实现中很受欢迎。</p>
<p>好的，介绍完了归并排序后，回到咱们的问题。由第一节，我们已经知道，当数据量大到不适合在内存中排序时，可以利用多路归并算法对磁盘文件进行排序。</p>
<p>我们以一个包含很多个整数的大文件为例，来说明多路归并的外排序算法基本思想。假设文件中整数个数为N(N是亿级的)，整数之间用空格分开。首先分多次从该文件中读取M（十万级）个整数，每次将M个整数在内存中使用快速排序之后存入临时文件，然后使用多路归并将各个临时文件中的数据再次整体排好序后存入输出文件。显然，该排序算法需要对每个整数做2次磁盘读和2次磁盘写。以下是本程序的流程图：</p>
<figure>
<img src="../images/10/10.3.jpg" />
</figure>
<p>本程序是基于以上思想对包含大量整数文件的从小到大排序的一个简单实现，这里没有使用内存缓冲区，在归并时简单使用一个数组来存储每个临时文件的第一个元素。下面是多路归并排序算法的c++实现代码（在第四节，将给出多路归并算法的c实现）：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@ 纯净的天空 &amp;&amp; yansha    </span>
<span class="co">//5、July，updated，2010.05.28。    </span>
<span class="ot">#include &lt;iostream&gt;    </span>
<span class="ot">#include &lt;ctime&gt;    </span>
<span class="ot">#include &lt;fstream&gt;    </span>
<span class="co">//#include &quot;ExternSort.h&quot;using namespace std;    </span>
<span class="co">//使用多路归并进行外排序的类    </span>
<span class="co">//ExternSort.h    </span>
<span class="co">/** 大数据量的排序* 多路归并排序* 以千万级整数从小到大排序为例* 一个比较简单的例子，没有建立内存缓冲区*/</span>    
<span class="ot">#ifndef EXTERN_SORT_H    </span>
<span class="ot">#define EXTERN_SORT_H    </span>

<span class="ot">#include &lt;cassert&gt;</span>

<span class="kw">class</span> ExternSort
{    
<span class="kw">public</span>:    
    <span class="dt">void</span> sort()
    {
        time_t start = time(NULL);
        <span class="co">//将文件内容分块在内存中排序，并分别写入临时文件</span>
        <span class="dt">int</span> file_count = memory_sort();
        <span class="co">//归并临时文件内容到输出文件</span>
        merge_sort(file_count);
        time_t end = time(NULL);printf(<span class="st">&quot;total time:%f/n&quot;</span>, (end - start) * <span class="fl">1000.0</span>/ CLOCKS_PER_SEC);
    }
  
    <span class="co">//input_file:输入文件名</span>
    <span class="co">//out_file:输出文件名</span>
    <span class="co">//count: 每次在内存中排序的整数个数</span>
    ExternSort(<span class="dt">const</span> <span class="dt">char</span> *input_file, <span class="dt">const</span> <span class="dt">char</span> * out_file, <span class="dt">int</span> count)
    {
        m_count = count;
        m_in_file = <span class="kw">new</span> <span class="dt">char</span>[strlen(input_file) + <span class="dv">1</span>];
        strcpy(m_in_file, input_file);
        m_out_file = <span class="kw">new</span> <span class="dt">char</span>[strlen(out_file) + <span class="dv">1</span>];
        strcpy(m_out_file, out_file);
    }

    <span class="kw">virtual</span> ~ExternSort()
    {
        <span class="kw">delete</span> [] m_in_file;
        <span class="kw">delete</span> [] m_out_file;
    }

<span class="kw">private</span>:
    <span class="dt">int</span> m_count;
    <span class="co">//数组长度char *m_in_file;</span>
    <span class="co">//输入文件的路径</span>
    <span class="dt">char</span> *m_out_file;
    <span class="co">//输出文件的路径</span>

<span class="kw">protected</span>:
    <span class="dt">int</span> read_data(FILE* f, <span class="dt">int</span> a[], <span class="dt">int</span> n)
    {
        <span class="dt">int</span> i = <span class="dv">0</span>;
        <span class="kw">while</span>(i &lt; n &amp;&amp; (fscanf(f, <span class="st">&quot;%d&quot;</span>, &amp;a[i]) != EOF))
            i++;
        printf(<span class="st">&quot;read:%d integer/n&quot;</span>, i);
        <span class="kw">return</span> i;
    }

    <span class="dt">void</span> write_data(FILE* f, <span class="dt">int</span> a[], <span class="dt">int</span> n)
    {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i)
            fprintf(f, <span class="st">&quot;%d &quot;</span>, a[i]);
    }

    <span class="dt">char</span>* temp_filename(<span class="dt">int</span> index)
    {
        <span class="dt">char</span> *tempfile = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">100</span>];
        sprintf(tempfile, <span class="st">&quot;temp%d.txt&quot;</span>, index);
        <span class="kw">return</span> tempfile;
    }

    <span class="dt">static</span> <span class="dt">int</span> cmp_int(<span class="dt">const</span> <span class="dt">void</span> *a, <span class="dt">const</span> <span class="dt">void</span> *b)
    {
        <span class="kw">return</span> *(<span class="dt">int</span>*)a - *(<span class="dt">int</span>*)b;
    }

    <span class="dt">int</span> memory_sort()
    {
        FILE* fin = fopen(m_in_file, <span class="st">&quot;rt&quot;</span>);
        <span class="dt">int</span> n = <span class="dv">0</span>, file_count = <span class="dv">0</span>;<span class="dt">int</span> *array = <span class="kw">new</span> <span class="dt">int</span>[m_count];
      
        <span class="co">//每读入m_count个整数就在内存中做一次排序，并写入临时文件</span>
        <span class="kw">while</span>(( n = read_data(fin, array, m_count)) &gt; <span class="dv">0</span>)
        {
            qsort(array, n, <span class="kw">sizeof</span>(<span class="dt">int</span>), cmp_int);   <span class="co">//这里，调用了库函数阿，在第四节的c实现里，不再调qsort。</span>
            <span class="dt">char</span> *fileName = temp_filename(file_count++);
            FILE *tempFile = fopen(fileName, <span class="st">&quot;w&quot;</span>);
            free(fileName);
            write_data(tempFile, array, n);
            fclose(tempFile);
        }
        <span class="kw">delete</span> [] array;
        fclose(fin);
        <span class="kw">return</span> file_count;
    }

    <span class="dt">void</span> merge_sort(<span class="dt">int</span> file_count)
    {
        <span class="kw">if</span>(file_count &lt;= <span class="dv">0</span>)
            <span class="kw">return</span>;
        <span class="co">//归并临时文件FILE *fout = fopen(m_out_file, &quot;wt&quot;);</span>
        FILE* *farray = <span class="kw">new</span> FILE*[file_count];
        <span class="dt">int</span> i;
        <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; file_count; ++i)
        {
            <span class="dt">char</span>* fileName = temp_filename(i);
            farray[i] = fopen(fileName, <span class="st">&quot;rt&quot;</span>);
            free(fileName);
        }
        <span class="dt">int</span> *data = <span class="kw">new</span> <span class="dt">int</span>[file_count];
        <span class="co">//存储每个文件当前的一个数字</span>
        <span class="dt">bool</span> *hasNext = <span class="kw">new</span> <span class="dt">bool</span>[file_count];
        <span class="co">//标记文件是否读完</span>
        memset(data, <span class="dv">0</span>, <span class="kw">sizeof</span>(<span class="dt">int</span>) * file_count);
        memset(hasNext, <span class="dv">1</span>, <span class="kw">sizeof</span>(<span class="dt">bool</span>) * file_count);
        <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; file_count; ++i)
        {
            <span class="kw">if</span>(fscanf(farray[i], <span class="st">&quot;%d&quot;</span>, &amp;data[i]) == EOF)
                <span class="co">//读每个文件的第一个数到data数组</span>
                hasNext[i] = <span class="kw">false</span>;
        }

        <span class="kw">while</span>(<span class="kw">true</span>)
        {
            <span class="co">//求data中可用的最小的数字，并记录对应文件的索引</span>
            <span class="dt">int</span> min = data[<span class="dv">0</span>];
            <span class="dt">int</span> j = <span class="dv">0</span>;
            <span class="kw">while</span> (j &lt; file_count &amp;&amp; !hasNext[j])
                j++;
            <span class="kw">if</span> (j &gt;= file_count)
                <span class="co">//没有可取的数字，终止归并</span>
                <span class="kw">break</span>;
            <span class="kw">for</span>(i = j + <span class="dv">1</span>; i &lt; file_count; ++i)
            {
                <span class="kw">if</span>(hasNext[i] &amp;&amp; min &gt; data[i])
                {
                    min = data[i];
                    j = i;
                }
            }
            <span class="kw">if</span>(fscanf(farray[j], <span class="st">&quot;%d&quot;</span>, &amp;data[j]) == EOF)
                <span class="co">//读取文件的下一个元素</span>
                hasNext[j] = <span class="kw">false</span>;
            fprintf(fout, <span class="st">&quot;%d &quot;</span>, min);
        }

        <span class="kw">delete</span> [] hasNext;
        <span class="kw">delete</span> [] data;
        <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; file_count; ++i)
        {
            fclose(farray[i]);
        }
        <span class="kw">delete</span> [] farray;
        fclose(fout);
    }
};
<span class="ot">#endif</span>

<span class="co">//测试主函数文件</span>
<span class="co">/** 大文件排序* 数据不能一次性全部装入内存* 排序文件里有多个整数，整数之间用空格隔开*/</span>

<span class="dt">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> count = <span class="dv">10000000</span>;
<span class="co">// 文件里数据的行数const unsigned int number_to_sort = 1000000;</span>
<span class="co">//在内存中一次排序的数量</span>
<span class="dt">const</span> <span class="dt">char</span> *unsort_file = <span class="st">&quot;unsort_data.txt&quot;</span>;
<span class="co">//原始未排序的文件名</span>
<span class="dt">const</span> <span class="dt">char</span> *sort_file = <span class="st">&quot;sort_data.txt&quot;</span>;
<span class="co">//已排序的文件名</span>
<span class="dt">void</span> init_data(<span class="dt">unsigned</span> <span class="dt">int</span> num);

<span class="co">//随机生成数据文件</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* *argv)
{
    srand(time(NULL));
    init_data(count);
    ExternSort extSort(unsort_file, sort_file, number_to_sort);
    extSort.sort();
    system(<span class="st">&quot;pause&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">void</span> init_data(<span class="dt">unsigned</span> <span class="dt">int</span> num)
{
    FILE* f = fopen(unsort_file, <span class="st">&quot;wt&quot;</span>);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; num; ++i)
        fprintf(f, <span class="st">&quot;%d &quot;</span>, rand());
    fclose(f);
}</code></pre>
<p>程序测试：读者可以继续用小文件小数据量进一步测试。</p>
<figure>
<img src="../images/10/10.4.jpg" />
</figure>
<h2 id="第三节磁盘文件排序的编程实现">第三节、磁盘文件排序的编程实现</h2>
<p>ok，接下来，我们来编程实现上述磁盘文件排序的问题，本程序由两部分构成：</p>
<p><strong>1、内存排序</strong></p>
<p>由于要求的可用内存为1MB，那么每次可以在内存中对250K的数据进行排序，然后将有序的数写入硬盘。 那么10M的数据需要循环40次，最终产生40个有序的文件。</p>
<p><strong>2、归并排序</strong></p>
<p>将每个文件最开始的数读入(由于有序，所以为该文件最小数)，存放在一个大小为40的first_data数组中； 选择first_data数组中最小的数min_data，及其对应的文件索引index； 将first_data数组中最小的数写入文件result，然后更新数组first_data(根据index读取该文件下一个数代替min_data)；</p>
<p>判断是否所有数据都读取完毕，否则返回2。</p>
<p>所以，本程序按顺序分两步，第一步、Memory Sort，第二步、Merge Sort。程序的流程图，如下图所示（感谢F的绘制）。</p>
<p><img src="../images/10/10.5.jpg" /> <img src="../images/10/10.6.jpg" /></p>
<p>然后，编写的完整代码如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@ yansha</span>
<span class="co">//July、updated，2011.05.28。</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> sort_num = <span class="dv">10000000</span>;
<span class="dt">int</span> memory_size = <span class="dv">250000</span>;

<span class="co">//每次只对250k个小数据量进行排序</span>
<span class="dt">int</span> read_data(FILE *fp, <span class="dt">int</span> *space)
{
    <span class="dt">int</span> index = <span class="dv">0</span>;
    <span class="kw">while</span> (index &lt; memory_size &amp;&amp; fscanf(fp, <span class="st">&quot;%d &quot;</span>, &amp;space[index]) != EOF)
        index++;
    <span class="kw">return</span> index;
}

<span class="dt">void</span> write_data(FILE *fp, <span class="dt">int</span> *space, <span class="dt">int</span> num)
{
    <span class="dt">int</span> index = <span class="dv">0</span>;
    <span class="kw">while</span> (index &lt; num)
    {
        fprintf(fp, <span class="st">&quot;%d &quot;</span>, space[index]);
        index++;
    }
}

<span class="co">// check the file pointer whether valid or not.</span>
<span class="dt">void</span> check_fp(FILE *fp)
{
    <span class="kw">if</span> (fp == NULL)
    {
        cout &lt;&lt; <span class="st">&quot;The file pointer is invalid!&quot;</span> &lt;&lt; endl;
        exit(<span class="dv">1</span>);
    }
}

<span class="dt">int</span> compare(<span class="dt">const</span> <span class="dt">void</span> *first_num, <span class="dt">const</span> <span class="dt">void</span> *second_num)
{
    <span class="kw">return</span> *(<span class="dt">int</span> *)first_num - *(<span class="dt">int</span> *)second_num;
}  

string new_file_name(<span class="dt">int</span> n)
{
    <span class="dt">char</span> file_name[<span class="dv">20</span>];
    sprintf(file_name, <span class="st">&quot;data%d.txt&quot;</span>, n);
    <span class="kw">return</span> file_name;
}

<span class="dt">int</span> memory_sort()
{
    <span class="co">// open the target file.</span>
    FILE *fp_in_file = fopen(<span class="st">&quot;data.txt&quot;</span>, <span class="st">&quot;r&quot;</span>);
    check_fp(fp_in_file);
    <span class="dt">int</span> counter = <span class="dv">0</span>;
    <span class="kw">while</span> (<span class="kw">true</span>)
    {
        <span class="co">// allocate space to store data read from file.</span>
        <span class="dt">int</span> *space = <span class="kw">new</span> <span class="dt">int</span>[memory_size];
        <span class="dt">int</span> num = read_data(fp_in_file, space);
        <span class="co">// the memory sort have finished if not numbers any more.</span>
        <span class="kw">if</span> (num == <span class="dv">0</span>)
            <span class="kw">break</span>;

        <span class="co">// quick sort.</span>
        qsort(space, num, <span class="kw">sizeof</span>(<span class="dt">int</span>), compare);
        <span class="co">// create a new auxiliary file name.</span>
        string file_name = new_file_name(++counter);
        FILE *fp_aux_file = fopen(file_name.c_str(), <span class="st">&quot;w&quot;</span>);
        check_fp(fp_aux_file);

        <span class="co">// write the orderly numbers into auxiliary file.</span>
        write_data(fp_aux_file, space, num);
        fclose(fp_aux_file);
        <span class="kw">delete</span> []space;
    }
    fclose(fp_in_file);

    <span class="co">// return the number of auxiliary files.</span>
    <span class="kw">return</span> counter;
    }

    <span class="dt">void</span> merge_sort(<span class="dt">int</span> file_num)
    {
    <span class="kw">if</span> (file_num &lt;= <span class="dv">0</span>)
        <span class="kw">return</span>;
    <span class="co">// create a new file to store result.</span>
    FILE *fp_out_file = fopen(<span class="st">&quot;result.txt&quot;</span>, <span class="st">&quot;w&quot;</span>);
    check_fp(fp_out_file);

    <span class="co">// allocate a array to store the file pointer.</span>
    FILE **fp_array = <span class="kw">new</span> FILE *[file_num];
    <span class="dt">int</span> i;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; file_num; i++)
    {
        string file_name = new_file_name(i + <span class="dv">1</span>);
        fp_array[i] = fopen(file_name.c_str(), <span class="st">&quot;r&quot;</span>);
        check_fp(fp_array[i]);
    }

    <span class="dt">int</span> *first_data = <span class="kw">new</span> <span class="dt">int</span>[file_num];
    <span class="co">//new出个大小为0.1亿/250k数组，由指针first_data指示数组首地址</span>
    <span class="dt">bool</span> *finish = <span class="kw">new</span> <span class="dt">bool</span>[file_num];
    memset(finish, <span class="kw">false</span>, <span class="kw">sizeof</span>(<span class="dt">bool</span>) * file_num);

    <span class="co">// read the first number of every auxiliary file.</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; file_num; i++)
        fscanf(fp_array[i], <span class="st">&quot;%d &quot;</span>, &amp;first_data[i]);
    <span class="kw">while</span> (<span class="kw">true</span>)
    {
        <span class="dt">int</span> index = <span class="dv">0</span>;
        <span class="kw">while</span> (index &lt; file_num &amp;&amp; finish[index])
            index++;

        <span class="co">// the finish condition of the merge sort.</span>
        <span class="kw">if</span> (index &gt;= file_num)
            <span class="kw">break</span>;
        <span class="co">//主要的修改在上面两行代码，就是merge sort结束条件。</span>
        <span class="co">//要保证所有文件都读完，必须使得finish[0]...finish[40]都为真</span>
        <span class="co">//July、yansha，555，2011.05.29。</span>

        <span class="dt">int</span> min_data = first_data[index];
        <span class="co">// choose the relative minimum in the array of first_data.</span>
        <span class="kw">for</span> (i = index + <span class="dv">1</span>; i &lt; file_num; i++)
        {
            <span class="kw">if</span> (min_data &gt; first_data[i] &amp;&amp; !finish[i])
                <span class="co">//一旦发现比min_data更小的数据first_data[i]</span>
            {
                min_data = first_data[i];
                <span class="co">//则置min_data&lt;-first_data[i]index = i;</span>
                <span class="co">//把下标i 赋给index。</span>
            }
        }

        <span class="co">// write the orderly result to file.</span>
        fprintf(fp_out_file, <span class="st">&quot;%d &quot;</span>, min_data);
        <span class="kw">if</span> (fscanf(fp_array[index], <span class="st">&quot;%d &quot;</span>, &amp;first_data[index]) == EOF)
            finish[index] = <span class="kw">true</span>;
    }

    fclose(fp_out_file);
    <span class="kw">delete</span> []finish;
    <span class="kw">delete</span> []first_data;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; file_num; i++)
        fclose(fp_array[i]);
    <span class="kw">delete</span> [] fp_array;
}

<span class="dt">int</span> main()
{
    clock_t start_memory_sort = clock();
    <span class="dt">int</span> aux_file_num = memory_sort();
    clock_t end_memory_sort = clock();
    cout &lt;&lt; <span class="st">&quot;The time needs in memory sort: &quot;</span> &lt;&lt; end_memory_sort - start_memory_sort &lt;&lt; endl;
    clock_t start_merge_sort = clock();
    merge_sort(aux_file_num);
    clock_t end_merge_sort = clock();
    cout &lt;&lt; <span class="st">&quot;The time needs in merge sort: &quot;</span> &lt;&lt; end_merge_sort - start_merge_sort &lt;&lt; endl;
    system(<span class="st">&quot;pause&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>其中，生成数据文件data.txt的代码在第一节已经给出。</p>
<p>程序测试：</p>
<ol type="1">
<li>咱们对1000W数据进行测试，打开半天没看到数据，</li>
</ol>
<figure>
<img src="../images/10/10.7.jpg" />
</figure>
<ol start="2" type="1">
<li>编译运行上述程序后，data文件先被分成40个小文件data[1....40]，然后程序再对这40个小文件进行归并排序，排序结果最终生成在result文件中，自此result文件中便是由data文件的数据经排序后得到的数据。</li>
</ol>
<figure>
<img src="../images/10/10.8.jpg" />
</figure>
<ol start="3" type="1">
<li>且，我们能看到，data[i]，i=1...40的每个文件都是有序的，如下图：</li>
</ol>
<figure>
<img src="../images/10/10.9.jpg" />
</figure>
<ol start="4" type="1">
<li>最终的运行结果，如下，单位统一为ms：</li>
</ol>
<figure>
<img src="../images/10/10.10.jpg" />
</figure>
<p>由上观之，我们发现，第一节的位图方案的程序效率是最快的，约为14s，而采用上述的多路归并算法的程序运行时间约为25s。时间主要浪费在读写磁盘IO上，且程序中用的库函数qsort也耗费了不少时间。所以，总的来说，采取位图方案是最佳方案。</p>
<p>小数据量测试：</p>
<p>我们下面针对小数据量的文件再测试一次，针对20个小数据，每趟对4个数据进行排序，即5路归并，程序的排序结果如下图所示。</p>
<figure>
<img src="../images/10/10.11.jpg" />
</figure>
<p>运行时间：</p>
<p>0ms，可以忽略不计了，毕竟是对20个数的小数据量进行排序：</p>
<figure>
<img src="../images/10/10.12.jpg" />
</figure>
<p>沙海拾贝：</p>
<p>我们不在乎是否能把一个软件产品或一本书最终完成，我们更在乎的是，在完成这个产品或创作这本书的过程中，读者学到了什么，能学到什么?所以，不要一味的马上就想得到一道题目的正确答案，请跟着我们一起逐步走向山巅。</p>
<h2 id="第四节多路归并算法的c实现">第四节、多路归并算法的c实现</h2>
<p>本多路归并算法的c实现原理与上述c++实现一致，不同的地方体现在一些细节处理上，且对临时文件的排序，不再用系统提供的快排，即上面的qsort库函数，是采用的三数中值的快速排序（个数小于3用插入排序）的。而我们知道，纯正的归并排序其实就是比较排序，在归并过程中总是不断的比较，为了从两个数中挑小的归并到最终的序列中。ok，此程序的详情请看：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@ 555  </span>
<span class="co">//July、2011.05.29。  </span>
<span class="ot">#include &lt;assert.h&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="dt">void</span> swap_int(<span class="dt">int</span>* a,<span class="dt">int</span>* b)
{
    <span class="dt">int</span> c;
    c = *a;
    *a = *b;
    *b = c;
}

<span class="co">//插入排序  </span>
<span class="dt">void</span> InsertionSort(<span class="dt">int</span> A[],<span class="dt">int</span> N)
{
    <span class="dt">int</span> j,p;
    <span class="dt">int</span> tmp;
    <span class="kw">for</span>(p = <span class="dv">1</span>; p &lt; N; p++)
    {
        tmp = A[p];
        <span class="kw">for</span>(j = p;j &gt; <span class="dv">0</span> &amp;&amp; A[j - <span class="dv">1</span>] &gt;tmp;j--)
        {
            A[j] = A[j - <span class="dv">1</span>];
        }

        A[j] = tmp;
    }
}

<span class="co">//三数取中分割法  </span>
<span class="dt">int</span> Median3(<span class="dt">int</span> A[],<span class="dt">int</span> Left,<span class="dt">int</span> Right)
{
    <span class="dt">int</span> Center = (Left + Right) / <span class="dv">2</span>;
    <span class="kw">if</span> (A[Left] &gt; A[Center])
        swap_int(&amp;A[Left],&amp;A[Center]);
    <span class="kw">if</span> (A[Left] &gt; A[Right])
        swap_int(&amp;A[Left],&amp;A[Right]);
    <span class="kw">if</span> (A[Center] &gt; A[Right])
        swap_int(&amp;A[Center],&amp;A[Right]);
    swap_int(&amp;A[Center],&amp;A[Right - <span class="dv">1</span>]);
    <span class="kw">return</span> A[Right - <span class="dv">1</span>];
}

<span class="co">//快速排序  </span>
<span class="dt">void</span> QuickSort(<span class="dt">int</span> A[],<span class="dt">int</span> Left,<span class="dt">int</span> Right)
{
    <span class="dt">int</span> i,j;
    <span class="dt">int</span> Pivot;
    <span class="dt">const</span> <span class="dt">int</span> Cutoff = <span class="dv">3</span>;
    <span class="kw">if</span> (Left + Cutoff &lt;= Right)
    {
        Pivot = Median3(A,Left,Right);
        i = Left;
        j = Right - <span class="dv">1</span>;
        <span class="kw">while</span> (<span class="dv">1</span>)
        {
            <span class="kw">while</span>(A[++i] &lt; Pivot){;}
            <span class="kw">while</span>(A[--j] &gt; Pivot){;}
            <span class="kw">if</span> (i &lt; j)
                swap_int(&amp;A[i],&amp;A[j]);
            <span class="kw">else</span>
                <span class="kw">break</span>;
        }
        swap_int(&amp;A[i],&amp;A[Right - <span class="dv">1</span>]);

        QuickSort(A,Left,i - <span class="dv">1</span>);
        QuickSort(A,i + <span class="dv">1</span>,Right);
    }
    <span class="kw">else</span>
    {
        InsertionSort(A+Left,Right - Left + <span class="dv">1</span>);
    }
}

<span class="co">//const int  KNUM  = 40;</span>
<span class="co">//分块数</span>
<span class="dt">const</span> <span class="dt">int</span>  NUMBER = <span class="dv">10000000</span>;
<span class="co">//输入文件最大读取的整数的个数</span>
<span class="co">//为了便于测试，我决定改成小文件小数据量进行测试。</span>
<span class="dt">const</span> <span class="dt">int</span>  KNUM  = <span class="dv">4</span>;
<span class="co">//分块数const int  NUMBER = 100;</span>
<span class="co">//输入文件最大读取的整数的个数</span>
<span class="dt">const</span> <span class="dt">char</span> *in_file = <span class="st">&quot;infile.txt&quot;</span>;
<span class="dt">const</span> <span class="dt">char</span> *out_file = <span class="st">&quot;outfile.txt&quot;</span>;
<span class="co">//#define OUTPUT_OUT_FILE_DATA</span>
<span class="co">//数据量大的时候,没必要把所有的数全部打印出来，所以可以把上面这句注释掉。</span>
<span class="dt">void</span>  gen_infile(<span class="dt">int</span> n)
{
    <span class="dt">int</span> i;
    FILE *f = fopen(in_file, <span class="st">&quot;wt&quot;</span>);
    <span class="kw">for</span>(i = <span class="dv">0</span>;i &lt; n; i++)
        fprintf(f,<span class="st">&quot;%d &quot;</span>,rand());
    fclose(f);
}

<span class="dt">int</span>  read_data(FILE *f,<span class="dt">int</span> a[],<span class="dt">int</span> n)
{
    <span class="dt">int</span> i = <span class="dv">0</span>;
    <span class="kw">while</span> ((i &lt; n) &amp;&amp; (fscanf(f,<span class="st">&quot;%d&quot;</span>,&amp;a[i]) != EOF))
        i++;
    printf(<span class="st">&quot;read: %d integer/n&quot;</span>,i);
    <span class="kw">return</span> i;
}

<span class="dt">void</span>  write_data(FILE *f,<span class="dt">int</span> a[],<span class="dt">int</span> n)  
{
    <span class="dt">int</span> i;<span class="kw">for</span>(i = <span class="dv">0</span>; i&lt; n;i++)
        fprintf(f,<span class="st">&quot;%d &quot;</span>,a[i]);
}

<span class="dt">char</span>* temp_filename(<span class="dt">int</span> index)
{
    <span class="dt">char</span> *tempfile = (<span class="dt">char</span>*) malloc(<span class="dv">64</span>*<span class="kw">sizeof</span>(<span class="dt">char</span>));
    assert(tempfile);
    sprintf(tempfile, <span class="st">&quot;temp%d.txt&quot;</span>, index);
    <span class="kw">return</span> tempfile;
}

<span class="co">//K路串行读取</span>
<span class="dt">void</span> k_num_read(<span class="dt">void</span>)
{
    <span class="dt">char</span>* filename;
    <span class="dt">int</span> i,cnt,*array;
    FILE* fin;
    FILE* tmpfile;
    <span class="co">//计算knum,每路应读取的整数个数int n = NUMBER/KNUM;</span>
    <span class="kw">if</span> (n * KNUM &lt; NUMBER)n++;

    <span class="co">//建立存储分块读取的数据的数组</span>
    array = (<span class="dt">int</span>*)malloc(n * <span class="kw">sizeof</span>(<span class="dt">int</span>));assert(array);
    <span class="co">//打开输入文件</span>
    fin = fopen(in_file,<span class="st">&quot;rt&quot;</span>);
    i = <span class="dv">0</span>;

    <span class="co">//分块循环读取数据,并写入硬盘上的临时文件</span>
    <span class="kw">while</span> ( (cnt = read_data(fin,array,n))&gt;<span class="dv">0</span>)
    {
        <span class="co">//对每次读取的数据,先进行快速排序,然后写入硬盘上的临时文件</span>
        QuickSort(array,<span class="dv">0</span>,cnt - <span class="dv">1</span>);
        filename = temp_filename(i++);
        tmpfile = fopen(filename,<span class="st">&quot;w&quot;</span>);
        free(filename);
        write_data(tmpfile,array,cnt);
        fclose(tmpfile);
    }
    assert(i == KNUM);
    <span class="co">//没有生成K路文件时进行诊断</span>
    <span class="co">//关闭输入文件句柄和临时存储数组</span>
    fclose(fin);
    free(array);
}

<span class="co">//k路合并(败者树)</span>
<span class="dt">void</span> k_num_merge(<span class="dt">void</span>)
{
    FILE *fout;
    FILE **farray;
    <span class="dt">char</span> *filename;
    <span class="dt">int</span>  *data;
    <span class="dt">char</span> *hasNext;
    <span class="dt">int</span> i,j,m,min;
    <span class="ot">#ifdef OUTPUT_OUT_FILE_DATAint id;</span>
    <span class="ot">#endif</span>
    <span class="co">//打开输出文件</span>
    fout = fopen(out_file,<span class="st">&quot;wt&quot;</span>);
    <span class="co">//打开各路临时分块文件</span>
    farray = (FILE**)malloc(KNUM*<span class="kw">sizeof</span>(FILE*));
    assert(farray);
    <span class="kw">for</span>(i = <span class="dv">0</span>; i&lt; KNUM;i++)
    {
        filename = temp_filename(i);
        farray[i] = fopen(filename,<span class="st">&quot;rt&quot;</span>);
        free(filename);
    }

    <span class="co">//建立KNUM个元素的data,hasNext数组,存储K路文件的临时数组和读取结束状态</span>
    data = (<span class="dt">int</span>*)malloc(KNUM*<span class="kw">sizeof</span>(<span class="dt">int</span>));
    assert(data);
    hasNext = (<span class="dt">char</span>*)malloc(<span class="kw">sizeof</span>(<span class="dt">char</span>)*KNUM);
    assert(hasNext);
    memset(data, <span class="dv">0</span>, <span class="kw">sizeof</span>(<span class="dt">int</span>) * KNUM);
    memset(hasNext, <span class="dv">1</span>, <span class="kw">sizeof</span>(<span class="dt">char</span>) * KNUM);

    <span class="co">//读K路文件先读取第一组数据,并对读取结束的各路文件设置不可再读状态</span>
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; KNUM; i++)
    {
        <span class="kw">if</span>(fscanf(farray[i], <span class="st">&quot;%d&quot;</span>, &amp;data[i]) == EOF)
        {
            hasNext[i] = <span class="dv">0</span>;
        }
    }
  
    <span class="co">//读取各路文件,利用败者树从小到大输出到输出文件</span>
    <span class="ot">#ifdef OUTPUT_OUT_FILE_DATAid = 0;</span>
    <span class="ot">#endif</span>
  
    j  = <span class="dv">0</span>;F_LOOP:
    <span class="kw">if</span> (j &lt; KNUM)
        <span class="co">//以下这段代码嵌套过深，日后应尽量避免此类问题。</span>
    {
        <span class="kw">while</span>(<span class="dv">1</span>==<span class="dv">1</span>)
        {
            min = data[j];
            m = j;
            <span class="kw">for</span>(i = j<span class="dv">+1</span>; i &lt; KNUM; i++)
            {
                <span class="kw">if</span>(hasNext[i] == <span class="dv">1</span>  &amp;&amp; min &gt; data[i])
                {
                    min = data[i];m = i;
                }
            }

            <span class="kw">if</span>(fscanf(farray[m], <span class="st">&quot;%d&quot;</span>, &amp;data[m]) == EOF)
            {
                hasNext[m] = <span class="dv">0</span>;
            }
            fprintf(fout, <span class="st">&quot;%d &quot;</span>, min);
<span class="ot">#ifdef OUTPUT_OUT_FILE_DATAprintf(&quot;fout :%d  %d/n&quot;,++id,min);  </span>
<span class="ot">#endif  </span>
            <span class="kw">if</span> (m == j &amp;&amp; hasNext[m] == <span class="dv">0</span>)
            {  
                <span class="kw">for</span> (i = j<span class="dv">+1</span>; i &lt; KNUM; i++)
                {  
                    <span class="kw">if</span> (hasNext[m] != hasNext[i])
                    {
                        m = i;
                        <span class="co">//第i个文件未读完,从第i个继续往下读</span>
                        <span class="kw">break</span>;
                    }
                }
                <span class="kw">if</span> (m != j)
                {
                    j = m;
                    <span class="kw">goto</span> F_LOOP;
                }
                <span class="kw">break</span>;
            }  
        }  
    }  
  
    <span class="co">//关闭分配的数据和数组</span>
    free(hasNext);
    free(data);
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; KNUM; ++i)
    {
        fclose(farray[i]);
    }
    free(farray);
    fclose(fout);
}

<span class="dt">int</span> main()
{
    time_t start = time(NULL),end,start_read,end_read,start_merge,end_merge;
    gen_infile(NUMBER);
    end = time(NULL);
    printf(<span class="st">&quot;gen_infile data time:%f/n&quot;</span>, (end - start) * <span class="fl">1000.0</span>/ CLOCKS_PER_SEC);
    start_read = time(NULL);k_num_read();
    end_read = time(NULL);
    printf(<span class="st">&quot;k_num_read time:%f/n&quot;</span>, (end_read - start_read) * <span class="fl">1000.0</span>/ CLOCKS_PER_SEC);
    start_merge = time(NULL);
    k_num_merge();
    end_merge = time(NULL);
    printf(<span class="st">&quot;k_num_merge time:%f/n&quot;</span>, (end_merge - start_merge) * <span class="fl">1000.0</span>/ CLOCKS_PER_SEC);
    end = time(NULL);
    printf(<span class="st">&quot;total time:%f/n&quot;</span>, (end - start) * <span class="fl">1000.0</span>/ CLOCKS_PER_SEC);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>程序测试：</p>
<p>在此，我们先测试下对10000000个数据的文件进行40趟排序，然后再对100个数据的文件进行4趟排序（读者可进一步测试）。如弄几组小点的数据,输出ID和数据到屏幕，再看程序运行效果。</p>
<ol type="1">
<li>10个数, 4组</li>
<li>40个数, 5组</li>
<li>55个数, 6组</li>
<li>100个数, 7组</li>
</ol>
<p><img src="../images/10/10.13.jpg" /> <img src="../images/10/10.14.jpg" /></p>
<p>（备注：1、以上所有各节的程序运行环境为windows xp + vc6.0 + e5200 cpu 2.5g主频，2、感谢5为本文程序所作的大量测试工作）</p>
<h4 id="全文总结">全文总结：</h4>
<p>1、关于本章中位图和多路归并两种方案的时间复杂度及空间复杂度的比较，如下：</p>
<pre><code>          时间复杂度       空间复杂度</code></pre>
<p>位图 O(N) 0.625M 多位归并 O(Nlogn) 1M</p>
<p>（多路归并，时间复杂度为O（k<em>n/k</em>logn/k ），严格来说，还要加上读写磁盘的时间，而此算法绝大部分时间也是浪费在这上面）</p>
<p>2、bit-map</p>
<p>适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下 基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码 扩展：bloom filter可以看做是对bit-map的扩展</p>
<p>问题实例：</p>
<p>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。 8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。</p>
<p>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p>
<p>将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。</p>
<p>3、[外排序适用范围]大数据的排序，去重基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树扩展。问题实例：1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。</p>
<p>4、海量数据处理</p>
<p>有关海量数据处理的方法或面试题可参考此文，十道海量数据处理面试题与十个方法大总结。日后，会逐步实现这十个处理海量数据的方法。同时，送给各位一句话，解决问题的关键在于熟悉一个算法，而不是某一个问题。熟悉了一个算法，便通了一片题目。</p>
<p>有一读者朋友针对本文写了一篇文章为，海量数据多路归并排序的c++实现（归并时利用了败者树），地址为：http://www.cnblogs.com/harryshayne/archive/2011/07/02/2096196.html 。谢谢，欢迎参考。</p>
<h1 id="第十一章最长公共子序列lcs问题">第十一章：最长公共子序列（LCS）问题</h1>
<h2 id="第一节问题描述">第一节、问题描述</h2>
<p>什么是最长公共子序列呢?好比一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则S 称为已知序列的最长公共子序列。</p>
<p>举个例子，如：有两条随机序列，如 1 3 4 5 5 ，and 2 4 5 5 7 6，则它们的最长公共子序列便是：4 5 5。</p>
<p>注意最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence, LCS）的区别：子串（Substring）是串的一个连续的部分，子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串acdfg同akdfc的最长公共子串为df，而他们的最长公共子序列是adf。LCS可以使用动态规划法解决。下文具体描述。</p>
<h2 id="第二节lcs问题的解决思路">第二节、LCS问题的解决思路</h2>
<ul>
<li>穷举法<br /> 解最长公共子序列问题时最容易想到的算法是穷举搜索法，即对X的每一个子序列，检查它是否也是Y的子序列，从而确定它是否为X和Y的公共子序列，并且在检查过程中选出最长的公共子序列。X和Y的所有子序列都检查过后即可求出X和Y的最长公共子序列。X的一个子序列相应于下标序列{1, 2, …, m}的一个子序列，因此，X共有2m个不同子序列（Y亦如此，如为2<sup>n），从而穷举搜索法需要指数时间（2</sup>m * 2^n）。<br /></li>
<li>动态规划算法</li>
</ul>
<p>事实上，最长公共子序列问题也有最优子结构性质。</p>
<p>记：<br /> Xi=﹤x1，⋯，xi﹥即X序列的前i个字符 (1≤i≤m)（前缀）</p>
<p>Yj=﹤y1，⋯，yj﹥即Y序列的前j个字符 (1≤j≤n)（前缀）</p>
<p>假定Z=﹤z1，⋯，zk﹥∈LCS(X , Y) 。</p>
<ul>
<li><p>若<strong>xm=yn</strong>（最后一个字符相同），则不难用反证法证明：该字符必是X与Y的任一最长公共子序列Z（设长度为k）的最后一个字符，即有zk = xm = yn 且显然有Zk-1∈LCS(Xm-1 , Yn-1)即Z的前缀<strong>Zk-1是Xm-1与Yn-1的最长公共子序列。</strong>此时，问题化归成求Xm-1与Yn-1的LCS（LCS(X , Y)的长度等于LCS(Xm-1 , Yn-1)的长度加1）。</p></li>
<li><p>若<strong>xm≠yn</strong>，则亦不难用反证法证明：要么Z∈LCS(Xm-1, Y)，要么Z∈LCS(X , Yn-1)。由于zk≠xm与zk≠yn其中至少有一个必成立，若zk≠xm则有Z∈LCS(Xm-1 , Y)，类似的，若zk≠yn 则有Z∈LCS(X , Yn-1)。此时，问题化归成求Xm-1与Y的LCS及X与Yn-1的LCS。LCS(X , Y)的长度为：max{LCS(Xm-1 , Y)的长度, LCS(X , Yn-1)的长度}。</p></li>
</ul>
<p>由于上述当<strong>xm≠yn</strong>的情况中，求LCS(Xm-1 , Y)的长度与LCS(X , Yn-1)的长度，这两个问题不是相互独立的：两者都需要求LCS(Xm-1，Yn-1)的长度。另外两个序列的LCS中包含了两个序列的前缀的LCS，故问题具有最优子结构性质考虑用动态规划法。</p>
<p>也就是说，解决这个LCS问题，你要求三个方面的东西：1、LCS（Xm-1，Yn-1）+1；2、LCS（Xm-1，Y），LCS（X，Yn-1）；3、max{LCS（Xm-1，Y），LCS（X，Yn-1）}。</p>
<p>行文至此，其实对这个LCS的动态规划解法已叙述殆尽，不过，为了成书的某种必要性，下面，我试着再多加详细阐述这个问题。</p>
<h2 id="第三节动态规划算法解lcs问题">第三节、动态规划算法解LCS问题</h2>
<h3 id="最长公共子序列的结构">最长公共子序列的结构</h3>
<p>最长公共子序列的结构有如下表示：</p>
<p>设序列X=&lt; x1, x2, …, xm &gt;和Y=&lt; y1, y2, …, yn &gt;的一个最长公共子序列Z=&lt; z1, z2, …, zk &gt;，则：</p>
<ol type="1">
<li>若xm=yn，则zk=xm=yn且Zk-1是Xm-1和Yn-1的最长公共子序列；<br /></li>
<li>若xm≠yn且zk≠xm ，则Z是Xm-1和Y的最长公共子序列；<br /></li>
<li>若xm≠yn且zk≠yn ，则Z是X和Yn-1的最长公共子序列。<br />其中Xm-1 = &lt; x1, x2, …, xm-1 &gt;，Yn-1 = &lt; y1, y2, …, yn-1 &gt;，Zk-1 = &lt; z1, z2, …, zk-1 &gt;。</li>
</ol>
<h3 id="子问题的递归结构">子问题的递归结构</h3>
<p>由最长公共子序列问题的最优子结构性质可知，要找出X=&lt; x1, x2, …, xm &gt;和Y=&lt; y1, y2, …, yn &gt;的最长公共子序列，可按以下方式递归地进行：当xm=yn时，找出Xm-1和Yn-1的最长公共子序列，然后在其尾部加上xm(=yn)即可得X和Y的一个最长公共子序列。当xm≠yn时，必须解两个子问题，即找出Xm-1和Y的一个最长公共子序列及X和Yn-1的一个最长公共子序列。这两个公共子序列中较长者即为X和Y的一个最长公共子序列。</p>
<p>由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。例如，在计算X和Y的最长公共子序列时，可能要计算出X和Yn-1及Xm-1和Y的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算Xm-1和Yn-1的最长公共子序列。</p>
<p>与矩阵连乘积最优计算次序问题类似，我们来建立子问题的最优值的递归关系。用c[i,j]记录序列Xi和Yj的最长公共子序列的长度。其中Xi=&lt; x1, x2, …, xi &gt;，Yj=&lt; y1, y2, …, yj &gt;。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列，故c[i,j]=0。其他情况下，由定理可建立递归关系如下：</p>
<figure>
<img src="../images/11/11.1.jpg" />
</figure>
<h3 id="计算最优值">计算最优值</h3>
<p>直接利用上节节末的递归式，我们将很容易就能写出一个计算c[i,j]的递归算法，但其计算时间是随输入长度指数增长的。由于在所考虑的子问题空间中，总共只有θ(m*n)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。</p>
<p>计算最长公共子序列长度的动态规划算法LCS_LENGTH(X,Y)以序列X=&lt; x1, x2, …, xm &gt;和Y=&lt; y1, y2, …, yn &gt;作为输入。输出两个数组c[0..m ,0..n]和b[1..m ,1..n]。其中c[i,j]存储Xi与Yj的最长公共子序列的长度，b[i,j]记录指示c[i,j]的值是由哪一个子问题的解达到的，这在构造最长公共子序列时要用到。最后，X和Y的最长公共子序列的长度记录于c[m,n]中。</p>
<pre><code>Procedure LCS_LENGTH(X,Y);  
begin  
  m:=length[X];  
  n:=length[Y];  
  for i:=1 to m do c[i,0]:=0;  
  for j:=1 to n do c[0,j]:=0;  
  for i:=1 to m do  
    for j:=1 to n do  
      if x[i]=y[j] then  
        begin  
          c[i,j]:=c[i-1,j-1]+1;  
          b[i,j]:=&quot;↖&quot;;  
        end  
      else if c[i-1,j]≥c[i,j-1] then  
        begin  
          c[i,j]:=c[i-1,j];  
          b[i,j]:=&quot;↑&quot;;  
        end  
      else  
        begin  
          c[i,j]:=c[i,j-1];  
          b[i,j]:=&quot;←&quot;  
        end;  
  return(c,b);  
end;   </code></pre>
<p>由算法LCS_LENGTH计算得到的数组b可用于快速构造序列X=&lt; x1, x2, …, xm &gt;和Y=&lt; y1, y2, …, yn &gt;的最长公共子序列。首先从b[m,n]开始，沿着其中的箭头所指的方向在数组b中搜索。</p>
<ul>
<li><p>当b[i,j]中遇到&quot;↖&quot;时（<em>意味着xi=yi是LCS的一个元素</em>），表示Xi与Yj的最长公共子序列是由Xi-1与Yj-1的最长公共子序列在尾部加上xi得到的子序列；</p></li>
<li><p>当b[i,j]中遇到&quot;↑&quot;时，表示Xi与Yj的最长公共子序列和Xi-1与Yj的最长公共子序列相同；</p></li>
<li><p>当b[i,j]中遇到&quot;←&quot;时，表示Xi与Yj的最长公共子序列和Xi与Yj-1的最长公共子序列相同。</p></li>
</ul>
<p>这种方法是按照反序来找LCS的每一个元素的。由于每个数组单元的计算耗费Ο(1)时间，算法LCS_LENGTH耗时Ο(mn)。</p>
<h3 id="构造最长公共子序列">构造最长公共子序列</h3>
<p>下面的算法LCS(b,X,i,j)实现根据b的内容打印出Xi与Yj的最长公共子序列。通过算法的调用LCS(b,X,length[X],length[Y])，便可打印出序列X和Y的最长公共子序列。</p>
<pre><code>Procedure LCS(b,X,i,j);  
begin  
  if i=0 or j=0 then return;  
  if b[i,j]=&quot;↖&quot; then  
    begin  
      LCS(b,X,i-1,j-1);  
      print(x[i]); {打印x[i]}  
    end  
  else if b[i,j]=&quot;↑&quot; then LCS(b,X,i-1,j)   
                      else LCS(b,X,i,j-1);  
end;   </code></pre>
<p>在算法LCS中，每一次的递归调用使i或j减1，因此算法的计算时间为O(m+n)。</p>
<p>例如，设所给的两个序列为X=&lt; A，B，C，B，D，A，B &gt;和Y=&lt; B，D，C，A，B，A &gt;。由算法LCS_LENGTH和LCS计算出的结果如下图所示：</p>
<figure>
<img src="../images/11/11.2.jpg" />
</figure>
<ul>
<li>我来说明下此图（参考算法导论）*。在序列X={A，B，C，B，D，A，B}和 Y={B，D，C，A，B，A}上，由LCS_LENGTH计算出的表c和b。第i行和第j列中的方块包含了c[i，j]的值以及指向b[i，j]的箭头。在c[7,6]的项4，表的右下角为X和Y的一个LCS &lt; B，C，B，A &gt;的长度。对于i，j&gt;0，项c[i，j]仅依赖于是否有xi=yi，及项c[i-1，j]和c[i，j-1]的值，这几个项都在c[i，j]之前计算。为了重构一个LCS的元素，从右下角开始跟踪b[i，j]的箭头即可，这条路径标示为阴影，这条路径上的每一个“↖”对应于一个使xi=yi为一个LCS的成员的项（高亮标示）。<br /> 所以根据上述图所示的结果，程序将最终输出：“B C B A”。</li>
</ul>
<h3 id="算法的改进">算法的改进</h3>
<p>对于一个具体问题，按照一般的算法设计策略设计出的算法，往往在算法的时间和空间需求上还可以改进。这种改进，通常是利用具体问题的一些特殊性。</p>
<p>例如，在算法LCS_LENGTH和LCS中，可进一步将数组b省去。事实上，数组元素c[i,j]的值仅由c[i-1,j-1]，c[i-1,j]和c[i,j-1]三个值之一确定，而数组元素b[i,j]也只是用来指示c[i,j]究竟由哪个值确定。因此，在算法LCS中，我们可以不借助于数组b而借助于数组c本身临时判断c[i,j]的值是由c[i-1,j-1]，c[i-1,j]和c[i,j-1]中哪一个数值元素所确定，代价是Ο(1)时间。既然b对于算法LCS不是必要的，那么算法LCS_LENGTH便不必保存它。这一来，可节省θ(mn)的空间，而LCS_LENGTH和LCS所需要的时间分别仍然是Ο(mn)和Ο(m+n)。不过，由于数组c仍需要Ο(mn)的空间，因此这里所作的改进，只是在空间复杂性的常数因子上的改进。</p>
<p>另外，如果只需要计算最长公共子序列的长度，则算法的空间需求还可大大减少。事实上，在计算c[i,j]时，只用到数组c的第i行和第i-1行。因此，只要用2行的数组空间就可以计算出最长公共子序列的长度。更进一步的分析还可将空间需求减至min(m, n)。</p>
<h2 id="第四节编码实现lcs问题">第四节、编码实现LCS问题</h2>
<p>动态规划的一个计算最长公共子序列的方法如下，以两个序列 X、Y 为例子：</p>
<p>设有二维数组 f[i][j] 表示 X 的 i 位和 Y 的 j 位之前的最长公共子序列的长度，则有：</p>
<p>f[1][1] = same(1,1)<br /> f[i][j] = max{f[i − 1][j − 1] +same(i,j), f[i − 1][j] ,f[i][j − 1]}</p>
<p>其中，same(a,b)当 X 的第 a 位与 Y 的第 b 位完全相同时为“1”，否则为“0”。</p>
<p>此时，f[i][j]中最大的数便是 X 和 Y 的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。</p>
<p>该算法的空间、时间复杂度均为O(n2)，经过优化后，空间复杂度可为O(n)，时间复杂度为O(nlogn)。</p>
<p>以下是此算法的java代码：</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import java.util.Random;</span>  
   
<span class="kw">public</span> <span class="kw">class</span> LCS{  
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args){  
   
        <span class="co">//设置字符串长度  </span>
        <span class="dt">int</span> substringLength1 = <span class="dv">20</span>;  
        <span class="dt">int</span> substringLength2 = <span class="dv">20</span>;  <span class="co">//具体大小可自行设置  </span>
   
        <span class="co">// 随机生成字符串  </span>
        String x = <span class="fu">GetRandomStrings</span>(substringLength1);  
        String y = <span class="fu">GetRandomStrings</span>(substringLength2);  
   
        Long startTime = System.<span class="fu">nanoTime</span>();  
        <span class="co">// 构造二维数组记录子问题x[i]和y[i]的LCS的长度  </span>
        <span class="dt">int</span>[][] opt = <span class="kw">new</span> <span class="dt">int</span>[substringLength1 + <span class="dv">1</span>][substringLength2 + <span class="dv">1</span>];  
   
        <span class="co">// 动态规划计算所有子问题  </span>
        <span class="kw">for</span> (<span class="dt">int</span> i = substringLength1 - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i--){  
            <span class="kw">for</span> (<span class="dt">int</span> j = substringLength2 - <span class="dv">1</span>; j &gt;= <span class="dv">0</span>; j--){  
                <span class="kw">if</span> (x.<span class="fu">charAt</span>(i) == y.<span class="fu">charAt</span>(j))  
                    opt[i][j] = opt[i + <span class="dv">1</span>][j + <span class="dv">1</span>] + <span class="dv">1</span>;                                 <span class="co">//参考上文我给的公式。  </span>
                <span class="kw">else</span>  
                    opt[i][j] = Math.<span class="fu">max</span>(opt[i + <span class="dv">1</span>][j], opt[i][j + <span class="dv">1</span>]);        <span class="co">//参考上文我给的公式。  </span>
            }  
        }  
   
        -------------------------------------------------------------------------------------  
   
        理解上段，参考上文我给的公式：  
   
        根据上述结论，可得到以下公式，  
   
        如果我们记字符串Xi和Yj的LCS的长度为c[i,j]，我们可以递归地求c[i,j]：  
   
                  /      <span class="dv">0</span>                               <span class="kw">if</span> i&lt;<span class="dv">0</span> or j&lt;<span class="dv">0</span>  
        c[i,j]=          c[i<span class="dv">-1</span>,j<span class="dv">-1</span>]+<span class="dv">1</span>                    <span class="kw">if</span> i,j&gt;=<span class="dv">0</span> and xi=xj  
                 /       <span class="fu">max</span>(c[i,j<span class="dv">-1</span>],c[i<span class="dv">-1</span>,j]           <span class="kw">if</span> i,j&gt;=<span class="dv">0</span> and xi≠xj  
   
        -------------------------------------------------------------------------------------  
   
        System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;substring1:&quot;</span>+x);  
        System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;substring2:&quot;</span>+y);  
        System.<span class="fu">out</span>.<span class="fu">print</span>(<span class="st">&quot;LCS:&quot;</span>);  
   
        <span class="dt">int</span> i = <span class="dv">0</span>, j = <span class="dv">0</span>;  
        <span class="kw">while</span> (i &lt; substringLength1 &amp;&amp; j &lt; substringLength2){  
            <span class="kw">if</span> (x.<span class="fu">charAt</span>(i) == y.<span class="fu">charAt</span>(j)){  
                System.<span class="fu">out</span>.<span class="fu">print</span>(x.<span class="fu">charAt</span>(i));  
                i++;  
                j++;  
            } <span class="kw">else</span> <span class="kw">if</span> (opt[i + <span class="dv">1</span>][j] &gt;= opt[i][j + <span class="dv">1</span>])  
                i++;  
            <span class="kw">else</span>  
                j++;  
        }  
        Long endTime = System.<span class="fu">nanoTime</span>();  
        System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot; Totle time is &quot;</span> + (endTime - startTime) + <span class="st">&quot; ns&quot;</span>);  
    }  
   
    <span class="co">//取得定长随机字符串  </span>
    <span class="kw">public</span> <span class="dt">static</span> String <span class="fu">GetRandomStrings</span>(<span class="dt">int</span> length){  
        StringBuffer buffer = <span class="kw">new</span> StringBuffer(<span class="st">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>);  
        StringBuffer sb = <span class="kw">new</span> StringBuffer();  
        Random r = <span class="kw">new</span> Random();  
        <span class="dt">int</span> range = buffer.<span class="fu">length</span>();  
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; length; i++){  
            sb.<span class="fu">append</span>(buffer.<span class="fu">charAt</span>(r.<span class="fu">nextInt</span>(range)));  
        }  
        <span class="kw">return</span> sb.<span class="fu">toString</span>();  
    }  
}  </code></pre>
<h2 id="第五节改进的算法">第五节、改进的算法</h2>
<p>下面咱们来了解一种不同于动态规划法的一种新的求解最长公共子序列问题的方法,该算法主要是把求解公共字符串问题转化为求解矩阵L(p,m)的问题，在利用定理求解矩阵的元素过程中</p>
<p>（1）while(i &lt; k),L(k,i)=null,<br /> （2）while(L(k,i)=k),L(k,i+1)=L(k,i+2)=…L(k,m)=k；</p>
<p>求出每列元素，一直到发现第p+1 行都为null 时退出循环，得出矩阵L(k,m)后，B[L(1,m-p+1)]B[L(2,m-p+2)]…B[L(p,m)]即为A 和B 的LCS，其中p 为LCS 的长度。</p>
<h3 id="主要定义及定理">主要定义及定理</h3>
<ul>
<li><p>定义 1 子序列(Subsequence)：给定字符串A=A[1]A[2]…A[m]，(A[i]是A 的第i 个字母，A[i]∈字符集Σ，l&lt;= i&lt;m = A ， A 表示字符串A 的长度)，字符串B 是A 的子序列是指B=A[ 1 i ]A[ 2 i ]…A[ k i ],其中1 i &lt; 2 i &lt;…&lt; k i 且k&lt;=m.</p></li>
<li><p>定义2 公共子序列(Common Subsequence)：给定字符串A、B、C，C 称为A 和B 的公共子序列是指C 既是A 的子序列，又是B 的子序列。</p></li>
<li><p>定义3 最长公共子序列(Longest Common Subsequence 简称LCS)：给定字符串A、B、C，C 称为A 和B 的最长公共子序列是指C 是A 和B 的公共子序列，且对于A 和B 的任意公共子序列D，都有D &lt;= C 。给定字符串A 和B，A =m，B =n，不妨设m&lt;=n，LCS 问题就是要求出A 和B 的LCS。</p></li>
<li><p>定义4 给定字符串A=A[1]A[2]…A[m]和字符串B=B[1]B[2]…[n]，A( 1:i)表示A 的连续子序列A[1]A[2]…A[i]，同样B(1:j)表示B 的连续子序列B[1]B[2]…[j]。Li(k)表示所有与字符串A(1:i) 有长度为k 的LCS 的字符串B(l:j) 中j 的最小值。用公式表示就是Li(k)=Minj(LCS(A(1:i)，B(l:j))=k) [3]。</p></li>
</ul>
<p>定理1 ∀ i∈[1，m]，有Li(l) &lt; Li(2) &lt; Li(3) &lt; … &lt; Li(m) .<br />定理2 ∀i∈[l，m-1]，∀k∈[l，m]，有i 1 L + (k)&lt;= i L (k).<br />定理3 ∀ i∈[l，m-1]， ∀ k∈[l，m-l]，有i L (k)&lt; i 1 L + (k+l).<br />以上三个定理都不考虑Li(k)无定义的情况。<br />定理4[3] i 1 L + (k)如果存在，那么它的取值必为: i 1 L + (k)=Min(j, i L (k))。这里j 是满足以下条件的最小整数:A[i+l]=B[j]且j&gt; i L (k-1)。</p>
<figure>
<img src="../images/11/11.3.jpg" />
</figure>
<p>矩阵中元素L(k，i)=Li(k)，这里(1 &lt; i &lt;= m，1 &lt; k &lt;= m)，null 表示L(k,i)不存在。当i &lt; k 时，显然L(k，i)不存在。</p>
<p>设p=Maxk(L(k ， m) ≠ null) ， 可以证明L 矩阵中L(p,m) 所在的对角线,L(1,m-p+1),L(2,m-p+2)…L(p-1,m-1),L(p,m) 所对应的子序列B[L(1,m-p+1)]B[L(2,m-p+2)]…B[L(p,m)]即为A 和B 的LCS，p 为该LCS 的长度。这样，LCS 问题的求解就转化为对m m L × 矩阵的求解。</p>
<h3 id="算法思想">算法思想</h3>
<p>根据定理,第一步求出第一行元素,L(1,1),L(1,2),…L(1,m),第二步求第二行,一直到发现第p+1 行都为null 为止。在计算过程中遇到i &lt; k 时,L(k,i)=null, 及L(k,i)=k时,L(k,i+1)=L(k,i+2)=…L(k,m)=k。这样,计算每行的时间复杂度为O(n),则整个时间复杂度为O(pn)。在求L 矩阵的过程中不用存储整个矩阵,只需存储当前行和上一行即可。空间复杂度为O(m+n)。</p>
<p>下面给出一个例子来说明:给定字符串A 和B，A=acdabbc，B=cddbacaba，(m= A =7，n= B =9)。按照定理给出的递推公式，求出A 和B 的L 矩阵如图2，其中的$表示NULL。</p>
<figure>
<img src="../images/11/11.4.jpg" />
</figure>
<p>则A 和B 的LCS 为B[1]B[2]B[4]B[6]=cdbc, LCS 的长度为4。</p>
<h3 id="算法伪代码">算法伪代码</h3>
<p>算法 L(A,B,L)<br />输入 长度分别为m,n 的字符串A,B<br />输出 A,B 的最长公共子序列LCS</p>
<pre><code>L(A,B,L){//字符串A，B，所求矩阵L  
  for(k=1;k&lt;=m;k++){ //m 为A 的长度  
    for(i=1;i&lt;=m;i++){  
      if(i&lt;k) L[k][i]=N;//i&lt;k 时,L(k,i)=null，N 代表无穷大  
      if(L[k][i]==k)//L(k,i)=k 时,L(k,i+1)=L(k,i+2)=…L(k,m)=k  
      for(l=i+1;l&lt;=m;l++)  
       { L[k][l]=k;  
         Break;}  
      for(j=1;j&lt;=n;j++){//定理4 的实现  
       if(A[i+1]==B[j]&amp;&amp;j&gt;L[k-1][i]){  
        L[k][i+1]=(j&lt;L[k][i]?j:L[k][i]);  
        break;  
      }  
      if(L[k][i+1]==0)  
        L[k][i]=N;  
     }  
     if(L[k][m]==N)  
      {p=k-1;break;}  
  }  
  p=k-1;  
}  </code></pre>
<h2 id="结语">结语</h2>
<p>本节主要描述区别于动态规划法的一种新的求解最长公共子序列问题的方法，在不影响精确度的前提下，提高序列匹配的速度，根据定理i 1 L + (k)=Min(j, i L (k))得出矩阵，在求解矩阵的过程中对最耗时的L(p,m)进行条件约束优化。我们在Intel(R) Core(TM)2 Quad 双核处理器、1G 内存，软件环境：windows xp 下试验结果证明，本文算法与其他经典的比对算法相比,不但能够取得准确的结果,而且速度有了较大的提高（本节参考了刘佳梅女士的论文）。</p>
<h1 id="第十二第十五章中钱概率ip访问次数回文等问题初稿">第十二~第十五章：中钱概率，IP访问次数，回文等问题（初稿）</h1>
<p>作者：上善若水.qinyu，BigPotato，luuillu，well，July。编程艺术室出品。</p>
<h2 id="前言">前言</h2>
<p>本文的全部稿件是由我们编程艺术室的部分成员：上善若水.qinyu，BigPotato，luuillu，well，July共同完成，共分4个部分，即4道题：</p>
<ul>
<li>第一部分、从一道题，漫谈数据结构、以及压缩、位图算法，由上善若水.qinyu完成，</li>
<li>第二部分、遍历n个元素取出等概率随机取出其中之一元素，由BigPotato完成，</li>
<li>第三部分、提取出某日访问百度次数最多的那个IP，由luuillu完成，</li>
<li>第四部分、回文判断，由well完成。全文由July统稿完成。</li>
</ul>
<p>由于本人在这周时间上实在是过于仓促，来不及过多整理，所以我尽量保持上述我的几位伙伴的原话原文，基本没做多少改动。因此，标明为初稿，以后会更加详尽细致的进行修补完善。</p>
<h2 id="第一部分从一道题漫谈数据结构以及压缩位图算法">第一部分、从一道题，漫谈数据结构、以及压缩、位图算法</h2>
<p>海量数据处理往往会很有趣，有趣在什么地方呢？</p>
<ul>
<li>空间，available的内存不够，需要反复交换内存</li>
<li>时间，速度太慢不行，毕竟那是海量数据</li>
<li>处理，数据是一次调用还是反复调用，因为针对时间和空间，通常来说，多次调用的话，势必会增加预处理以减少每次调用的时候的时间代价。</li>
</ul>
<h3 id="题目如下">题目如下</h3>
<p>7、腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</p>
<p><strong>分析</strong>：1个unsigned int占用4字节，40亿大约是4G个数，那么一共大约要用16G的内存空间，如果内存不够大，反复和硬盘交换数据的话，后果不堪设想。</p>
<p>那么怎么储存这么多的数据呢？还记得伴随数组么？还是那种思想，利用内存地址代替下标。</p>
<p>先举例，在内存中应该是1个byte=8bit，那么明显有</p>
<p>0 = 0000 0000</p>
<p>255 = 1111 1111</p>
<p>69 = 0100 0101</p>
<p>那么69可以表示0.2.6三个数存在，其余的7以下的数不存在，0表示0-7都不存在，255表示0-7都存在，这就是位图算法：通过全部置0，存在置1，这样一种模式来通过连续的地址存贮数据，和检验数据的方法。</p>
<p>那么1个 unsigned int代表多少个数呢？1个unsigned int 是一个2^32以内的数，那么也就是这样的1个数，可以表示32个数是否存在。同理申请一个unsigned int的数组a[n]则可以表示连续的 n*32的数。也就是a[0]表示0-31的数是否存在，a[1]表示32-63的数是否存在，依次类推。</p>
<p>这时候需要用多大的内存呢？</p>
<p>16G/32=512M</p>
<p>512M和16G之间的区别，却是是否一个32位寻址的CPU能否办得到的事儿了，众所周知，32位CPU最大寻址不超过4G，固然，你会说，现在都是64位的CPU之类的云云，但是，对于底层的设计者来说，寻址范围越小越好操控的事实是不争的。</p>
<p>问题到这里，其实基本上已经完事了，判断本身，在位图算法这里就是找到对应的内存位置是否为1就可以了。</p>
<p><strong>当数据超出可接受范围之后…</strong></p>
<p>当然，下面就要开始说一说，当数据超出了可以接受的范围之后的事情了。比如， 2^66范围的数据检索，也会是一个问题</p>
<p>4倍于64位CPU寻址范围，如果加上CPU本身的偏移寄存器占用的资源，可能应该是6-8个64位CPU的寻址范围，如果反复从内存到硬盘的读写，过程本身就是可怕的。</p>
<p>算法，更多的是用来解决瓶颈的，就想现在，根本不用考虑内存超出8M的问题，但是20年前，8086的年代，内存4M，或者内存8M，你怎么处理?固然做软件的不需要完全考虑摩尔定律，但是摩尔定律绝对是影响软件和算法编写者得想法的。</p>
<p>再比如，乌克兰俄罗斯的一批压缩高手，比如国内有名的R大，为什么压缩会出现？就是因为，要么存不下，要么传输时间过长。网络再好，64G的高清怎么的也得下遍历n个元素取出等概率载个一段时间吧。海量数据处理，永远是考虑超过了当前硬件条件的时候，该怎么办？！</p>
<p>那么我们可以发现一个更加有趣的问题，如果存不下，但是还要存，怎么办！</p>
<p>压缩！这里简单的说一嘴，无损压缩常见的为Huffman算法和LZW(Lenpel-Ziv &amp;Welch)压缩算法，前者研究不多，后者却经常使用。</p>
<p>因为上面提到了位图算法，我就用常见的位图类的数据举例：</p>
<p>以下引自我的摘抄出处忘记了，请作者见谅：</p>
<p>对原始数据ABCCAABCDDAACCDB进行LZW压缩</p>
<p>原始数据中，只包括4个字符(Character),A,B,C,D,四个字符可以用一个2bit的数表示，0-A,1-B,2-C,3-D,从最直观的角度看，原始字符串存在重复字符：ABCCAABCDDAACCDB，用4代表AB,5代表CC，上面的字符串可以替代表示为:45A4CDDAA5DB,这样是不是就比原数据短了一些呢！</p>
<p><strong>LZW算法的适用范围</strong></p>
<p>为了区别代表串的值(Code)和原来的单个的数据值(String)，需要使它们的数值域不重合，上面用0-3来代表A-D,那么AB就必须用大于3的数值来代替，再举另外一个例子，原来的数值范围可以用8bit来表示，那么就认为原始的数的范围是0～255，压缩程序生成的标号的范围就不能为0～255（如果是0-255，就重复了）。只能从256开始，但是这样一来就超过了8位的表示范围了，所以必须要扩展数据的位数，至少扩展一位，但是这样不是增加了1个字符占用的空间了么？但是却可以用一个字符代表几个字符，比如原来255是8bit,但是现在用256来表示254，255两个数，还是划得来的。从这个原理可以看出LZW算法的适用范围<u>是原始数据串最好是有大量的子串多次重复出现，重复的越多，压缩效果越好。反之则越差，可能真的不减反增了</u>。</p>
<p>伪代码如下</p>
<pre><code>  STRING = get input character
  WHILE there are still input characters DO
    CHARACTER = get input character
    IF STRING+CHARACTER is in the string table then
      STRING = STRING+character
    ELSE
      output the code for STRING
      add STRING+CHARACTER to the string table
      STRING = CHARACTER
    END of IF
  END of WHILE
  output the code for STRING </code></pre>
<p>看过上面的适用范围再联想本题，数据有多少种，根据同余模的原理，可以惊人的发现，其实真的非常适合压缩，但是压缩之后，尽管存下了，在查找的时候，势必又需要解码，那么又回到了我们当初学习算法时的那句经典话，算法本身，就是为了解决时间和空间的均衡问题，要么时间换空间，要么空间换时间。</p>
<p>更多的，请读者自行思考，因为，压缩本身只是想引起读者思考，已经是题外话了~本部分完--<strong>上善若水.qinyu</strong>。</p>
<h2 id="第二部分随机取出其中之一元素">第二部分、随机取出其中之一元素</h2>
<h3 id="问题描述">问题描述</h3>
<p>1．一个文件中含有n个元素，只能遍历一遍，要求等概率随机取出其中之一。</p>
<p>先讲一个例子，5个人抽5个签，只有一个签意味着“中签”，轮流抽签，那么这种情况，估计这5个人都不会有异议，都觉得这种方法是公平的，这确实也是公平的，“抓阄”的方法已经有很长的历史了，要是不公平的话老祖先们就不干了。</p>
<p>或许有人觉得先抓的人中签的概率会大一些，因为要是前面的人中了，后面的中签概率就是0了，也可能有人会觉得后面抓的人更有优势，因为前面拿去了不中的签，后面中签的概率就大，那么我们就计算一下吧。</p>
<h3 id="问题分析">问题分析</h3>
<p>第一个人中签的概率是1/5,</p>
<p>第二个人中签的情况只能在第一个人未中时才有可能，所以他中的概率是4/5 X 1/4 = 1/5（4/5表示第一个人未中，1/4表示在剩下的4个签里中签的概率），所以，第二个人最终的中签概率也是1/5，</p>
<p>同理，第三个人中签的概率为：第一个人未中的概率 * 第二个人未中的概率 * 第三个人中的概率，即为：4/5 * 3/4 * 1/3 = 1/5，</p>
<p>一样的可以求出第四和第五个人的概率都为1/5，也就是说先后顺序不影响公平性。</p>
<p>说这个问题是要说明这种前后有关联的事件的概率计算的方式，我们回到第1个问题。前几天我的一个同学电面百度是被问到这个问题，他想了想回答说，依次遍历，遇到每一个元素都生成一个随机数作为标记，如果当前生成的随机数大于为之前保留的元素生成的随机数就替换，这样操作直到文件结束。</p>
<p>但面试官问到：如果生成的随机数和之前保留的元素的随机数一样大的话，要不要替换呢？</p>
<p>你也许会想，一个double的范围可以是-1.79E+308 ~ +1.79E+308，要让两个随机生成的double相等的概率不是一般的微乎其微啊！但计算机世界里有条很让人伤心的“真理”：可能发生的事件，总会发生！</p>
<p>那我们遇到这种情况，是换还是不换？To be or not to be， that’s a question！</p>
<p>就好比，两个人百米赛跑，测出来的时间一样，如果只能有一个人得冠军的话，对于另一个人始终是不公平的，那么只能再跑一次，一决雌雄了！</p>
<h3 id="我的策略">我的策略</h3>
<p>下面，说一个个人认为比较满足要求的选取策略：</p>
<p>顺序遍历，当前遍历的元素为第L个元素，变量e表示之前选取了的某一个元素，此时生成一个随机数r，如果r%L == 0(当然0也可以是0~L-1中的任何一个，概率都是一样的), 我们将e的值替换为当前值，否则扫描下一个元素直到文件结束。</p>
<p>你要是给面试官说明了这样一个策略后，面试官百分之一千会问你这样做是等概率吗？那我们来证明一下。</p>
<h3 id="证明">证明</h3>
<p>在遍历到第1个元素的时候，即L为1，那么r%L必然为0，所以e为第一个元素，p=100%，</p>
<p>遍历到第2个元素时，L为2，r%L==0的概率为1/2, 这个时候，第1个元素不被替换的概率为1*(1-1/2)=1/2,</p>
<p>第1个元素被替换，也就是第2个元素被选中的概率为1/2,你可以看到，只有2时，这两个元素是等概率的机会被选中的。</p>
<p>继续，遍历到第3个元素的时候，r%L==0的概率为1/3，前面被选中的元素不被替换的概率为1/2*(1-1/3)=1/3,前面被选中的元素被替换的概率，即第3个元素被选中的概率为1/3。</p>
<p>归纳法证明，这样走到第L个元素时，这L个元素中任一被选中的概率都是1/L，那么走到L+1时，第L+1个元素选中的概率为1/(L+1), 之前选中的元素不被替换，即继续被选中的概率为1/L*(1-1/(L+1)) = 1/(L+1)。证毕。</p>
<p>也就是说，走到文件最后，每一个元素最终被选出的概率为1/n， n为文件中元素的总数。好歹我们是一个技术博客，看不到一丁点代码多少有点遗憾，给出一个选取策略的伪代码，如下：</p>
<p><strong>伪代码</strong></p>
<pre><code>  Element RandomPick(file):
  Int length = 1;
  While (length &lt;= file.size)
    If (rand() % length == 0)
      Picked = File[length];
    Length++;
  Return picked</code></pre>
<p>近日，看见我的一些同学在他们的面经里面常推荐结构之法算法之道这个博客，感谢东南大学计算机学院即将找工作的同学们对本博的关注，欢迎批评指正！--<strong>BigPotato</strong>。</p>
<h2 id="第三部分提取出某日访问百度次数最多的那个ip">第三部分、提取出某日访问百度次数最多的那个IP</h2>
<p>问题描述：海量日志数据，提取出某日访问百度次数最多的那个IP。</p>
<p>方法: 计数法</p>
<p>假设一天之内某个IP访问百度的次数不超过40亿次,则访问次数可以用unsigned int表示。用数组统计出每个IP地址出现的 次数, 即可得到访问次数最大的IP地址。</p>
<p>IP地址是32位的二进制数,所以共有N=2^32个不同的IP地址，创建一个大小为N的的数组count，即可统计出每个IP的访问次数,而sizeof(count) == 4G*4 = 16G,远远超过了32位计算机所支持的内存大小,因此不能直接创建这个数组.下面采用划分法解决这个问题。</p>
<p>假设允许使用的内存是512M, 512M/4=128M 即512M内存可以统计128M个不同的IP地址的访问次数。而N/128M = 4G/128M = 32 ,所以只要把IP地址划分成32个不同的区间,分别统计出每个区间中访问次数最大的IP,然后就可以计算出所有IP地址中访问次数最大的IP了.</p>
<p>因为2^5=32, 所以可以把IP地址的最高5位作为区间编号,剩下的27为作为区间内的值,建立32个临时文件,代表32个区间,把相同区间的IP地址保存到同一临时文件中.</p>
<p>例如:</p>
<p>IP1=0x1f4e2342</p>
<p>IP1的高5位是id1 = IP1 &gt;&gt; 27 = 0x11 = 3</p>
<p>IP1的其余27位是value1 = IP1 &amp; 0x07ffffff = 0x074e2342</p>
<p>所以把 value1 保存在tmp3文件中.</p>
<p>由id1和value1可以还原成IP1, 即 IP1 =(id1 &lt;&lt; 27) | value1</p>
<p>按照上面的方法可以得到32个临时文件,每个临时文件中的IP地址的取值范围属于[0-128M),因此可以统计出每个IP地址的访问次数.从而找到访问次数最大的IP地址</p>
<p>程序源码:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;fstream&gt;  </span>
<span class="ot">#include &lt;iostream&gt;  </span>
<span class="ot">#include &lt;ctime&gt;  </span>
  
<span class="kw">using</span> <span class="kw">namespace</span> std;  
<span class="ot">#define N 32           </span><span class="co">//临时文件数  </span>
  
<span class="ot">#define ID(x)  (x&gt;&gt;27)                 </span><span class="co">//x对应的文件编号  </span>
<span class="ot">#define VALUE(x) (x&amp;0x07ffffff)        </span><span class="co">//x在文件中保存的值  </span>
<span class="ot">#define MAKE_IP(x,y)  ((x&lt;&lt;27)|y)      </span><span class="co">//由文件编号和值得到IP地址.  </span>
  
<span class="ot">#define MEM_SIZE  128*1024*1024       </span><span class="co">//需分配内存的大小为 MEM_SIZE*sizeof(unsigned)     </span>
  
<span class="dt">char</span>* data_path=<span class="st">&quot;D:/test/ip.dat&quot;</span>;        <span class="co">//ip数据  </span>

<span class="co">//产生n个随机IP地址  </span>
<span class="dt">void</span> make_data(<span class="dt">const</span> <span class="dt">int</span>&amp; n)         
{
    ofstream out(data_path,ios::out|ios::binary);  
    srand((<span class="dt">unsigned</span>)(time(NULL)));  
    <span class="kw">if</span> (out)  
    {  
        <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;n; ++i)
        {  
            <span class="dt">unsigned</span> val=<span class="dt">unsigned</span>(rand());           
            val = (val&lt;&lt;<span class="dv">24</span>)|val;              <span class="co">//产生unsigned类型的随机数  </span>
 
            out.write((<span class="dt">char</span> *)&amp;val,<span class="kw">sizeof</span> (<span class="dt">unsigned</span>));  
        }  
    }  
}  
 
<span class="co">//找到访问次数最大的ip地址  </span>
<span class="dt">int</span> main()  
{  
    <span class="co">//make_data(100);     //   </span>
    make_data(<span class="dv">100000000</span>);       <span class="co">//产生测试用的IP数据  </span>
    fstream arr[N];  
     
    <span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;N; ++i)                 <span class="co">//创建N个临时文件  </span>
    {  
        <span class="dt">char</span> tmp_path[<span class="dv">128</span>];     <span class="co">//临时文件路径  </span>
        sprintf(tmp_path,<span class="st">&quot;D:/test/tmp%d.dat&quot;</span>,i);  
        arr[i].open(tmp_path, ios::trunc|ios::in|ios::out|ios::binary);  <span class="co">//打开第i个文件  </span>

        <span class="kw">if</span>( !arr[i])  
        {  
            cout&lt;&lt;<span class="st">&quot;open file&quot;</span>&lt;&lt;i&lt;&lt;<span class="st">&quot;error&quot;</span>&lt;&lt;endl;  
        }  
    }  
 
    ifstream infile(data_path,ios::in|ios::binary);   <span class="co">//读入测试用的IP数据  </span>
    <span class="dt">unsigned</span> data;  
 
    <span class="kw">while</span>(infile.read((<span class="dt">char</span>*)(&amp;data), <span class="kw">sizeof</span>(data)))  
    {  
        <span class="dt">unsigned</span> val=VALUE(data);  
        <span class="dt">int</span> key=ID(data);  
        arr[ID(data)].write((<span class="dt">char</span>*)(&amp;val), <span class="kw">sizeof</span>(val));           <span class="co">//保存到临时文件件中  </span>
    }  
 
    <span class="kw">for</span>(<span class="dt">unsigned</span> i=<span class="dv">0</span>; i&lt;N; ++i)  
    {  
        arr[i].seekg(<span class="dv">0</span>);  
    }  
    <span class="dt">unsigned</span> max_ip = <span class="dv">0</span>;    <span class="co">//出现次数最多的ip地址  </span>
    <span class="dt">unsigned</span> max_times = <span class="dv">0</span>;     <span class="co">//最大只出现的次数  </span>
 
    <span class="co">//分配512M内存,用于统计每个数出现的次数  </span>
    <span class="dt">unsigned</span> *count = <span class="kw">new</span> <span class="dt">unsigned</span>[MEM_SIZE];    
 
    <span class="kw">for</span> (<span class="dt">unsigned</span> i=<span class="dv">0</span>; i&lt;N; ++i)  
    {  
        memset(count, <span class="dv">0</span>, <span class="kw">sizeof</span>(<span class="dt">unsigned</span>)*MEM_SIZE);  
 
        <span class="co">//统计每个临时文件件中不同数字出现的次数  </span>
        <span class="dt">unsigned</span> data;  
        <span class="kw">while</span>(arr[i].read((<span class="dt">char</span>*)(&amp;data), <span class="kw">sizeof</span>(<span class="dt">unsigned</span>)))       
        {  
            ++count[data];  
        }  
         
        <span class="co">//找出出现次数最多的IP地址  </span>
        <span class="kw">for</span>(<span class="dt">unsigned</span> j=<span class="dv">0</span>; j&lt;MEM_SIZE; ++j)                             
        {  
            <span class="kw">if</span>(max_times&lt;count[j])             
            {  
                max_times = count[j];  
                max_ip = MAKE_IP(i,j);        <span class="co">// 恢复成原ip地址.  </span>
            }  
        }  
    }  
    <span class="kw">delete</span>[] count; 
    <span class="dt">unsigned</span> <span class="dt">char</span> *result=(<span class="dt">unsigned</span> <span class="dt">char</span> *)(&amp;max_ip);  
    printf(<span class="st">&quot;出现次数最多的IP为:%d.%d.%d.%d,共出现%d次&quot;</span>,   
           result[<span class="dv">0</span>], result[<span class="dv">1</span>], result[<span class="dv">2</span>], result[<span class="dv">3</span>], max_times);  
}</code></pre>
<p>执行结果：</p>
<figure>
<img src="../images/12.1.gif" />
</figure>
<p>--<strong>luuillu</strong>。</p>
<h2 id="第四部分回文判断">第四部分、回文判断</h2>
<p>（初稿，写的比较急，请审阅、增补、修改）</p>
<p>回文判断是一类典型的问题，尤其是与字符串结合后呈现出多姿多彩，在实际中使用也比较广泛，而且也是面试题中的常客，所以本文就结合几个典型的例子来体味下回文之趣。</p>
<p>回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗呢 ：）</p>
<h3 id="一回文判断">一、回文判断</h3>
<p>那么，我们的第一个问题就是：<strong>判断一个字串是否是回文</strong></p>
<p>通过对回文字串的考察，最直接的方法显然是将字符串逆转，存入另外一个字符串，然后比较原字符串和逆转后的字符串是否一样，一样就是回文，这个方法的时空复杂度都是O(n)。</p>
<p>我们还很容易想到只要从两头开始同时向中间扫描字串，如果直到相遇两端的字符都一样，那么这个字串就是一个回文。我们只需要维护头部和尾部两个扫描指针即可，代码如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/**  </span>
<span class="co"> *check weather s is a palindrome, n is the length of string s </span>
<span class="co"> *Copyright(C) fairywell 2011 </span>
<span class="co"> */</span>  
<span class="dt">bool</span> IsPalindrome(<span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">int</span> n)  
{  
    <span class="kw">if</span> (s == NULL || n &lt; <span class="dv">1</span>) <span class="kw">return</span> <span class="kw">false</span>; <span class="co">// invalid string  </span>
    <span class="dt">char</span> *front, *back;  
    front = s; back = s + n - <span class="dv">1</span>; <span class="co">// set front and back to the begin and endof the string  </span>
    <span class="kw">while</span> (front &lt; back) {  
        <span class="kw">if</span> (*front != *back) <span class="kw">return</span> <span class="kw">false</span>; <span class="co">// not a palindrome  </span>
        ++front; --back;  
    }  
    <span class="kw">return</span> <span class="kw">true</span>; <span class="co">// check over, it&#39;s a palindrome  </span>
}  </code></pre>
<p>这是一个直白且效率不错的实现，只需要附加 2 个额外的指针，在 O(n) 时间内我们可以判断出字符串是否是回文。</p>
<p>是否还有其他方法？呵呵，聪明的读者因该想到了不少变种吧，不过时空复杂度因为不会有显著提升了（为什么？），下面再介绍一种回文判断方法，先上代码：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/**  </span>
<span class="co"> *check weather s is a palindrome, n is the length of string s </span>
<span class="co"> *Copyright(C) fairywell 2011 </span>
<span class="co"> */</span>  
<span class="dt">bool</span> IsPalindrome2(<span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">int</span> n)  
{  
    <span class="kw">if</span> (s == NULL || n &lt; <span class="dv">1</span>) <span class="kw">return</span> <span class="kw">false</span>; <span class="co">// invalid string  </span>
    <span class="dt">char</span> *first, *second;  
    <span class="dt">int</span> m = ((n &gt;&gt; <span class="dv">1</span>) - <span class="dv">1</span>) &gt;= <span class="dv">0</span> ? (n &gt;&gt; <span class="dv">1</span>) - <span class="dv">1</span> : <span class="dv">0</span>; <span class="co">// m is themiddle point of s      </span>
    first = s + m; second = s + n - <span class="dv">1</span> - m;  
    <span class="kw">while</span> (first &gt;= s)  
        <span class="kw">if</span> (s[first--] != s[second++]) <span class="kw">return</span> <span class="kw">false</span>; <span class="co">// not equal, so it&#39;s not apalindrome  </span>
    <span class="kw">return</span> <span class="kw">true</span>; <span class="co">// check over, it&#39;s a palindrome  </span>
}  </code></pre>
<p>代码略有些小技巧，不过相信我们聪明的读者已经看清了意思，这里就是从中间开始、向两边扩展查看字符是否相等的一种方法，时空复杂度和上一个方法是一模一样的，既然一样，那么我们为什么还需要这种方法呢？首先，世界的美存在于它的多样性；其次，我们很快会看到，在某些回文问题里面，这个方法有着自己的独到之处，可以方便的解决一类问题。</p>
<p>那么除了直接用数组，我们还可以采用其他的数据结构来判断回文吗呢？请读者朋友稍作休息想想看。相信我们聪明的读者肯定想到了不少好方法吧，也一定想到了经典的单链表和栈这两种方法吧，这也是面试中常常出现的两种回文数据结构类型。</p>
<p>对于单链表结构，处理的思想不难想到：用两个指针从两端或者中间遍历并判断对应字符是否相等。所以这里的关键就是如何朝两个方向遍历。单链表是单向的，所以要向两个方向遍历不太容易。一个简单的方法是，用经典的快慢指针的方法，定位到链表的中间位置，将链表的后半逆置，然后用两个指针同时从链表头部和中间开始同时遍历并比较即可。</p>
<p>对于栈就简单些，只需要将字符串全部压入栈，然后依次将各字符出栈，这样得到的就是原字符串的逆置串，分别和原字符串各个字符比较，就可以判断了。</p>
<h3 id="二回文的应用">二、回文的应用</h3>
<p>我们已经了解了回文的判断方法，接下来可以来尝试回文的其他应用了。回文不是很简单的东西吗，还有其他应用？是的，比如：查找一个字符串中的最长回文字串</p>
<p>Hum，还是请读者朋友们先自己想想看看。嗯，有什么好方法了吗？枚举所有的子串，分别判断其是否为回文？这个思路是正确的，但却做了很多无用功，如果一个长的子串包含另一个短一些的子串，那么对子串的回文判断其实是不需要的。</p>
<p>那么如何高效的进行判断呢？既然对短的子串的判断和包含它的长的子串的判断重复了，我们何不复用下短的子串的判断呢（哈，算法里也跑出软件工程了），让短的子串的判断成为长的子串的判断的一个部分！想到怎么做了吗？Aha，没错，扩展法。从一个字符开始，向两边扩展，看看最多能到多长，使其保持为回文。这也就是为什么我们在上一节里面要提出 IsPalindrome2 的原因。</p>
<p>具体而言，我们可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度，即为所求。代码如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/**  </span>
<span class="co"> *find the longest palindrome in a string, n is the length of string s </span>
<span class="co"> *Copyright(C) fairywell 2011 </span>
<span class="co"> */</span>  
<span class="dt">int</span> LongestPalindrome(<span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">int</span> n)  
{
    <span class="dt">int</span> i, j, max;  
    <span class="kw">if</span> (s == <span class="dv">0</span> || n &lt; <span class="dv">1</span>) <span class="kw">return</span> <span class="dv">0</span>;  
    max = <span class="dv">0</span>;  
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i) { <span class="co">// i is the middle point of the palindrome  </span>
        <span class="kw">for</span> (j = <span class="dv">0</span>; (i-j &gt;= <span class="dv">0</span>) &amp;&amp; (i+j &lt; n); ++j) <span class="co">// if the lengthof the palindrome is odd  </span>
            <span class="kw">if</span> (s[i-j] != s[i+j]) <span class="kw">break</span>;  
        <span class="kw">if</span> (j*<span class="dv">2+1</span> &gt; max) max = j * <span class="dv">2</span> + <span class="dv">1</span>;  
        <span class="kw">for</span> (j = <span class="dv">0</span>; (i-j &gt;= <span class="dv">0</span>) &amp;&amp; (i+j<span class="dv">+1</span> &lt; n); ++j) <span class="co">// for theeven case  </span>
            <span class="kw">if</span> (s[i-j] != s[i+j<span class="dv">+1</span>]) <span class="kw">break</span>;  
        <span class="kw">if</span> (j*<span class="dv">2+2</span> &gt; max) max = j * <span class="dv">2</span> + <span class="dv">2</span>;  
    }  
    <span class="kw">return</span> max;  
}  </code></pre>
<p>代码稍微难懂一点的地方就是内层的两个 for 循环，它们分别对于以 i 为中心的，长度为奇数和偶数的两种情况，整个代码遍历中心位置 i 并以之扩展，找出最长的回文。</p>
<p>当然，还有更先进但也更复杂的方法，比如用 s 和逆置 s' 的组合 s$s' 来建立后缀树的方法也能找到最长回文，但构建的过程比较复杂，所以在实践中用的比较少，感兴趣的朋友可以参考相应资料。</p>
<p>回文的内容还有不少，但主要的部分通过上面的内容相信大家已经掌握，希望大家能抓住实质，在实践中灵活运用，回文的内容我就暂时介绍到这里了，谢谢大家--well。</p>
<h1 id="第十六第二十章全排列跳台阶奇偶排序第一个只出现一次等问题">第十六~第二十章：全排列，跳台阶，奇偶排序，第一个只出现一次等问题</h1>
<h2 id="第十六章全排列问题">第十六章、全排列问题</h2>
<p>53.字符串的排列。</p>
<p>题目：输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串</p>
<p>abc、acb、bac、bca、cab 和cba。</p>
<p>分析：此题最初整理于去年的微软面试100题中第53题，第二次整理于微软、Google等公司非常好的面试题及解答[第61-70题] 第67题。无独有偶，这个问题今年又出现于今年的2011.10.09百度笔试题中。ok，接下来，咱们先好好分析这个问题。</p>
<p><strong>解法一、递归实现</strong></p>
<p>从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理，从而得到所有元素的全排列。以对字符串abc进行全排列为例，我们可以这么做：以abc为例</p>
<p>固定a，求后面bc的排列：abc，acb，求好后，a和b交换，得到bac</p>
<p>固定b，求后面ac的排列：bac，bca，求好后，c放到第一位置，得到cba</p>
<p>固定c，求后面ba的排列：cba，cab。代码可如下编写所示：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;  
<span class="dt">void</span> CalcAllPermutation_R(T perm[], <span class="dt">int</span> first, <span class="dt">int</span> num)  
{  
    <span class="kw">if</span> (num &lt;= <span class="dv">1</span>) {  
        <span class="kw">return</span>;  
    }  
      
    <span class="kw">for</span> (<span class="dt">int</span> i = first; i &lt; first + num; ++i) {  
        swap(perm[i], perm[first]);  
        CalcAllPermutation_R(perm, first + <span class="dv">1</span>, num - <span class="dv">1</span>);  
        swap(perm[i], perm[first]);  
    }  
}</code></pre>
<p>或者如此编写，亦可：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Permutation(<span class="dt">char</span>* pStr, <span class="dt">char</span>* pBegin);  
  
<span class="dt">void</span> Permutation(<span class="dt">char</span>* pStr)  
{  
      Permutation(pStr, pStr);  
}  
  
<span class="dt">void</span> Permutation(<span class="dt">char</span>* pStr, <span class="dt">char</span>* pBegin)  
{  
    <span class="kw">if</span>(!pStr || !pBegin)  
        <span class="kw">return</span>;  
      
    <span class="kw">if</span>(*pBegin == &#39;\<span class="dv">0</span>&#39;)  
    {  
        printf(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, pStr);  
    }  
    <span class="kw">else</span>  
    {  
        <span class="kw">for</span>(<span class="dt">char</span>* pCh = pBegin; *pCh != &#39;\<span class="dv">0</span>&#39;; ++ pCh)  
        {  
            <span class="co">// swap pCh and pBegin  </span>
            <span class="dt">char</span> temp = *pCh;  
            *pCh = *pBegin;  
            *pBegin = temp;  
              
            Permutation(pStr, pBegin + <span class="dv">1</span>);    
            <span class="co">// restore pCh and pBegin  </span>
            temp = *pCh;  
            *pCh = *pBegin;  
            *pBegin = temp;  
        }  
    }  
} </code></pre>
<p><strong>解法二、字典序排列</strong></p>
<p>把升序的排列（当然，也可以实现为降序）作为当前排列开始，然后依次计算当前排列的下一个字典序排列。</p>
<p>对当前排列从后向前扫描，找到一对为升序的相邻元素，记为i和j（i &lt; j）。如果不存在这样一对为升序的相邻元素，则所有排列均已找到，算法结束；否则，重新对当前排列从后向前扫描，找到第一个大于i的元素k，交换i和k，然后对从j开始到结束的子序列反转，则此时得到的新排列就为下一个字典序排列。这种方式实现得到的所有排列是按字典序有序的，这也是C++ STL算法next_permutation的思想。算法实现如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;  
<span class="dt">void</span> CalcAllPermutation(T perm[], <span class="dt">int</span> num)  
{  
    <span class="kw">if</span> (num &lt; <span class="dv">1</span>)  
        <span class="kw">return</span>;  
          
    <span class="kw">while</span> (<span class="kw">true</span>) {  
        <span class="dt">int</span> i;  
        <span class="kw">for</span> (i = num - <span class="dv">2</span>; i &gt;= <span class="dv">0</span>; --i) {  
            <span class="kw">if</span> (perm[i] &lt; perm[i + <span class="dv">1</span>])  
                <span class="kw">break</span>;  
        }  
          
        <span class="kw">if</span> (i &lt; <span class="dv">0</span>)  
            <span class="kw">break</span>;  <span class="co">// 已经找到所有排列  </span>
      
        <span class="dt">int</span> k;  
        <span class="kw">for</span> (k = num - <span class="dv">1</span>; k &gt; i; --k) {  
            <span class="kw">if</span> (perm[k] &gt; perm[i])  
                <span class="kw">break</span>;  
        }  
          
        swap(perm[i], perm[k]);  
        reverse(perm + i + <span class="dv">1</span>, perm + num);  
         
    }  
} </code></pre>
<p>扩展：如果不是求字符的所有排列，而是求字符的所有组合，应该怎么办呢？当输入的字符串中含有相同的字符串时，相同的字符交换位置是不同的排列，但是同一个组合。举个例子，如果输入abc，它的组合有a、b、c、ab、ac、bc、abc。 ## 第十七章、跳台阶问题 ### 27.跳台阶问题 题目：一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。</p>
<p>求总共有多少总跳法，并分析算法的时间复杂度。</p>
<p>分析：在九月腾讯，创新工场，淘宝等公司最新面试十三题中第23题又出现了这个问题，题目描述如下：23、人人笔试1：一个人上台阶可以一次上1个，2个，或者3个，问这个人上n层的台阶，总共有几种走法？咱们先撇开这个人人笔试的问题（其实差别就在于人人笔试题中多了一次可以跳三级的情况而已），先来看这个第27题。</p>
<p>首先考虑最简单的情况。如果只有1级台阶，那显然只有一种跳法。如果有2级台阶，那就有两种跳的方法了：一种是分两次跳，每次跳1级；另外一种就是一次跳2级。</p>
<p>现在我们再来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶时的不同跳法的总数f(n)=f(n-1)+f(n-2)。</p>
<p>我们把上面的分析用一个公式总结如下：</p>
<pre><code>        /  1                             n = 1
f(n)=      2                             n = 2
        \  f(n-1) + f(n-2)               n &gt; 2</code></pre>
<p>原来上述问题就是我们平常所熟知的Fibonacci数列问题。可编写代码，如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">long</span> <span class="dt">long</span> Fibonacci_Solution1(<span class="dt">unsigned</span> <span class="dt">int</span> n)  
{  
    <span class="dt">int</span> result[<span class="dv">2</span>] = {<span class="dv">0</span>, <span class="dv">1</span>};  
    <span class="kw">if</span>(n &lt; <span class="dv">2</span>)  
        <span class="kw">return</span> result[n];  
      
    <span class="kw">return</span> Fibonacci_Solution1(n - <span class="dv">1</span>) + Fibonacci_Solution1(n - <span class="dv">2</span>);  
}</code></pre>
<p>那么，如果是人人笔试那道题呢?一个人上台阶可以一次上1个，2个，或者3个，岂不是可以轻而易举的写下如下公式：</p>
<pre><code>        / 1                                      n = 1
f(n)=     2                                      n = 2
          4                                      n = 3       //111, 12, 21, 3
        \ f(n-1)+(f-2)+f(n-3)                    n &gt; 3</code></pre>
<p>行文至此，你可能会认为问题已经解决了，但事实上没有：</p>
<p>用递归方法计算的时间复杂度是以n的指数的方式递增的，我们可以尝试用递推方法解决。具体如何操作，读者自行思考。</p>
<p>有一种方法，能在O(logn)的时间复杂度内求解Fibonacci数列问题，你能想到么?</p>
<p>同时，有朋友指出对于这个台阶问题只需求幂就可以了（求复数幂C++库里有），不用任何循环且复杂度为O（1），如下图所示，是否真如此?:</p>
<p><img src="../images/16~20/17.1.gif" /> ##第十八章、奇偶调序</p>
<p>54.调整数组顺序使奇数位于偶数前面。</p>
<p>题目：输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，</p>
<p>所有偶数位于数组的后半部分。要求时间复杂度为O(n)。</p>
<p>分析：</p>
<ol type="1">
<li><p>你当然可以从头扫描这个数组，每碰到一个偶数时，拿出这个数字，并把位于这个数字后面的所有数字往前挪动一位。挪完之后在数组的末尾有一个空位，这时把该偶数放入这个空位。由于碰到一个偶数，需要移动O(n)个数字，只是这种方法总的时间复杂度是O(n２)，不符合要求，pass</p></li>
<li><p>很简单，维护两个指针，一个指针指向数组的第一个数字，向后移动；一个个指针指向最后一个数字，向前移动。如果第一个指针指向的数字是偶数而第二个指针指向的数字是奇数，我们就交换这两个数字。</p></li>
</ol>
<p>思路有了，接下来，写代码实现：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//思路，很简答，俩指针，一首一尾  </span>
<span class="co">//如果第一个指针指向的数字是偶数而第二个指针指向的数字是奇数，  </span>
<span class="co">//我们就交换这两个数字  </span>
  
<span class="co">// 2 1 3 4 6 5 7   </span>
<span class="co">// 7 1 3 4 6 5 2  </span>
<span class="co">// 7 1 3 5 6 4 2  </span>
  
<span class="co">//如果限制空间复杂度为O（1），时间为O（N），且奇偶数之间相对顺序不变，就相当于正负数间顺序调整的那道题了。  </span>
  
<span class="co">//copyright@2010 zhedahht。  </span>
<span class="dt">void</span> Reorder(<span class="dt">int</span> *pData, <span class="dt">unsigned</span> <span class="dt">int</span> length, <span class="dt">bool</span> (*func)(<span class="dt">int</span>));  
<span class="dt">bool</span> isEven(<span class="dt">int</span> n);  
<span class="dt">void</span> ReorderOddEven(<span class="dt">int</span> *pData, <span class="dt">unsigned</span> <span class="dt">int</span> length)  
{  
    <span class="kw">if</span>(pData == NULL || length == <span class="dv">0</span>)  
        <span class="kw">return</span>;  
      
    Reorder(pData, length, isEven);  
}  
<span class="dt">void</span> Reorder(<span class="dt">int</span> *pData, <span class="dt">unsigned</span> <span class="dt">int</span> length, <span class="dt">bool</span> (*func)(<span class="dt">int</span>))  
{  
    <span class="kw">if</span>(pData == NULL || length == <span class="dv">0</span>)  
        <span class="kw">return</span>;  
    <span class="dt">int</span> *pBegin = pData;  
    <span class="dt">int</span> *pEnd = pData + length - <span class="dv">1</span>;  
    <span class="kw">while</span>(pBegin &lt; pEnd)  
    {  
        <span class="co">// if *pBegin does not satisfy func, move forward  </span>
        <span class="kw">if</span>(!func(*pBegin))   <span class="co">//偶数  </span>
        {  
            pBegin ++;  
            <span class="kw">continue</span>;  
        }  
          
        <span class="co">// if *pEnd does not satisfy func, move backward  </span>
        <span class="kw">if</span>(func(*pEnd))      <span class="co">//奇数  </span>
        {  
            pEnd --;  
            <span class="kw">continue</span>;  
        }  
        <span class="co">// if *pBegin satisfy func while *pEnd does not,  </span>
        <span class="co">// swap these integers  </span>
        <span class="dt">int</span> temp = *pBegin;  
        *pBegin = *pEnd;  
        *pEnd = temp;  
    }  
}  
<span class="dt">bool</span> isEven(<span class="dt">int</span> n)  
{  
    <span class="kw">return</span> (n &amp; <span class="dv">1</span>) == <span class="dv">0</span>;  
} </code></pre>
<p>细心的读者想必注意到了上述程序注释中所说的“如果限制空间复杂度为O（1），时间为O（N）就相当于正负数间顺序调整的那道题了”，没错，它与个人之前整理的一文中的第5题极其类似：5、一个未排序整数数组，有正负数，重新排列使负数排在正数前面，并且要求不改变原来的正负数之间相对顺序 比如： input: 1,7,-5,9,-12,15 ans: -5,-12,1,7,9,15 要求时间复杂度O(N),空间O(1) 。（<strong>此题一直没看到令我满意的答案，一般达不到题目所要求的：时间复杂度O(N),空间O(1)，且保证原来正负数之间的相对位置不变</strong>）。</p>
<p>如果你想到了绝妙的解决办法，不妨在本文评论下告知于我，或者来信指导（zhoulei0907@yahoo.cn），谢谢。</p>
<h3 id="第十九章第一个只出现一次的字符">第十九章、第一个只出现一次的字符</h3>
<p>第17 题：题目：在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。</p>
<p>分析：这道题是2006 年google 的一道笔试题。它在今年又出现了，不过换了一种形式。即最近的搜狐笔试大题：数组非常长，如何找到第一个只出现一次的数字，说明算法复杂度。此问题已经在程序员编程艺术系列第二章中有所阐述，在此不再作过多讲解。</p>
<p>代码，可编写如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;  </span>
<span class="kw">using</span> <span class="kw">namespace</span> std;  
  
<span class="co">//查找第一个只出现一次的字符，第1个程序  </span>
<span class="co">//copyright@ Sorehead &amp;&amp; July  </span>
<span class="co">//July、updated，2011.04.24.  </span>
<span class="dt">char</span> find_first_unique_char(<span class="dt">char</span> *str)  
{  
    <span class="dt">int</span> data[<span class="dv">256</span>];  
    <span class="dt">char</span> *p;  
      
    <span class="kw">if</span> (str == NULL)  
        <span class="kw">return</span> &#39;\<span class="dv">0</span>&#39;;  
      
    memset(data, <span class="dv">0</span>, <span class="kw">sizeof</span>(data));    <span class="co">//数组元素先全部初始化为0  </span>
    p = str;  
    <span class="kw">while</span> (*p != &#39;\<span class="dv">0</span>&#39;)  
        data[(<span class="dt">unsigned</span> <span class="dt">char</span>)*p++]++;  <span class="co">//遍历字符串，在相应位置++，（同时，下标强制转换）  </span>
      
    <span class="kw">while</span> (*str != &#39;\<span class="dv">0</span>&#39;)  
    {  
        <span class="kw">if</span> (data[(<span class="dt">unsigned</span> <span class="dt">char</span>)*str] == <span class="dv">1</span>)  <span class="co">//最后，输出那个第一个只出现次数为1的字符  </span>
            <span class="kw">return</span> *str;  
          
        str++;  
    }  
      
    <span class="kw">return</span> &#39;\<span class="dv">0</span>&#39;;  
}  
  
<span class="dt">int</span> main()  
{  
    <span class="dt">char</span> *str = <span class="st">&quot;afaccde&quot;</span>;  
    cout &lt;&lt; find_first_unique_char(str) &lt;&lt; endl;  
    <span class="kw">return</span> <span class="dv">0</span>;  
} </code></pre>
<p>当然，代码也可以这么写（测试正确）：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//查找第一个只出现一次的字符，第2个程序  </span>
<span class="co">//copyright@ yansha  </span>
<span class="co">//July、updated，2011.04.24.  </span>
<span class="dt">char</span> FirstNotRepeatChar(<span class="dt">char</span>* pString)  
{  
    <span class="kw">if</span>(!pString)  
        <span class="kw">return</span> &#39;\<span class="dv">0</span>&#39;;  
      
    <span class="dt">const</span> <span class="dt">int</span> tableSize = <span class="dv">256</span>;  
    <span class="dt">int</span> hashTable[tableSize] = {<span class="dv">0</span>}; <span class="co">//存入数组，并初始化为0  </span>
      
    <span class="dt">char</span>* pHashKey = pString;  
    <span class="kw">while</span>(*(pHashKey) != &#39;\<span class="dv">0</span>&#39;)  
        hashTable[*(pHashKey++)]++;  
      
    <span class="kw">while</span>(*pString != &#39;\<span class="dv">0</span>&#39;)  
    {  
        <span class="kw">if</span>(hashTable[*pString] == <span class="dv">1</span>)  
            <span class="kw">return</span> *pString;  
          
        pString++;  
    }  
    <span class="kw">return</span> &#39;\<span class="dv">0</span>&#39;;  <span class="co">//没有找到满足条件的字符，退出  </span>
} </code></pre>
<h2 id="第二十章一致性哈希算法">第二十章、一致性哈希算法</h2>
<p>tencent2012笔试题附加题</p>
<p>问题描述： 例如手机朋友网有n个服务器，为了方便用户的访问会在服务器上缓存数据，因此用户每次访问的时候最好能保持同一台服务器。</p>
<p>已有的做法是根据ServerIPIndex[QQNUM%n]得到请求的服务器，这种方法很方便将用户分到不同的服务器上去。但是如果一台服务器死掉了，那么n就变为了n-1，那么ServerIPIndex[QQNUM%n]与ServerIPIndex[QQNUM%（n-1）]基本上都不一样了，所以大多数用户的请求都会转到其他服务器，这样会发生大量访问错误。</p>
<p>问： 如何改进或者换一种方法，使得：</p>
<ol type="1">
<li><p>一台服务器死掉后，不会造成大面积的访问错误，</p></li>
<li><p>原有的访问基本还是停留在同一台服务器上；</p></li>
<li><p>尽量考虑负载均衡。（思路：往分布式一致哈希算法方面考虑。）</p></li>
</ol>
<ol type="1">
<li><p>最土的办法还是用模余方法：做法很简单，假设有N台服务器，现在完好的是M（M&lt;=N),先用N求模，如果不落在完好的机器上，然后再用N-1求模，直到M.这种方式对于坏的机器不多的情况下，具有更好的稳定性。</p></li>
<li><p>一致性哈希算法。</p></li>
</ol>
<p>下面，本文剩下部分重点来讲讲这个一致性哈希算法。</p>
<h3 id="应用场景">应用场景</h3>
<p>在做服务器负载均衡时候可供选择的负载均衡的算法有很多，包括： 轮循算法（Round Robin）、哈希算法（HASH）、最少连接算法（Least Connection）、响应速度算法（Response Time）、加权法（Weighted ）等。其中哈希算法是最为常用的算法.</p>
<p>典型的应用场景是： 有N台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责1/N的服务。</p>
<p>常用的算法是对hash结果取余数 (hash() mod N)：对机器编号从0到N-1，按照自定义的hash()算法，对每个请求的hash()值按N取模，得到余数i，然后将请求分发到编号为i的机器。但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算；如果新增一台机器，会有N /(N+1)的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸（因为这意味着大量缓存的失效或者数据需要转移）。那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢？</p>
<p>在Memcached、Key-Value Store、Bittorrent DHT、LVS中都采用了Consistent Hashing算法，可以说Consistent Hashing 是分布式系统负载均衡的首选算法。 ### Consistent Hashing算法描述</p>
<p>下面以Memcached中的Consisten Hashing算法为例说明。</p>
<p>consistent hashing 算法早在 1997 年就在论文 <a href="http://dl.acm.org/citation.cfm?id=258660">Consistent hashing and random trees</a> 中被提出，目前在 cache 系统中应用越来越广泛；</p>
<h4 id="基本场景">1 基本场景</h4>
<p>比如你有 N 个 cache 服务器（后面简称 cache ），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash 值，然后均匀的映射到到 N 个 cache ；</p>
<p>hash(object)%N</p>
<p>一切都运行正常，再考虑如下的两种情况；</p>
<ol type="1">
<li>一个 cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1) ；</li>
<li>由于访问加重，需要添加 cache ，这时候 cache 是 N+1 台，映射公式变成了 hash(object)%(N+1) ；</li>
</ol>
<p>1 和 2 意味着什么？这意味着突然之间几乎所有的 cache 都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的 hash 算法也做不到。</p>
<p>有什么方法可以改变这个状况呢，这就是consistent hashing。</p>
<h4 id="hash-算法和单调性">2 hash 算法和单调性</h4>
<p>Hash 算法的一个衡量指标是单调性（ Monotonicity ），定义如下：</p>
<p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p>
<p>容易看到，上面的简单 hash 算法 hash(object)%N 难以满足单调性要求。</p>
<h4 id="consistent-hashing-算法的原理">3 consistent hashing 算法的原理</h4>
<p>consistent hashing 是一种 hash 算法，简单的说，在移除 / 添加一个 cache 时，它能够尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。</p>
<p>下面就来按照 5 个步骤简单讲讲 consistent hashing 算法的基本原理。</p>
<h5 id="环形hash-空间">3.1 环形hash 空间</h5>
<p>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环，如下面图 1 所示的那样。</p>
<figure>
<img src="../images/16~20/20.1.jpg" title="图 1 环形 hash 空间" />
</figure>
<p>图 1 环形 hash 空间</p>
<h5 id="把对象映射到hash-空间">3.2 把对象映射到hash 空间</h5>
<p>接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布如图 2 所示。</p>
<p>hash(object1) = key1;</p>
<p>… …</p>
<p>hash(object4) = key4;</p>
<figure>
<img src="../images/16~20/20.2.jpg" title="图 2 4 个对象的 key 值分布" />
</figure>
<p>图 2 4 个对象的 key 值分布</p>
<h5 id="把cache-映射到hash-空间">3.3 把cache 映射到hash 空间</h5>
<p>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的hash 算法。</p>
<p>假设当前有 A,B 和 C 共 3 台 cache ，那么其映射结果将如图 3 所示，他们在 hash 空间中，以对应的 hash值排列。</p>
<p>hash(cache A) = key A;</p>
<p>… …</p>
<p>hash(cache C) = key C;</p>
<figure>
<img src="../images/16~20/20.3.jpg" title="图 3 cache 和对象的 key 值分布" />
</figure>
<p>图 3 cache 和对象的 key 值分布</p>
<p>说到这里，顺便提一下 cache 的 hash 计算，一般的方法可以使用 cache 机器的 IP 地址或者机器名作为hash 输入。</p>
<h5 id="把对象映射到cache">3.4 把对象映射到cache</h5>
<p>现在 cache 和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，接下来要考虑的就是如何将对象映射到 cache 上面了。</p>
<p>在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 cache ，那么就将该对象存储在这个 cache 上，因为对象和 cache 的 hash 值是固定的，因此这个 cache 必然是唯一和确定的。这样不就找到了对象和 cache 的映射方法了吗？！</p>
<p>依然继续上面的例子（参见图 3 ），那么根据上面的方法，对象 object1 将被存储到 cache A 上； object2和 object3 对应到 cache C ； object4 对应到 cache B ；</p>
<h5 id="考察cache-的变动">3.5 考察cache 的变动</h5>
<p>前面讲过，通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时，cache 会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析 consistent hashing 算法。</p>
<h6 id="移除-cache">3.5.1 移除 cache</h6>
<p>考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 顺时针遍历直到下一个 cache （ cache C ）之间的对象，也即是本来映射到 cache B 上的那些对象。</p>
<p>因此这里仅需要变动对象 object4 ，将其重新映射到 cache C 上即可；参见图 4 。</p>
<figure>
<img src="../images/16~20/20.4.jpg" title="图 4 Cache B 被移除后的 cache 映射" />
</figure>
<p>图 4 Cache B 被移除后的 cache 映射</p>
<h6 id="添加-cache">3.5.2 添加 cache</h6>
<p>再考虑添加一台新的 cache D 的情况，假设在这个环形 hash 空间中， cache D 被映射在对象 object2 和object3 之间。这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache （ cache B ）之间的对象（它们是也本来映射到 cache C 上对象的一部分），将这些对象重新映射到 cache D 上即可。</p>
<p>因此这里仅需要变动对象 object2 ，将其重新映射到 cache D 上；参见图 5 。</p>
<figure>
<img src="../images/16~20/20.5.jpg" title="图 5 添加 cache D 后的映射关系" />
</figure>
<p>图 5 添加 cache D 后的映射关系</p>
<h4 id="虚拟节点">4 虚拟节点</h4>
<p>考量 Hash 算法的另一个指标是平衡性 (Balance) ，定义如下：</p>
<h5 id="平衡性">平衡性</h5>
<p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p>
<p>hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，比如在上面的例子中，仅部署 cache A 和 cache C 的情况下，在 4 个对象中， cache A 仅存储了 object1 ，而 cache C 则存储了 object2 、 object3 和 object4 ；分布是很不均衡的。</p>
<p>为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：</p>
<p>“虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。</p>
<p>仍以仅部署 cache A 和 cache C 的情况为例，在图 4 中我们已经看到， cache 分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A ； cache C1, cache C2 代表了 cache C ；假设一种比较理想的情况，参见图 6 。</p>
<figure>
<img src="../images/16~20/20.6.jpg" title="图 6 引入“虚拟节点”后的映射关系" />
</figure>
<p>图 6 引入“虚拟节点”后的映射关系</p>
<p>此时，对象到“虚拟节点”的映射关系为：</p>
<p>objec1-&gt;cache A2 ； objec2-&gt;cache A1 ； objec3-&gt;cache C1 ； objec4-&gt;cache C2 ；</p>
<p>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。</p>
<p>引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache时的映射关系如图 7 所示。</p>
<figure>
<img src="../images/16~20/20.7.jpg" title="图 7 查询对象所在 cache" />
</figure>
<p>图 7 查询对象所在 cache</p>
<p>“虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为202.168.14.241 。</p>
<p>引入“虚拟节点”前，计算 cache A 的 hash 值：</p>
<p>Hash(“202.168.14.241”);</p>
<p>引入“虚拟节点”后，计算“虚拟节”点 cache A1 和 cache A2 的 hash 值：</p>
<p>Hash(“202.168.14.241#1”); // cache A1</p>
<p>Hash(“202.168.14.241#2”); // cache A2</p>
<h2 id="后记">后记</h2>
<ol type="1">
<li>以上部分代码思路有参考自此博客：(<a href="http://zhedahht.blog.163.com/blog/">http://zhedahht.blog.163.com/blog/</a>)。特此注明下。<br /></li>
<li>上文第五部分来源：(<a href="http://blog.csdn.net/sparkliang/article/details/5279393">http://blog.csdn.net/sparkliang/article/details/5279393</a>)；</li>
<li>行文仓促，若有任何问题或漏洞，欢迎不吝指正或赐教。谢谢。转载，请注明出处。完。</li>
</ol>
<h1 id="第二十一章出现次数超过一半的数字">第二十一章：出现次数超过一半的数字</h1>
<h2 id="前言-1">前言</h2>
<p>这个问题来自编程之美上，Tango是微软亚洲研究院的一个试验项目，如图1所示。研究院的员工和实习生们都很喜欢在Tango上面交流灌水。传说，Tango有一大“水王”，他不但喜欢发帖，还会回复其他ID发的每个帖子。坊间风闻该“水王”发帖数目超过了帖子总数的一半。如果你有一个当前论坛上所有帖子（包括回帖）的列表，其中帖子作者的ID也在表中，你能快速找出这个传说中的Tango水王吗？</p>
<figure>
<img src="../images/21~22/21.1.gif" />
</figure>
<p>图1 Tango</p>
<p>ok，看本文之前，你尚不知道怎么解决上述两个问题的话不要紧，本文即要阐述上述两个问题。若有任何问题，欢迎随时不吝指正。谢谢。</p>
<h2 id="第二十一章发帖水王及其扩展">第二十一章：发帖水王及其扩展</h2>
<h4 id="第一节74.数组中超过出现次数超过一半的数字">第一节：74.数组中超过出现次数超过一半的数字</h4>
<p>题目：数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。</p>
<p>分析：编程之美上也有这道题，不过它变换了题目的表述形式，即是如本文前言所述的寻找发帖水王的问题。</p>
<p>ok，咱们来解决上述这道题，以微软面试100题第74题的阐述为准（本程序员编程艺术系列就是按照之前整理的微软100题一题一题展开而来的）。</p>
<p>一个数组中有很多数，现在我们要找出这个数组中那个超过出现次数一半的数字，怎么找呢?大凡当我们碰到某一个杂乱无序的东西时，我们人的内心本质期望是希望把它梳理成有序的。所以，我们得分两种情况来讨论，无序和有序：</p>
<p><strong>1.</strong>如果<strong>无序</strong>，那么我们是不是可以先把数组中所有这些数字<strong>先进行排序</strong>，至于选取什么排序方法则不在话下，最常用的快速排序O（N<em>logN）即可。排完序呢，直接遍历。在遍历整个数组的同时统计每个数字的出现次数，然后把那个出现次数超过一半的数字直接输出，题目便解答完成了。总的时间复杂度为O（N</em>logN+N）。</p>
<p><strong>2.</strong>但各位再想想，<strong>如果是有序的数组呢</strong>或者经过上述由无序的数组变成有序后的数组呢？是否在排完序O（N<em>logN）后，真的还需要再遍历一次整个数组么?我们知道，既然是数组的话，那么我们可以根据数组索引支持直接定向到某一个数。我们发现，一个数字在数组中的出现次数超过了一半，那么在已排好序的数组索引的N/2处（从零开始编号），就一定是这个数字。自此，我们只需要对整个数组排完序之后，然后直接输出数组中的第N/2处的数字即可，这个数字即是整个数组中出现次数超过一半的数字，总的时间复杂度由于少了最后一次整个数组的遍历，缩小到O（N</em>logN）。</p>
<p><strong>3.</strong>然不论是上述思路一的O（N<em>logN+N），还是思路二的O（N</em>logN），时间复杂度并无本质性的改变。我们需要找到一种更为有效的思路或方法。既要缩小总的时间复杂度，那么就用查找时间复杂度为O（1），事先预处理时间复杂度为O（N）的<strong>hash表</strong>。哈希表的键值（Key）为数组中的数字，值（Value）为该数字对应的次数。然后直接遍历整个<strong>hash表</strong>，找出每一个数字在对应的位置处出现的次数，输出那个出现次数超过一半的数字即可。</p>
<p><strong>4.</strong>Hash表需要O（N）的开销空间，且要设计hash函数，还有没有更好的办法呢?我们可以试着这么考虑，如果<strong>每次删除两个不同的数</strong>（不管是不是我们要查找的那个出现次数超过一半的数字），那么，在剩下的数中，我们要查找的数（出现次数超过一半）出现的次数仍然超过总数的一半。通过不断重复这个过程，不断排除掉其它的数，最终找到那个出现次数超过一半的数字。这个方法，免去了上述思路一、二的排序，也避免了思路三空间O（N）的开销，总得说来，时间复杂度只有O（N），空间复杂度为O（1），不失为最佳方法。</p>
<p>或许，你还没有明白上述思路4的意思，举个简单的例子吧，如数组a[5]={0,1,2,1,1};</p>
<p>很显然，若我们要找出数组a中出现次数超过一半的数字，这个数字便是1，若根据上述思路4所述的方法来查找，我们应该怎么做呢?通过一次性遍历整个数组，然后每次删除不相同的两个数字，过程如下简单表示：</p>
<pre><code>0 1 2 1 1 =&gt;2 1 1=&gt;1,最终，1即为所找。</code></pre>
<p>但是如果是5，5，5，5，1，还能运用上述思路么？额，别急，请看下文思路5。</p>
<p><strong>5.</strong>咱们根据数组的特性进一步考虑@zhedahht： 数组中有个数字出现的次数超过了数组长度的一半。也就是说，有个数字出现的次数比其他所有数字出现次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1。如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，我们需要保存下一个数字，并把次数重新设为1。</p>
<p>下面，举二个例子：</p>
<ul>
<li><p>第一个例子，5，5，5，5，1 ：</p>
<p>不同的相消，相同的累积。遍历到第四个数字时，candidate 是5, nTimes 是4; 遍历到第五个数字时，candidate 是5, nTimes 是3; nTimes不为0，那么candidate就是超过半数的。</p></li>
<li><p>第二个例子，0，1，2，1，1 :</p>
<p>开始时，保存candidate是数字0，ntimes为1，遍历到数字1后，与数字0不同，则ntime减1变为零,；接下来，遍历到数字2，2与1不同，candidate保存数字2，且ntimes重新设为1；继续遍历到第4个数字1时，与2不同，ntimes减一为零，同时candidate保存为1；最终遍历到最后一个数字还是1，与我们之前candidate保存的数字1相同，ntime加一为1。最后返回的是之前保存的candidate为1。</p></li>
</ul>
<figure>
<img src="../images/21~22/21.2.gif" />
</figure>
<p>针对上述程序，我再说详细点，0，1，2，1，1 ：</p>
<pre><code>i=0，candidate=0，nTimes=1；
i=1，a[1]=0 ！= candidate，nTimes--，=0；
i=2，candidate=2，nTimes=1；
i=3，a[3] ！= candidate，nTimes--，=0；
i=4，candidate=1，nTimes=1；
如果是0，1，2，1，1，1的话，那么i=5，a[5]=1=candidate，nTimes++，=2；......</code></pre>
<p>ok，思路清楚了，完整的代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//改自编程之美 2010  </span>
Type Find(Type* a, <span class="dt">int</span> N)  <span class="co">//a代表数组，N代表数组长度  </span>
{  
    Type candidate;  
    <span class="dt">int</span> nTimes, i;  
    <span class="kw">for</span>(i = nTimes = <span class="dv">0</span>; i &lt; N; i++)  
    {  
        <span class="kw">if</span>(nTimes == <span class="dv">0</span>)  
        {  
            candidate = a[i], nTimes = <span class="dv">1</span>;  
        }  
        <span class="kw">else</span>  
        {  
            <span class="kw">if</span>(candidate == a[i])  
                nTimes++;  
            <span class="kw">else</span>  
                nTimes--;  
        }  
    }  
    <span class="kw">return</span> candidate;   
}</code></pre>
<p>或者：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@zhedahht  </span>
<span class="co">//July,updated,  </span>
<span class="co">//2011.04.16。  </span>
<span class="ot">#include &lt;iostream&gt;  </span>
<span class="kw">using</span> <span class="kw">namespace</span> std;  
  
<span class="dt">bool</span> g_Input = <span class="kw">false</span>;  
  
<span class="dt">int</span> Num(<span class="dt">int</span>* numbers, <span class="dt">unsigned</span> <span class="dt">int</span> length)  
{  
    <span class="kw">if</span>(numbers == NULL &amp;&amp; length == <span class="dv">0</span>)  
    {  
        g_Input = <span class="kw">true</span>;  
        <span class="kw">return</span> <span class="dv">0</span>;  
    }  
    g_Input = <span class="kw">false</span>;  
      
    <span class="dt">int</span> result = numbers[<span class="dv">0</span>];  
    <span class="dt">int</span> times = <span class="dv">1</span>;  
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; length; ++i)  
    {  
        <span class="kw">if</span>(numbers[i] == result)  
            times++;  
        <span class="kw">else</span>  
            times--;  
        <span class="kw">if</span>(times == <span class="dv">0</span>)  
        {  
            result = numbers[i];  
            times = <span class="dv">1</span>;  
        }  
    }  
      
    <span class="co">//检测输入是否有效。  </span>
    times = <span class="dv">0</span>;  
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; length; ++i)  
    {  
        <span class="kw">if</span>(numbers[i] == result)  
            times++;  
    }  
    <span class="kw">if</span>(times * <span class="dv">2</span> &lt;= length)  
        <span class="co">//检测的标准是：如果数组中并不包含这么一个数字，那么输入将是无效的。  </span>
    {  
        g_Input = <span class="kw">true</span>;  
        result = <span class="dv">0</span>;  
    }      
    <span class="kw">return</span> result;  
}  
  
<span class="dt">int</span> main()  
{  
    <span class="dt">int</span> a[<span class="dv">10</span>]={<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>};  
    <span class="dt">int</span>* n=a;  
    cout&lt;&lt;Num(a,<span class="dv">9</span>)&lt;&lt;endl;  
    <span class="kw">return</span> <span class="dv">0</span>;  
}</code></pre>
<p>这段代码与上段代码本质上并无二致，不过有几个问题，还是需要我们注意：</p>
<p><strong>1.</strong>当输入无效性时，要处理。比如数组长度为0。</p>
<p><strong>2.</strong>最后，上述代码加了一个判断，如果数组中并不包含这么一个数字，那么输入也是无效的。因此在函数结束前还加了一段代码来验证输入是不是有效的。</p>
<h4 id="第二节加强版水王.找出出现次数刚好是一半的数字">第二节：加强版水王.找出出现次数刚好是一半的数字</h4>
<p><strong>1.问题扩展@BrainDeveloper</strong></p>
<p>我们知道，水王问题：有N个数，其中有一个数出现超过一半，要求在线性时间求出这个数。那么，我的问题是，加强版水王：有N个数，其中有一个数刚好出现一半次数，要求在线性时间内求出这个数。</p>
<p>因为，很明显，如果是刚好出现一半的话，如此例： 0，1，2，1 ：</p>
<pre><code>遍历到0 时 candidate为0，times为1
遍历到1时  与candidate不同，times减为0
遍历到2时， times为0，则candidate更新为2，times加1
遍历到1时， 与candidate不同，则times减为0；我们需要返回所保存candidate（数字2）的下一个数字即数字1。</code></pre>
<p>所以，如果还运用上面的程序的话，那么只能返回我们要找的数字1的前一个数字，即遍历到1之前所保存的candidate=2，试问如何让程序能返回我们需要的数字1呢？望读者思考之。</p>
<p>赤血红狐&amp;&amp;pointersky用了两个变量来记录水王，最终完整代码如下（测试正确）：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;iostream&gt;  </span>
<span class="kw">using</span> <span class="kw">namespace</span> std;  
  
<span class="dt">int</span> Find(<span class="dt">int</span>* a, <span class="dt">int</span> N)  
{  
    <span class="dt">int</span> candidate1,candidate2;  
    <span class="dt">int</span> nTimes1, nTimes2, i;  
          
    <span class="kw">for</span>(i = nTimes1 = nTimes2 =<span class="dv">0</span>; i &lt; N; i++)  
    {  
        <span class="kw">if</span>(nTimes1 == <span class="dv">0</span>)  
        {  
            candidate1 = a[i], nTimes1 = <span class="dv">1</span>;  
        }  
        <span class="kw">else</span> <span class="kw">if</span>(nTimes2 == <span class="dv">0</span> &amp;&amp; candidate1 != a[i])  
        <span class="co">//注意：这里的判断条件加上第二个变量是否等于第一个变量的判断  </span>
        {  
              
            candidate2 = a[i], nTimes2 = <span class="dv">1</span>;  
        }  
        <span class="kw">else</span>  
        {  
            <span class="kw">if</span>(candidate1 == a[i])  
                nTimes1++;  
            <span class="kw">else</span> <span class="kw">if</span>(candidate2 == a[i])  
                nTimes2++;  
            <span class="kw">else</span>  
            {  
                nTimes1--;  
                nTimes2--;  
            }  
        }  
    }  
    <span class="kw">return</span> nTimes1&gt;nTimes2?candidate1:candidate2;  
}  
  
<span class="dt">int</span> main()  
{  
    <span class="dt">int</span> a[<span class="dv">4</span>]={<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>};  
    cout&lt;&lt;Find(a,<span class="dv">4</span>)&lt;&lt;endl;  
<span class="co">//  int a[6]={1,0,2,1,2,1};  </span>
<span class="co">//  cout&lt;&lt;Find(a,6)&lt;&lt;endl;  </span>
}</code></pre>
<p><strong>4.读者反馈</strong></p>
<p>当然也可以如<a href="http://blog.csdn.net/v_july_v/article/details/6890054">本文</a>评论下第16楼dalong7所述：</p>
<pre><code>易知总数必定是偶数，同时删除不同数字，最后剩余的两个数字必有其一为水王，只需简单判断一下即可</code></pre>
<p>代码如下（测试正确）：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> Find(<span class="dt">int</span>* a, <span class="dt">int</span> N)  <span class="co">//a代表数组，N代表数组长度      </span>
{      
    <span class="dt">int</span> candidate;      
    <span class="dt">int</span> nTimes, i;      
    <span class="kw">for</span>(i = nTimes = <span class="dv">0</span>; i &lt; N; i++)      
    {      
        <span class="kw">if</span>(nTimes == <span class="dv">0</span>)      
        {      
            candidate = a[i], nTimes = <span class="dv">1</span>;      
        }      
        <span class="kw">else</span>      
        {      
            <span class="kw">if</span>(candidate == a[i])      
                nTimes++;      
            <span class="kw">else</span>      
                nTimes--;      
        }      
    }      
    
    <span class="dt">int</span> cTimes = <span class="dv">0</span>;    
    <span class="dt">int</span> candidate2 = a[N<span class="dv">-1</span>];    
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; N; i ++)    
    {    
        <span class="kw">if</span>(a[i] == candidate)    
        {    
            cTimes++;    
        }    
    }    
    
    <span class="kw">return</span> cTimes == N/<span class="dv">2</span> ? candidate : candidate2;       
}</code></pre>
<h4 id="第三节这个问题的美国选举版本和论文">第三节：这个问题的美国选举版本和论文</h4>
<p><strong>1. 谁是选举中得票超半数的人？</strong></p>
<p>美国选举一般要求找到的票数超过一半的人。于是有人就开始研究如何用线性时间找到这个人或者证明这个人不存在。Robert S. Boyer 和 J Strother Moore 发表了一片关于这个算法的论文。内容和上文提到的算法是一致的，只是多了理论分析和FORTRAN实现部分。</p>
<p>MJRTY - A Fast Majority Vote Algorithm, with R.S. Boyer. In R.S. Boyer (ed.), Automated Reasoning: Essays in Honor of Woody Bledsoe, Automated Reasoning Series, Kluwer Academic Publishers, Dordrecht, The Netherlands, 1981, pp. 105-117.</p>
<p><strong>2. 链接</strong></p>
<p>论文链接：http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.3439&amp;rep=rep1&amp;type=pdf</p>
<p>作者J Strother Moore关于这个算法的网址（英文）：http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html</p>
<h1 id="第二十二章最短摘要的生成">第二十二章：最短摘要的生成</h1>
<p>第二个问题来自各位读者的手中，你我在百度或谷歌搜索框中敲入本博客名称的前4个字“结构之法”，便能在第一个选项看到本博客的链接，如下图2所示：</p>
<figure>
<img src="../images/21~22/22.1.gif" />
</figure>
<p>图2 谷歌中搜索关键字“结构之法”</p>
<p>在上面所示的图2中，搜索结果“结构之法算法之道-博客频道-CSDN.NET”下有一段说明性的文字：“程序员面试、算法研究、编程艺术、红黑树4大经典原创系列集锦与总结 作者：July--结构之法算法...”，我们把这段文字称为那个搜索结果的摘要，亦即最短摘要。我们的问题是，请问，这个最短摘要是怎么生成的呢?</p>
<p><strong>Alibaba</strong>笔试题：给定一段产品的英文描述，包含M个英文字母，每个英文单词以空格分隔，无其他标点符号；再给定N个英文单词关键字，请说明思路并编程实现方法</p>
<pre><code>String extractSummary(String description,String[] key words)</code></pre>
<p>目标是找出此产品描述中包含N个关键字（每个关键词至少出现一次）的长度最短的子串，作为产品简介输出。（不限编程语言）20分。</p>
<p>这题是来自此篇文章十月百度，阿里巴巴，迅雷搜狗最新面试十一题中整理的阿里巴巴的笔试题，之前已经给出了这样一种思路，如下：</p>
<pre><code>@owen：扫描过程始终保持一个[left,right]的range,初始化确保[left,right]的range里包含所有关键字则停止。然后每次迭代：
1.试图右移动left，停止条件为再移动将导致无法包含所有关键字。
2.比较当前range&#39;s length和best length，更新最优值。
3.右移right，停止条件为使任意一个关键字的计数+1。
4.重复迭代。</code></pre>
<p>在那篇文章中也提到了编程之美有最短摘要生成的问题，与此问题类似。下面，我将介绍这种方法。首先，咱们来看一个问题。读者可以在百度或谷歌中搜索本博客名称的前4个字，”结构之法“，便会在第一个搜索结果中看到如下图所示的搜索项：</p>
<figure>
<img src="../images/21~22/22.2.gif" />
</figure>
<p>上图中，那段大致介绍本博客结构之法算法之道的文字：”程序员面试、算法研究、编程艺术、红黑树4大经典原创系列集锦与总结 作者：July--结构之法算法之道blog之博主。时间：2010年10月-2011年6月。出处：http://...“这段介于搜索关键词与最底下的URL便是我们所称之为的摘要。那么，这段摘要是怎么产生的呢?可以对问题进行如下的简化。</p>
<p><strong>1.</strong>假设给定的已经是经过网页分词之后的结果，词语序列数组为W。其中W[0], W[1],…, W[N]为一些已经分好的词语。</p>
<p><strong>2.</strong>假设用户输入的搜索关键词为数组Q。其中Q[0], Q[1],…, Q[m]为所有输入的搜索关键词。</p>
<p>这样，生成的最短摘要实际上就是一串相互联系的分词序列。比如从W[i]到W[j]，其中，0 &lt; i &lt; j&lt;= N。例如上图所示的摘要“程序员面试、算法研究、编程艺术、红黑树4大经典原创吸了集锦与总结 作者：July--结构之法算法之道blog之博主.....”中包含了关键字——“结构之法”。</p>
<p>那么，我们该怎么做呢？</p>
<h4 id="思路一">思路一：</h4>
<p>在分析问题之前，先通过一个实际的例子来探讨。比如在本博客第一篇置顶文章的开头，有这么一段话：</p>
<pre><code>“程序员面试、算法研究、编程艺术、红黑树4大经典原创系列集锦与总结
作者：July--结构之法算法之道blog之博主。
时间：2010年10月-2011年6月。
出处：http://blog.csdn.net/v_JULY_v。
声明：版权所有，侵犯必究。”</code></pre>
<p>那么，我们可以猜想一下可能的分词结果：</p>
<pre><code>”程序员/面试/、/算法/研究/、/编程/艺术/、/红黑树/4/大/经典/原创/系列/集锦/与/总结/ /作者/：/July/
--/结构/之/法/算法/之/道/blog/之/博主/....“（网页的分词效果W数组）</code></pre>
<p>这也就是我们期望的W数组序列。</p>
<p>之前的Q数组序列为：</p>
<pre><code>“结构之法”（用户输入的关键字Q数组）</code></pre>
<p>再看下下面这个W-Q序列：</p>
<pre><code>w0,w1,w2,w3,q0,w4,w5,q1,w6,w7,w8,q0,w9,q1</code></pre>
<p>上述序列上面的是W数组（经过网页分词之后的结果），W[0], W[1],…, W[N]为一些已经分好的词语，上述序列下面的是Q数组（用户输入的搜索关键词）。其中Q[0], Q[1],…, Q[m]为所有输入的搜索关键词。</p>
<p>ok，如果你不甚明白，我说的通俗点：如上W-Q序列中，我们可以把,q0,w4,w5,q1作为摘要，q0,w9,q1的也可以作为摘要，同样都包括了所有的关键词q0，q1，那么选取哪个是最短摘要呢？答案很明显，后一个更短，选取q0,w9,q1的作为最短摘要，这便是最短摘要的生成。</p>
<p>我们可以进一步可以想象，如下：</p>
<p>从用户的角度看：当我们在百度的搜索框中输入“结构之法”4个字时，搜索引擎将在索引数据库中（关于搜索引擎原理的大致介绍，可参考本博客中这篇文章：搜索引擎技术之概要预览）查找和匹配这4个字的网页，最终第一个找到了本博客的置顶的第一篇文章：[置顶]程序员面试、算法研究、编程艺术、红黑树4大系列集锦与总结；</p>
<p>从搜索引擎的角度看：搜索引擎经过把上述网页分词后，便得到了上述的分词效果，然后在这些分词中查找“结构之法”4个关键字，但这4个关键字不一定只会出现一遍，它可能会在这篇文章中出现多次，就如上面的W-Q序列一般。咱们可以假想出下面的结果（结构之法便出现了两次）：</p>
<pre><code>“程序员/面试/、/算法/研究/、/编程/艺术/、/红黑树/4/大/经典/原创/系列/集锦/与/总结/ /作者/：/July/
--/结构/之/法/算法/之/道/blog/之/博主/././././转载/请/注明/出处/：/结构/之/法/算法/之/道/CSDN/博客/./././.”</code></pre>
<p>由此，我们可以得出解决此问题的思路，如下：</p>
<p><strong>1.</strong>从W数组的第一个位置开始查找出一段包含所有关键词数组Q的序列（第一个位置”程“开始：程序员/面试/、/算法/研究/、/编程/艺术/、/红黑树/4/大/经典/原创/系列/集锦/与/总结/ /作者/：/July/--/结构/之/法/查找包含关键字“结构之法”所有关键词的序列）。计算当前的最短长度，并更新Seq数组。</p>
<p><strong>2.</strong>对目标数组W进行遍历，从第二个位置开始，重新查找包含所有关键词数组Q的序列（第二个位置”序“处开始：程序员/面试/、/算法/研究/、/编程/艺术/、/红黑树/4/大/经典/原创/系列/集锦/与/总结/ /作者/：/July/--/结构/之/法/查找包含关键字”结构之法“所有关键词的序列），同样计算出其最短长度，以及更新包含所有关键词的序列Seq，然后求出最短距离。</p>
<p><strong>3.</strong>依次操作下去，一直到遍历至目标数组W的最后一个位置为止。</p>
<p>最终，通过比较，咱们确定如下分词序列作为最短摘要，即搜索引擎给出的分词效果：</p>
<pre><code>“程序员面试、算法研究、编程艺术、红黑树4大经典原创系列集锦与总结 作者：July--结构之法算法之道blog之博主。
时间：2010年10月-2011年6月。出处：http://...”</code></pre>
<p>那么，这个算法的时间复杂度如何呢？</p>
<p>要遍历所有其他的关键词（M），对于每个关键词，要遍历整个网页的词（N），而每个关键词在整个网页中的每一次出现，要遍历所有的Seq，以更新这个关键词与所有其他关键词的最小距离。所以算法复杂度为：O（N^2 * M）。</p>
<h4 id="思路二">思路二：</h4>
<p>我们试着降低此问题的复杂度。因为上述思路一再进行查找的时候，总是重复地循环，效率不高。那么怎么简化呢？先来看看这些序列：</p>
<pre><code>w0,w1,w2,w3,q0,w4,w5,q1,w6,w7,w8,q0,w9,q1</code></pre>
<p>问题在于，如何一次把所有的关键词都扫描到，并且不遗漏。扫描肯定是无法避免的，但是如何把两次扫描的结果联系起来呢？这是一个值得考虑的问题。</p>
<p>沿用前面的扫描方法，再来看看。第一次扫描的时候，假设需要包含所有的关键词，从第一个位置w0处将扫描到w6处：</p>
<pre><code>w0,w1,w2,w3,q0,w4,w5,q1,w6,w7,w8,q0,w9,q1</code></pre>
<p>那么，下次扫描应该怎么办呢？先把第一个被扫描的位置挪到q0处。</p>
<pre><code>w0,w1,w2,w3,q0,w4,w5,q1,w6,w7,w8,q0,w9,q1</code></pre>
<p>然后把第一个被扫描的位置继续往后面移动一格，这样包含的序列中将减少了关键词q0。那么，我们便可以把第二个扫描位置往后移，这样就可以找到下一个包含所有关键词的序列。即从w4扫描到w9处，便包含了q1，q0：</p>
<pre><code>w0,w1,w2,w3,q0,w4,w5,q1,w6,w7,w8,q0,w9,q1</code></pre>
<p>这样，问题就和第一次扫描时碰到的情况一样了。依次扫描下去，在w中找出所有包含q的序列，并且找出其中的最小值，就可得到最终的结果。编程之美上给出了如下参考代码：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//July、updated，2011.10.21</span>
<span class="dt">int</span> nTargetLen = N + <span class="dv">1</span>;           <span class="co">// 设置目标长度为总长度+1  </span>
<span class="dt">int</span> pBegin = <span class="dv">0</span>;                     <span class="co">// 初始指针  </span>
<span class="dt">int</span> pEnd = <span class="dv">0</span>;                       <span class="co">// 结束指针  </span>
<span class="dt">int</span> nLen = N;                       <span class="co">// 目标数组的长度为N  </span>
<span class="dt">int</span> nAbstractBegin = <span class="dv">0</span>;           <span class="co">// 目标摘要的起始地址  </span>
<span class="dt">int</span> nAbstractEnd = <span class="dv">0</span>;           <span class="co">// 目标摘要的结束地址  </span>
  
<span class="kw">while</span>(true)  
{  
    <span class="co">// 假设未包含所有的关键词，并且后面的指针没有越界，往后移动指针  </span>
    <span class="kw">while</span>(!isAllExisted() &amp;&amp; pEnd &lt; nLen)  
    {  
        pEnd++;  
    }  
      
    <span class="co">// 假设找到一段包含所有关键词信息的字符串  </span>
    <span class="kw">while</span>(isAllExisted())  
    {  
        <span class="kw">if</span>(pEnd – pBegin &lt; nTargetLen)  
        {  
            nTargetLen = pEnd – pBegin;  
            nAbstractBegin = pBegin;  
            nAbstractEnd = pEnd – <span class="dv">1</span>;   
        }  
        pBegin++;  
    }  
    <span class="kw">if</span>(pEnd &gt;= N)  
        Break;  
}</code></pre>
<p>小结：上述思路二相比于思路一，很明显提高了不小效率。我们在匹配的过程中利用了可以省去其中某些死板的步骤，这让我想到了KMP算法的匹配过程。同样是经过观察，比较，最后总结归纳出的高效算法。我想，一定还有更好的办法，只是我们目前还没有看到，想到，待我们去发现，创造。</p>
<h4 id="思路三">思路三：</h4>
<p>以下是读者jiaotao1983回复于本文评论下的反馈，非常感谢。</p>
<p>关于最短摘要的生成，我觉得July的处理有些简单，我以July的想法为基础，提出了自己的一些想法，这个问题分以下几步解决：</p>
<p><strong>1.</strong>将传入的key words[]生成哈希表，便于以后的字符串比较。结构为KeyHash，如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> KeyHash
{
  <span class="dt">int</span> cnt;
  <span class="dt">char</span> key[];
  <span class="dt">int</span> hash;
}</code></pre>
<p>结构体中的hash代表了关键字的哈希值，key代表了关键字，cnt代表了在当前的扫描过程中，扫描到的该关键字的个数。</p>
<p>当然，作为哈希表结构，该结构体中还会有其它值，这里不赘述。</p>
<p>初始状态下，所有哈希结构的cnt字段为0。</p>
<p><strong>2.</strong>建立一个KeyWord结构，结构体如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> KeyWord
{
  <span class="dt">int</span> start;
  KeyHash* key;
  KeyWord* next;
  KeyWord* prev;
}</code></pre>
<p>key字段指向了建立的一个KeyWord代表了当前扫描到的一个关键字，扫描到的多个关键字组成一个双向链表。</p>
<p>start字段指向了关键字在文章中的起始位置。</p>
<p><strong>3.</strong>建立几个全局变量:</p>
<p>KeyWord* head，指向了双向链表的头，初始为NULL。</p>
<p>KeyWord* tail，指向了双向链表的尾，初始为NULL。</p>
<p>int minLen，当前扫描到的最短的摘要的长度，初始为0。</p>
<p>int minStartPos，当前扫描到的最短摘要的起始位置。</p>
<p>int needKeyCnt，还需要几个关键字才能够包括全部的关键字，初始为关键字的个数。</p>
<p><strong>4.</strong>开始对文章进行扫描。每扫描到一个关键字时，就建立一个KeyWord的结构并且将其连入到扫描到的双向链表中，更新head和tail结构，同时将对应的KeyHash结构中的cnt加1，表示扫描到了关键字。如果cnt由0变成了1，表示扫描到一个新的关键字，因此needKeyCnt减1。</p>
<p><strong>5.</strong>当needKeyCnt变成0时，表示扫描到了全部的关键字了。此时要进行一个操作：链表头优化。链表头指向的word是摘要的起始点，可是如果对应的KeyHash结构中的cnt大于1，表示扫描到的摘要中还有该关键字，因此可以跳过该关键字。因此，此时将链表头更新为下一个关键字，同时，将对应的KeyHash中的结构中的cnt减1，重复这样的检查，直至某个链表头对应的KeyHash结构中的cnt为1，此时该结构不能够少了。</p>
<p><strong>6.</strong>如果找到更短的minLength，则更新minLength和minStartPos。</p>
<p><strong>7.</strong>开始新一轮的搜索。此时摘除链表的第一个节点，将needKeyCnt加1，将下一个节点作为链表头，同样的开始链表头优化措施。搜索从上一次的搜索结束处开始，不用回溯。就是所，搜索在整个算法的过程中是一直沿着文章向下的，不会回溯，直至文章搜索完毕。</p>
<p>这样的算法的复杂度初步估计是O(M+N)。</p>
<p><strong>8.</strong>另外，我觉得该问题不具备实际意义，要具备实际意义，摘要应该包含完整的句子，所以摘要的起始和结束点应该以句号作为分隔。</p>
<p>这里，新建立一个结构：Sentence，结构体如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> Sentence
{
  <span class="dt">int</span> start; <span class="co">//句子的起始位置</span>
  <span class="dt">int</span> end; <span class="co">//句子的结束位置</span>
  KeyWord* startKey; <span class="co">//句子包含的起始关键字</span>
  KeyWord* endKey; <span class="co">//句子包含的结束关键字</span>
  Sentence* prev; <span class="co">//下一个句子结构</span>
  Sentence* next; <span class="co">//前一个句子结构</span>
}</code></pre>
<p>扫描到的多个句子结构组成一个链表。增加两个全局变量，分别指向了Sentence链表的头和尾。</p>
<p>扫描时，建立关键字链表时，也要建立Sentence链表。当扫描到包含了所有的关键字时，必须要扫描到一个完整句子的结束。开始做Sentence头节点优化。做法是：查看Sentence结构中的全部key结构，如果全部的key对应的KeyHash结构的cnt属性全部大于1，表明该句子是多余的，去掉它，去掉它的时候更新对应的HashKey结构的关键字，因为减去了很多的关键字。然后对下一个Sentence结构做同样的操作，直至某个Sentence结构是必不可少的，就是说它包含了当前的摘要中只出现过一次的关键字！</p>
<p>扫描到了一个摘要后，在开始新的扫描。更新Sentence链表的头结点为下一个节点，同时更新对应的KeyHash结构中的cnt关键字，当某个cnt变成0时，就递增needKeycnt变量。再次扫描时仍然是从当前的结束位置开始扫描。</p>
<p>初步估计时间也是O(M+N)。</p>
<p>ok，留下一个编程之美一书上的扩展问题：当搜索一个词语后，有许多的相似页面出现，如何判断两个页面相似，从而在搜索结果中隐去这类结果？</p>
<h1 id="第二十三章杨氏矩阵查找">第二十三章：杨氏矩阵查找</h1>
<p>作者：July、yansha。编程艺术室出品。</p>
<p>出处：结构之法算法之道</p>
<h2 id="题目">题目：</h2>
<p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>例如下面的二维数组就是每行、每列都递增排序。如果在这个数组中查找数字6，则返回true；如果查找数字5，由于数组不含有该数字，则返回false。</p>
<figure>
<img src="../images/23~24/23.1.gif" alt="img" /><figcaption>img</figcaption>
</figure>
<p>本Young问题解法有二（如查找数字6）：</p>
<ol type="1">
<li><p>分治法，分为四个矩形，配以二分查找，如果要找的数是6介于对角线上相邻的两个数4、10，可以排除掉左上和右下的两个矩形，而递归在左下和右上的两个矩形继续找，如下图所示：<br /><img src="../images/23~24/23.2.gif" alt="img" /></p></li>
<li><p>定位法，时间复杂度O（m+n）。首先直接定位到最右上角的元素，再配以二分查找，比要找的数（6）大就往左走，比要找数（6）的小就往下走，直到找到要找的数字（6）为止，如下图所示：<br /><img src="../images/23~24/23.3.gif" alt="img" /></p></li>
</ol>
<p>上述方法二的关键代码+程序运行如下图所示：<br /><img src="../images/23~24/23.4.gif" alt="img" /></p>
<p>试问，上述算法复杂么？不复杂，只要稍微动点脑筋便能想到，还可以参看友人老梦的文章，Young氏矩阵：<a href="http://blog.csdn.net/zhanglei8893/article/details/6234564">http://blog.csdn.net/zhanglei8893/article/details/6234564</a>，以及IT练兵场的：<a href="http://www.jobcoding.com/array/matrix/young-tableau-problem/">http://www.jobcoding.com/array/matrix/young-tableau-problem/</a>，除此之外，何海涛先生一书剑指offer中也收集了此题，感兴趣的朋友也可以去看看。</p>
<h1 id="第二十四章倒排索引关键词不重复hash编码">第二十四章：倒排索引关键词不重复Hash编码</h1>
<p>作者：July、yansha。编程艺术室出品。</p>
<p>出处：结构之法算法之道</p>
<p>本章要介绍这样一个问题，对倒排索引中的关键词进行编码。那么，这个问题将分为两个个步骤：</p>
<ol type="1">
<li>首先，要提取倒排索引内词典文件中的关键词；</li>
<li>对提取出来的关键词进行编码。本章采取hash编码的方式。既然要用hash编码，那么最重要的就是要解决hash冲突的问题，下文会详细介绍。</li>
</ol>
<p>有一点必须提醒读者的是，倒排索引包含词典和倒排记录表两个部分，词典一般有词项（或称为关键词）和词项频率（即这个词项或关键词出现的次数），倒排记录表则记录着上述词项（或关键词）所出现的位置，或出现的文档及网页ID等相关信息。</p>
<h2 id="正排索引与倒排索引">24.1、正排索引与倒排索引</h2>
<p>咱们先来看什么是倒排索引，以及倒排索引与正排索引之间的区别：</p>
<p>我们知道，搜索引擎的关键步骤就是建立倒排索引，所谓倒排索引一般表示为一个关键词，然后是它的频度（出现的次数），位置（出现在哪一篇文章或网页中，及有关的日期，作者等信息），它相当于为互联网上几千亿页网页做了一个索引，好比一本书的目录、标签一般。读者想看哪一个主题相关的章节，直接根据目录即可找到相关的页面。不必再从书的第一页到最后一页，一页一页的查找。</p>
<p>接下来，阐述下正排索引与倒排索引的区别：</p>
<h2 id="一般索引正排索引">一般索引（正排索引）</h2>
<p>正排表是以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时扫描表中每个文档中字的信息直到找出所有包含查询关键字的文档。正排表结构如图1所示，这种组织方法在建立索引的时候结构比较简单，建立比较方便且易于维护;因为索引是基于文档建立的，若是有新的文档假如，直接为该文档建立一个新的索引块，挂接在原来索引文件的后面。若是有文档删除，则直接找到该文档号文档对因的索引信息，将其直接删除。但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。</p>
<p>尽管正排表的工作原理非常的简单，但是由于其检索效率太低，除非在特定情况下，否则实用性价值不大。<br /><img src="../images/23~24/24.1.gif" alt="img" /></p>
<h2 id="倒排索引">倒排索引</h2>
<p>倒排表以字或词为关键字进行索引，表中关键字所对应的记录表项记录了出现这个字或词的所有文档，一个表项就是一个字表段，它记录该文档的ID和字符在该文档中出现的位置情况。由于每个字或词对应的文档数量在动态变化，所以倒排表的建立和维护都较为复杂，但是在查询的时候由于可以一次得到查询关键字所对应的所有文档，所以效率高于正排表。在全文检索中，检索的快速响应是一个最为关键的性能，而索引建立由于在后台进行，尽管效率相对低一些，但不会影响整个搜索引擎的效率。</p>
<p>倒排表的结构图如图2：<br /><img src="../images/23~24/24.2.gif" alt="img" /></p>
<p>倒排表的索引信息保存的是字或词后继数组模型、互关联后继数组模型条在文档内的位置，在同一篇文档内相邻的字或词条的前后关系没有被保存到索引文件内。</p>
<h2 id="倒排索引中提取关键词">24.2、倒排索引中提取关键词</h2>
<p>倒排索引是搜索引擎之基石。建成了倒排索引后，用户要查找某个query，如在搜索框输入某个关键词：“结构之法”后，搜索引擎不会再次使用爬虫又一个一个去抓取每一个网页，从上到下扫描网页，看这个网页有没有出现这个关键词，而是会在它预先生成的倒排索引文件中查找和匹配包含这个关键词“结构之法”的所有网页。找到了之后，再按相关性度排序，最终把排序后的结果显示给用户。<br /><img src="../images/23~24/24.3.gif" alt="img" /></p>
<p>如下，即是一个倒排索引文件（不全），我们把它取名为big_index，<img src="../images/23~24/24.4.gif" alt="img" />文件中每一较短的，不包含有“#####”符号的便是某个关键词，及这个关键词的出现次数。现在要从这个大索引文件中提取出这些关键词，--Firelf--，-11，-Winter-，.，007，007：天降杀机，02Chan..如何做到呢？一行一行的扫描整个索引文件么？</p>
<p>何意？之前已经说过：倒排索引包含词典和倒排记录表两个部分，词典一般有词项（或称为关键词）和词项频率（即这个词项或关键词出现的次数），倒排记录表则记录着上述词项（或关键词）所出现的位置，或出现的文档及网页ID等相关信息。</p>
<p>最简单的讲，就是要提取词典中的词项（关键词）：--Firelf--，-11，-Winter-，.，007，007：天降杀机，02Chan...。</p>
<p>--Firelf--（关键词）8（出现次数）<br /><img src="../images/23~24/24.5.gif" alt="img" /></p>
<p>我们可以试着这么解决：通过查找#####便可判断某一行出现的词是不是关键词，但如果这样做的话，便要扫描整个索引文件的每一行，代价实在巨大。如何提高速度呢？对了，关键词后面的那个出现次数为我们问题的解决起到了很好的作用，如下注释所示：</p>
<p>// 本身没有##### 的行判定为关键词行，后跟这个关键词的行数N（即词项频率） // 接下来，截取关键词--Firelf--，然后读取后面关键词的行数N // 再跳过N行（滤过和避免扫描中间的倒排记录表信息） // 读取下一个关键词..</p>
<p>有朋友指出，上述方法虽然减少了扫描的行数，但并没有减少I0开销。读者是否有更好地办法？欢迎随时交流。</p>
<h2 id="为提取出来的关键词编码">24.3、为提取出来的关键词编码</h2>
<p>爱思考的朋友可能会问，上述从倒排索引文件中提取出那些关键词（词项）的操作是为了什么呢？其实如我个人微博上12月12日所述的Hash词典编码：</p>
<p>词典文件的编码：1、词典怎么生成（存储和构造词典）；2、如何运用hash对输入的汉字进行编码；3、如何更好的解决冲突，即不重复以及追加功能。具体例子为：事先构造好词典文件后，输入一个词，要求找到这个词的编码，然后将其编码输出。且要有不断能添加词的功能，不得重复。</p>
<p>步骤应该是如下：1、读索引文件；2、提取索引中的词出来；3、词典怎么生成，存储和构造词典；4、词典文件的编码：不重复与追加功能。编码比如，输入中国，他的编码可以为10001，然后输入银行，他的编码可以为10002。只要实现不断添加词功能，以及不重复即可，词典类的大文件，hash最重要的是怎样避免冲突。</p>
<p>也就是说，现在我要对上述提取出来后的关键词进行编码，采取何种方式编码呢？暂时用hash函数编码。编码之后的效果将是每一个关键词都有一个特定的编码，如下图所示（与上文big_index文件比较一下便知）：</p>
<p>--Firelf-- 对应编码为：135942</p>
<p>-11 对应编码为：106101</p>
<p>....<br /><img src="../images/23~24/24.6.gif" alt="img" /></p>
<p>但细心的朋友一看上图便知，其中第34~39行显示，有重复的编码，那么如何解决这个不重复编码的问题呢？ 用hash表编码？但其极易产生冲突碰撞，为什么？请看：</p>
<p>哈希表是一种查找效率极高的数据结构，很多语言都在内部实现了哈希表。PHP中的哈希表是一种极为重要的数据结构，不但用于表示Array数据类型，还在Zend虚拟机内部用于存储上下文环境信息（执行上下文的变量及函数均使用哈希表结构存储）。</p>
<p>理想情况下哈希表插入和查找操作的时间复杂度均为O(1)，任何一个数据项可以在一个与哈希表长度无关的时间内计算出一个哈希值（key），然后在常量时间内定位到一个桶（术语bucket，表示哈希表中的一个位置）。当然这是理想情况下，因为任何哈希表的长度都是有限的，所以一定存在不同的数据项具有相同哈希值的情况，此时不同数据项被定为到同一个桶，称为碰撞（collision）。</p>
<p>哈希表的实现需要解决碰撞问题，碰撞解决大体有两种思路，</p>
<ol type="1">
<li>第一种是根据某种原则将被碰撞数据定为到其它桶，例如线性探测——如果数据在插入时发生了碰撞，则顺序查找这个桶后面的桶，将其放入第一个没有被使用的桶；</li>
<li>第二种策略是每个桶不是一个只能容纳单个数据项的位置，而是一个可容纳多个数据的数据结构（例如链表或红黑树），所有碰撞的数据以某种数据结构的形式组织起来。</li>
</ol>
<p>不论使用了哪种碰撞解决策略，都导致插入和查找操作的时间复杂度不再是O(1)。以查找为例，不能通过key定位到桶就结束，必须还要比较原始key（即未做哈希之前的key）是否相等，如果不相等，则要使用与插入相同的算法继续查找，直到找到匹配的值或确认数据不在哈希表中。</p>
<p>PHP是使用单链表存储碰撞的数据，因此实际上PHP哈希表的平均查找复杂度为O(L)，其中L为桶链表的平均长度；而最坏复杂度为O(N)，此时所有数据全部碰撞，哈希表退化成单链表。下图PHP中正常哈希表和退化哈希表的示意图。<br /><img src="../images/23~24/24.7.gif" alt="img" /></p>
<p>哈希表碰撞攻击就是通过精心构造数据，使得所有数据全部碰撞，人为将哈希表变成一个退化的单链表，此时哈希表各种操作的时间均提升了一个数量级，因此会消耗大量CPU资源，导致系统无法快速响应请求，从而达到拒绝服务攻击（DoS）的目的。</p>
<p>可以看到，进行哈希碰撞攻击的前提是哈希算法特别容易找出碰撞，如果是MD5或者SHA1那基本就没戏了，幸运的是（也可以说不幸的是）大多数编程语言使用的哈希算法都十分简单（这是为了效率考虑），因此可以不费吹灰之力之力构造出攻击数据.（上述五段文字引自：<a href="http://www.codinglabs.org/html/hash-collisions-attack-on-php.html">http://www.codinglabs.org/html/hash-collisions-attack-on-php.html</a>）。</p>
<h2 id="暴雪的hash算法">24.4、暴雪的Hash算法</h2>
<p>值得一提的是，在解决Hash冲突的时候，搞的焦头烂额，结果今天上午在自己的博客内的一篇文章（<a href="http://blog.csdn.net/v_JULY_v/archive/2011/03/17/6256463.aspx">十一、从头到尾彻底解析Hash表算法</a>）内找到了解决办法：网上流传甚广的暴雪的Hash算法。 OK，接下来，咱们回顾下暴雪的hash表算法：</p>
<blockquote>
<p>接下来，咱们来具体分析一下一个最快的Hash表算法。</p>
</blockquote>
<blockquote>
<p>我们由一个简单的问题逐步入手：有一个庞大的字符串数组，然后给你一个单独的字符串，让你从这个数组中查找是否有这个字符串并找到它，你会怎么做？</p>
</blockquote>
<blockquote>
<p>有一个方法最简单，老老实实从头查到尾，一个一个比较，直到找到为止，我想只要学过程序设计的人都能把这样一个程序作出来，但要是有程序员把这样的程序交给用户，我只能用无语来评价，或许它真的能工作，但...也只能如此了。</p>
</blockquote>
<blockquote>
<p>最合适的算法自然是使用HashTable（哈希表），先介绍介绍其中的基本知识，所谓Hash，一般是一个整数，通过某种算法，可以把一个字符串&quot;压缩&quot; 成一个整数。当然，无论如何，一个32位整数是无法对应回一个字符串的，但在程序中，两个字符串计算出的Hash值相等的可能非常小，下面看看在MPQ中的Hash算法：</p>
</blockquote>
<blockquote>
<p>函数prepareCryptTable以下的函数生成一个长度为0x500（合10进制数：1280）的cryptTable[0x500]</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//函数prepareCryptTable以下的函数生成一个长度为0x500（合10进制数：1280）的cryptTable[0x500]  </span>
<span class="dt">void</span> prepareCryptTable()  
{   
    <span class="dt">unsigned</span> <span class="dt">long</span> seed = <span class="bn">0x00100001</span>, index1 = <span class="dv">0</span>, index2 = <span class="dv">0</span>, i;  
  
    <span class="kw">for</span>( index1 = <span class="dv">0</span>; index1 &lt; <span class="bn">0x100</span>; index1++ )  
    {   
        <span class="kw">for</span>( index2 = index1, i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++, index2 += <span class="bn">0x100</span> )  
        {   
            <span class="dt">unsigned</span> <span class="dt">long</span> temp1, temp2;  
  
            seed = (seed * <span class="dv">125</span> + <span class="dv">3</span>) % <span class="bn">0x2AAAAB</span>;  
            temp1 = (seed &amp; <span class="bn">0xFFFF</span>) &lt;&lt; <span class="bn">0x10</span>;  
  
            seed = (seed * <span class="dv">125</span> + <span class="dv">3</span>) % <span class="bn">0x2AAAAB</span>;  
            temp2 = (seed &amp; <span class="bn">0xFFFF</span>);  
  
            cryptTable[index2] = ( temp1 | temp2 );   
        }   
    }   
}   </code></pre>
<blockquote>
<p>函数HashString以下函数计算lpszFileName 字符串的hash值，其中dwHashType 为hash的类型，</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//函数HashString以下函数计算lpszFileName 字符串的hash值，其中dwHashType 为hash的类型，  </span>
<span class="dt">unsigned</span> <span class="dt">long</span> HashString(<span class="dt">const</span> <span class="dt">char</span> *lpszkeyName, <span class="dt">unsigned</span> <span class="dt">long</span> dwHashType )  
{  
    <span class="dt">unsigned</span> <span class="dt">char</span> *key  = (<span class="dt">unsigned</span> <span class="dt">char</span> *)lpszkeyName;  
    <span class="dt">unsigned</span> <span class="dt">long</span> seed1 = <span class="bn">0x7FED7FED</span>;  
    <span class="dt">unsigned</span> <span class="dt">long</span> seed2 = <span class="bn">0xEEEEEEEE</span>;  
    <span class="dt">int</span> ch;  
  
    <span class="kw">while</span>( *key != <span class="dv">0</span> )  
    {  
        ch = *key++;  
        seed1 = cryptTable[(dwHashType&lt;&lt;<span class="dv">8</span>) + ch] ^ (seed1 + seed2);  
        seed2 = ch + seed1 + seed2 + (seed2&lt;&lt;<span class="dv">5</span>) + <span class="dv">3</span>;  
    }  
    <span class="kw">return</span> seed1;  
} </code></pre>
<blockquote>
<p>Blizzard的这个算法是非常高效的，被称为&quot;One-Way Hash&quot;( A one-way hash is a an algorithm that is constructed in such a way that deriving the original string (set of strings, actually) is virtually impossible)。举个例子，字符串&quot;unitneutralacritter.grp&quot;通过这个算法得到的结果是0xA26067F3。</p>
</blockquote>
<blockquote>
<p>是不是把第一个算法改进一下，改成逐个比较字符串的Hash值就可以了呢，答案是，远远不够，要想得到最快的算法，就不能进行逐个的比较，通常是构造一个哈希表(Hash Table)来解决问题，哈希表是一个大数组，这个数组的容量根据程序的要求来定义，</p>
</blockquote>
<blockquote>
<p>例如1024，每一个Hash值通过取模运算 (mod) 对应到数组中的一个位置，这样，只要比较这个字符串的哈希值对应的位置有没有被占用，就可以得到最后的结果了，想想这是什么速度？是的，是最快的O(1)，现在仔细看看这个算法吧：</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span>  
{  
    <span class="dt">int</span> nHashA;  
    <span class="dt">int</span> nHashB;  
    <span class="dt">char</span> bExists;  
   ......  
} SOMESTRUCTRUE;  
<span class="co">//一种可能的结构体定义？</span></code></pre>
<blockquote>
<p>函数GetHashTablePos下述函数为在Hash表中查找是否存在目标字符串，有则返回要查找字符串的Hash值，无则，return -1.</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//函数GetHashTablePos下述函数为在Hash表中查找是否存在目标字符串，有则返回要查找字符串的Hash值，无则，return -1.  </span>
<span class="dt">int</span> GetHashTablePos( har *lpszString, SOMESTRUCTURE *lpTable )   
<span class="co">//lpszString要在Hash表中查找的字符串，lpTable为存储字符串Hash值的Hash表。  </span>
{   
    <span class="dt">int</span> nHash = HashString(lpszString);  <span class="co">//调用上述函数HashString，返回要查找字符串lpszString的Hash值。  </span>
    <span class="dt">int</span> nHashPos = nHash % nTableSize;  
   
    <span class="kw">if</span> ( lpTable[nHashPos].bExists  &amp;&amp;  !strcmp( lpTable[nHashPos].pString, lpszString ) )   
    {  <span class="co">//如果找到的Hash值在表中存在，且要查找的字符串与表中对应位置的字符串相同，  </span>
        <span class="kw">return</span> nHashPos;    <span class="co">//返回找到的Hash值  </span>
    }   
    <span class="kw">else</span>  
    {  
        <span class="kw">return</span> -<span class="dv">1</span>;    
    }   
}  </code></pre>
<blockquote>
<p>看到此，我想大家都在想一个很严重的问题：“如果两个字符串在哈希表中对应的位置相同怎么办？”,毕竟一个数组容量是有限的，这种可能性很大。解决该问题的方法很多，我首先想到的就是用“链表”,感谢大学里学的数据结构教会了这个百试百灵的法宝，我遇到的很多算法都可以转化成链表来解决，只要在哈希表的每个入口挂一个链表，保存所有对应的字符串就OK了。事情到此似乎有了完美的结局，如果是把问题独自交给我解决，此时我可能就要开始定义数据结构然后写代码了。 然而Blizzard的程序员使用的方法则是更精妙的方法。基本原理就是：他们在哈希表中不是用一个哈希值而是用三个哈希值来校验字符串。</p>
</blockquote>
<blockquote>
<p>MPQ使用文件名哈希表来跟踪内部的所有文件。但是这个表的格式与正常的哈希表有一些不同。首先，它没有使用哈希作为下标，把实际的文件名存储在表中用于验证，实际上它根本就没有存储文件名。而是使用了3种不同的哈希：一个用于哈希表的下标，两个用于验证。这两个验证哈希替代了实际文件名。</p>
</blockquote>
<blockquote>
<p>当然了，这样仍然会出现2个不同的文件名哈希到3个同样的哈希。但是这种情况发生的概率平均是：1:18889465931478580854784，这个概率对于任何人来说应该都是足够小的。现在再回到数据结构上，Blizzard使用的哈希表没有使用链表，而采用&quot;顺延&quot;的方式来解决问题。”下面，咱们来看看这个网上流传甚广的暴雪hash算法：</p>
</blockquote>
<p>函数GetHashTablePos中，lpszString 为要在hash表中查找的字符串；lpTable 为存储字符串hash值的hash表；nTableSize 为hash表的长度：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//函数GetHashTablePos中，lpszString 为要在hash表中查找的字符串；lpTable 为存储字符串hash值的hash表；nTableSize 为hash表的长度：   </span>
<span class="dt">int</span> GetHashTablePos( <span class="dt">char</span> *lpszString, MPQHASHTABLE *lpTable, <span class="dt">int</span> nTableSize )  
{  
    <span class="dt">const</span> <span class="dt">int</span>  HASH_OFFSET = <span class="dv">0</span>, HASH_A = <span class="dv">1</span>, HASH_B = <span class="dv">2</span>;  
   
    <span class="dt">int</span>  nHash = HashString( lpszString, HASH_OFFSET );  
    <span class="dt">int</span>  nHashA = HashString( lpszString, HASH_A );  
    <span class="dt">int</span>  nHashB = HashString( lpszString, HASH_B );  
    <span class="dt">int</span>  nHashStart = nHash % nTableSize;  
    <span class="dt">int</span>  nHashPos = nHashStart;  
   
    <span class="kw">while</span> ( lpTable[nHashPos].bExists )  
   {  
<span class="co">//     如果仅仅是判断在该表中时候存在这个字符串，就比较这两个hash值就可以了，不用对结构体中的字符串进行比较。  </span>
<span class="co">//         这样会加快运行的速度？减少hash表占用的空间？这种方法一般应用在什么场合？  </span>
        <span class="kw">if</span> ( 　 lpTable[nHashPos].nHashA == nHashA  
        &amp;&amp;  lpTable[nHashPos].nHashB == nHashB )  
       {  
            <span class="kw">return</span> nHashPos;  
       }  
       <span class="kw">else</span>  
       {  
            nHashPos = (nHashPos + <span class="dv">1</span>) % nTableSize;  
       }  
   
        <span class="kw">if</span> (nHashPos == nHashStart)  
              <span class="kw">break</span>;  
    }  
     <span class="kw">return</span> -<span class="dv">1</span>;  
}  </code></pre>
<p>上述程序解释：</p>
<ol type="1">
<li>计算出字符串的三个哈希值（一个用来确定位置，另外两个用来校验)<br /></li>
<li>察看哈希表中的这个位置<br /></li>
<li>哈希表中这个位置为空吗？如果为空，则肯定该字符串不存在，返回-1。<br /></li>
<li>如果存在，则检查其他两个哈希值是否也匹配，如果匹配，则表示找到了该字符串，返回其Hash值。<br /></li>
<li>移到下一个位置，如果已经移到了表的末尾，则反绕到表的开始位置起继续查询<br /></li>
<li>看看是不是又回到了原来的位置，如果是，则返回没找到<br /></li>
<li>回到3。</li>
</ol>
<h2 id="不重复hash编码">24.5、不重复Hash编码</h2>
<p>有了上面的暴雪Hash算法。咱们的问题便可解决了。不过，有两点必须先提醒读者：<br />1. Hash表起初要初始化；<br />2. 暴雪的Hash算法对于查询那样处理可以，但对插入就不能那么解决。</p>
<p>关键主体代码如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//函数prepareCryptTable以下的函数生成一个长度为0x500（合10进制数：1280）的cryptTable[0x500]  </span>
<span class="dt">void</span> prepareCryptTable()  
{  
    <span class="dt">unsigned</span> <span class="dt">long</span> seed = <span class="bn">0x00100001</span>, index1 = <span class="dv">0</span>, index2 = <span class="dv">0</span>, i;  
  
    <span class="kw">for</span>( index1 = <span class="dv">0</span>; index1 &lt;<span class="bn">0x100</span>; index1++ )  
    {  
        <span class="kw">for</span>( index2 = index1, i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++, index2 += <span class="bn">0x100</span>)  
        {  
            <span class="dt">unsigned</span> <span class="dt">long</span> temp1, temp2;  
            seed = (seed * <span class="dv">125</span> + <span class="dv">3</span>) % <span class="bn">0x2AAAAB</span>;  
            temp1 = (seed &amp; <span class="bn">0xFFFF</span>)&lt;&lt;<span class="bn">0x10</span>;  
            seed = (seed * <span class="dv">125</span> + <span class="dv">3</span>) % <span class="bn">0x2AAAAB</span>;  
            temp2 = (seed &amp; <span class="bn">0xFFFF</span>);  
            cryptTable[index2] = ( temp1 | temp2 );  
        }  
    }  
}  
  
<span class="co">//函数HashString以下函数计算lpszFileName 字符串的hash值，其中dwHashType 为hash的类型，  </span>
<span class="dt">unsigned</span> <span class="dt">long</span> HashString(<span class="dt">const</span> <span class="dt">char</span> *lpszkeyName, <span class="dt">unsigned</span> <span class="dt">long</span> dwHashType )  
{  
    <span class="dt">unsigned</span> <span class="dt">char</span> *key  = (<span class="dt">unsigned</span> <span class="dt">char</span> *)lpszkeyName;  
    <span class="dt">unsigned</span> <span class="dt">long</span> seed1 = <span class="bn">0x7FED7FED</span>;  
    <span class="dt">unsigned</span> <span class="dt">long</span> seed2 = <span class="bn">0xEEEEEEEE</span>;  
    <span class="dt">int</span> ch;  
  
    <span class="kw">while</span>( *key != <span class="dv">0</span> )  
    {  
        ch = *key++;  
        seed1 = cryptTable[(dwHashType&lt;&lt;<span class="dv">8</span>) + ch] ^ (seed1 + seed2);  
        seed2 = ch + seed1 + seed2 + (seed2&lt;&lt;<span class="dv">5</span>) + <span class="dv">3</span>;  
    }  
    <span class="kw">return</span> seed1;  
}  
  
<span class="co">/////////////////////////////////////////////////////////////////////  </span>
<span class="co">//function: 哈希词典 编码  </span>
<span class="co">//parameter:  </span>
<span class="co">//author: lei.zhou  </span>
<span class="co">//time: 2011-12-14  </span>
<span class="co">/////////////////////////////////////////////////////////////////////  </span>
MPQHASHTABLE TestHashTable[nTableSize];  
<span class="dt">int</span> TestHashCTable[nTableSize];  
<span class="dt">int</span> TestHashDTable[nTableSize];  
key_list test_data[nTableSize];  
  
<span class="co">//直接调用上面的hashstring，nHashPos就是对应的HASH值。  </span>
<span class="dt">int</span> insert_string(<span class="dt">const</span> <span class="dt">char</span> *string_in)  
{  
    <span class="dt">const</span> <span class="dt">int</span> HASH_OFFSET = <span class="dv">0</span>, HASH_C = <span class="dv">1</span>, HASH_D = <span class="dv">2</span>;  
    <span class="dt">unsigned</span> <span class="dt">int</span> nHash = HashString(string_in, HASH_OFFSET);  
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashC = HashString(string_in, HASH_C);  
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashD = HashString(string_in, HASH_D);  
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashStart = nHash % nTableSize;  
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashPos = nHashStart;  
    <span class="dt">int</span> ln, ires = <span class="dv">0</span>;  
  
    <span class="kw">while</span> (TestHashTable[nHashPos].bExists)  
    {  
<span class="co">//      if (TestHashCTable[nHashPos]  == (int) nHashC &amp;&amp; TestHashDTable[nHashPos] == (int) nHashD)  </span>
<span class="co">//          break;  </span>
<span class="co">//      //...  </span>
<span class="co">//      else  </span>
        <span class="co">//如之前所提示读者的那般，暴雪的Hash算法对于查询那样处理可以，但对插入就不能那么解决  </span>
            nHashPos = (nHashPos + <span class="dv">1</span>) % nTableSize;  
  
        <span class="kw">if</span> (nHashPos == nHashStart)  
            <span class="kw">break</span>;  
    }  
  
    ln = strlen(string_in);  
    <span class="kw">if</span> (!TestHashTable[nHashPos].bExists &amp;&amp; (ln &lt; nMaxStrLen))  
    {   
        TestHashCTable[nHashPos] = nHashC;  
        TestHashDTable[nHashPos] = nHashD;  
  
        test_data[nHashPos] = (KEYNODE *) malloc (<span class="kw">sizeof</span>(KEYNODE) * <span class="dv">1</span>);  
        <span class="kw">if</span>(test_data[nHashPos] == NULL)  
        {  
            printf(<span class="st">&quot;10000 EMS ERROR !!!!</span><span class="ch">\n</span><span class="st">&quot;</span>);  
            <span class="kw">return</span> <span class="dv">0</span>;  
        }  
  
        test_data[nHashPos]-&gt;pkey = (<span class="dt">char</span> *)malloc(ln<span class="dv">+1</span>);  
        <span class="kw">if</span>(test_data[nHashPos]-&gt;pkey == NULL)  
        {  
            printf(<span class="st">&quot;10000 EMS ERROR !!!!</span><span class="ch">\n</span><span class="st">&quot;</span>);  
            <span class="kw">return</span> <span class="dv">0</span>;  
        }  
  
        memset(test_data[nHashPos]-&gt;pkey, <span class="dv">0</span>, ln<span class="dv">+1</span>);  
        strncpy(test_data[nHashPos]-&gt;pkey, string_in, ln);  
        *((test_data[nHashPos]-&gt;pkey)+ln) = <span class="dv">0</span>;  
        test_data[nHashPos]-&gt;weight = nHashPos;  
  
        TestHashTable[nHashPos].bExists = <span class="dv">1</span>;  
    }  
    <span class="kw">else</span>  
    {  
        <span class="kw">if</span>(TestHashTable[nHashPos].bExists)  
            printf(<span class="st">&quot;30000 in the hash table %s !!!</span><span class="ch">\n</span><span class="st">&quot;</span>, string_in);  
        <span class="kw">else</span>  
            printf(<span class="st">&quot;90000 strkey error !!!</span><span class="ch">\n</span><span class="st">&quot;</span>);  
    }  
    <span class="kw">return</span> nHashPos;  
}</code></pre>
<p>接下来要读取索引文件big_index对其中的关键词进行编码（为了简单起见，直接一行一行扫描读写，没有跳过行数了）：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> bigIndex_hash(<span class="dt">const</span> <span class="dt">char</span> *docpath, <span class="dt">const</span> <span class="dt">char</span> *hashpath)  
{  
    FILE *fr, *fw;  
    <span class="dt">int</span> len;  
    <span class="dt">char</span> *pbuf, *p;  
    <span class="dt">char</span> dockey[TERM_MAX_LENG];  
  
    <span class="kw">if</span>(docpath == NULL || *docpath == &#39;\<span class="dv">0</span>&#39;)  
        <span class="kw">return</span>;  
  
    <span class="kw">if</span>(hashpath == NULL || *hashpath == &#39;\<span class="dv">0</span>&#39;)  
        <span class="kw">return</span>;  
  
    fr = fopen(docpath, <span class="st">&quot;rb&quot;</span>);  <span class="co">//读取文件docpath  </span>
    fw = fopen(hashpath, <span class="st">&quot;wb&quot;</span>);  
    <span class="kw">if</span>(fr == NULL || fw == NULL)  
    {  
        printf(<span class="st">&quot;open read or write file error!</span><span class="ch">\n</span><span class="st">&quot;</span>);  
        <span class="kw">return</span>;  
    }  
  
    pbuf = (<span class="dt">char</span>*)malloc(BUFF_MAX_LENG);  
    <span class="kw">if</span>(pbuf == NULL)  
    {  
        fclose(fr);  
        <span class="kw">return</span> ;  
    }  
  
    memset(pbuf, <span class="dv">0</span>, BUFF_MAX_LENG);  
  
    <span class="kw">while</span>(fgets(pbuf, BUFF_MAX_LENG, fr))  
    {  
        len = GetRealString(pbuf);  
        <span class="kw">if</span>(len &lt;= <span class="dv">1</span>)  
            <span class="kw">continue</span>;  
        p = strstr(pbuf, <span class="st">&quot;#####&quot;</span>);    
        <span class="kw">if</span>(p != NULL)  
            <span class="kw">continue</span>;  
  
        p = strstr(pbuf, <span class="st">&quot;  &quot;</span>);  
        <span class="kw">if</span> (p == NULL)  
        {  
            printf(<span class="st">&quot;file contents error!&quot;</span>);  
        }  
  
        len = p - pbuf;  
        dockey[<span class="dv">0</span>] = <span class="dv">0</span>;  
        strncpy(dockey, pbuf, len);  
  
        dockey[len] = <span class="dv">0</span>;        
  
        <span class="dt">int</span> num = insert_string(dockey);   
  
        dockey[len] = &#39; &#39;;  
        dockey[len<span class="dv">+1</span>] = &#39;\<span class="dv">0</span>&#39;;  
        <span class="dt">char</span> str[<span class="dv">20</span>];  
        itoa(num, str, <span class="dv">10</span>);  
  
        strcat(dockey, str);  
        dockey[len+strlen(str)+<span class="dv">1</span>] = &#39;\<span class="dv">0</span>&#39;;  
        fprintf (fw, <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, dockey);  
  
    }  
    free(pbuf);  
    fclose(fr);  
    fclose(fw);  
} </code></pre>
<p>主函数已经很简单了，如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()  
{  
    prepareCryptTable();  <span class="co">//Hash表起初要初始化  </span>
  
    <span class="co">//现在要把整个big_index文件插入hash表，以取得编码结果  </span>
    bigIndex_hash(<span class="st">&quot;big_index.txt&quot;</span>, <span class="st">&quot;hashpath.txt&quot;</span>);  
    system(<span class="st">&quot;pause&quot;</span>);  
  
    <span class="kw">return</span> <span class="dv">0</span>;  
}  </code></pre>
<p>程序运行后生成的hashpath.txt文件如下： <img src="../images/23~24/24.8.gif" alt="img" /></p>
<p>如上所示，采取暴雪的Hash算法并在插入的时候做适当处理，当再次对上文中的索引文件big_index进行Hash编码后，冲突问题已经得到初步解决。当然，还有待更进一步更深入的测试。</p>
<p>后续添上数目索引1~10000...</p>
<p>后来又为上述文件中的关键词编了码一个计数的内码，不过，奇怪的是，同样的代码，在Dev C++ 与VS2010上运行结果却不同（左边dev上计数从&quot;1&quot;开始，VS上计数从“1994014002”开始），如下图所示： <img src="../images/23~24/24.9.gif" alt="img" /></p>
<p>在上面的bigIndex_hashcode函数的基础上，修改如下，即可得到上面的效果：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> bigIndex_hashcode(<span class="dt">const</span> <span class="dt">char</span> *in_file_path, <span class="dt">const</span> <span class="dt">char</span> *out_file_path)  
{  
    FILE *fr, *fw;  
    <span class="dt">int</span> len, value;  
    <span class="dt">char</span> *pbuf, *pleft, *p;  
    <span class="dt">char</span> keyvalue[TERM_MAX_LENG], str[WORD_MAX_LENG];  
  
    <span class="kw">if</span>(in_file_path == NULL || *in_file_path == &#39;\<span class="dv">0</span>&#39;) {  
        printf(<span class="st">&quot;input file path error!</span><span class="ch">\n</span><span class="st">&quot;</span>);  
        <span class="kw">return</span>;  
    }  
  
    <span class="kw">if</span>(out_file_path == NULL || *out_file_path == &#39;\<span class="dv">0</span>&#39;) {  
        printf(<span class="st">&quot;output file path error!</span><span class="ch">\n</span><span class="st">&quot;</span>);  
        <span class="kw">return</span>;  
    }  
  
    fr = fopen(in_file_path, <span class="st">&quot;r&quot;</span>);  <span class="co">//读取in_file_path路径文件  </span>
    fw = fopen(out_file_path, <span class="st">&quot;w&quot;</span>);  
  
    <span class="kw">if</span>(fr == NULL || fw == NULL)  
    {  
        printf(<span class="st">&quot;open read or write file error!</span><span class="ch">\n</span><span class="st">&quot;</span>);  
        <span class="kw">return</span>;  
    }  
  
    pbuf = (<span class="dt">char</span>*)malloc(BUFF_MAX_LENG);  
    pleft = (<span class="dt">char</span>*)malloc(BUFF_MAX_LENG);  
    <span class="kw">if</span>(pbuf == NULL || pleft == NULL)  
    {  
        printf(<span class="st">&quot;allocate memory error!&quot;</span>);  
        fclose(fr);  
        <span class="kw">return</span> ;  
    }  
  
    memset(pbuf, <span class="dv">0</span>, BUFF_MAX_LENG);  
  
    <span class="dt">int</span> offset = <span class="dv">1</span>;  
    <span class="kw">while</span>(fgets(pbuf, BUFF_MAX_LENG, fr))  
    {  
        <span class="kw">if</span> (--offset &gt; <span class="dv">0</span>)  
            <span class="kw">continue</span>;  
  
        <span class="kw">if</span>(GetRealString(pbuf) &lt;= <span class="dv">1</span>)  
            <span class="kw">continue</span>;  
  
        p = strstr(pbuf, <span class="st">&quot;#####&quot;</span>);    
        <span class="kw">if</span>(p != NULL)  
            <span class="kw">continue</span>;  
  
        p = strstr(pbuf, <span class="st">&quot;  &quot;</span>);  
        <span class="kw">if</span> (p == NULL)  
        {  
            printf(<span class="st">&quot;file contents error!&quot;</span>);  
        }  
  
        len = p - pbuf;  
  
        <span class="co">// 确定跳过行数  </span>
        strcpy(pleft, p<span class="dv">+1</span>);   
        offset = atoi(pleft) + <span class="dv">1</span>;  
  
        strncpy(keyvalue, pbuf, len);    
        keyvalue[len] = &#39;\<span class="dv">0</span>&#39;;  
        value = insert_string(keyvalue);  
  
        <span class="kw">if</span> (value != -<span class="dv">1</span>) {  
  
            <span class="co">// key value中插入空格  </span>
            keyvalue[len] = &#39; &#39;;  
            keyvalue[len<span class="dv">+1</span>] = &#39;\<span class="dv">0</span>&#39;;  
  
            itoa(value, str, <span class="dv">10</span>);  
            strcat(keyvalue, str);  
  
            keyvalue[len+strlen(str)+<span class="dv">1</span>] = &#39; &#39;;  
            keyvalue[len+strlen(str)+<span class="dv">2</span>] = &#39;\<span class="dv">0</span>&#39;;  
  
            keysize++;  
            itoa(keysize, str, <span class="dv">10</span>);  
            strcat(keyvalue, str);  
  
            <span class="co">// 将key value写入文件  </span>
            fprintf (fw, <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, keyvalue);  
  
        }  
    }  
    free(pbuf);  
    fclose(fr);  
    fclose(fw);  
} </code></pre>
<h2 id="小结">小结</h2>
<p>本文有一点值得一提的是，在此前的这篇文章（<a href="http://blog.csdn.net/v_JULY_v/archive/2011/03/17/6256463.aspx">十一、从头到尾彻底解析Hash表算法</a>）之中，只是对Hash表及暴雪的Hash算法有过学习和了解，但尚未真正运用过它，而今在本章中体现，证明还是之前写的文章，及之前对Hash表等算法的学习还是有一定作用的。同时，也顺便对暴雪的Hash函数算是做了个测试，其的确能解决一般的冲突性问题，创造这个算法的人不简单呐。</p>
<h1 id="第二十五章二分查找实现">第二十五章：二分查找实现</h1>
<p>作者：July</p>
<p>出处：结构之法算法之道</p>
<h2 id="引言">引言</h2>
<p>Jon Bentley：90%以上的程序员无法正确无误的写出二分查找代码。也许很多人都早已听说过这句话，但我还是想引用《编程珠玑》上的如下几段文字：</p>
<p>二分查找可以解决（预排序数组的查找）问题：只要数组中包含T（即要查找的值），那么通过不断缩小包含T的范围，最终就可以找到它。一开始，范围覆盖整个数组。将数组的中间项与T进行比较，可以排除一半元素，范围缩小一半。就这样反复比较，反复缩小范围，最终就会在数组中找到T，或者确定原以为T所在的范围实际为空。对于包含N个元素的表，整个查找过程大约要经过log(2)N次比较。</p>
<p>多数程序员都觉得只要理解了上面的描述，写出代码就不难了；但事实并非如此。如果你不认同这一点，最好的办法就是放下书本，自己动手写一写。试试吧。</p>
<p>我在贝尔实验室和IBM的时候都出过这道考题。那些专业的程序员有几个小时的时间，可以用他们选择的语言把上面的描述写出来；写出高级伪代码也可以。考试结束后，差不多所有程序员都认为自己写出了正确的程序。于是，我们花了半个钟头来看他们编写的代码经过测试用例验证的结果。几次课，一百多人的结果相差无几：90%的程序员写的程序中有bug（我并不认为没有bug的代码就正确）。</p>
<p>我很惊讶：在足够的时间内，只有大约10%的专业程序员可以把这个小程序写对。但写不对这个小程序的还不止这些人：高德纳在《计算机程序设计的艺术 第3卷 排序和查找》第6.2.1节的“历史与参考文献”部分指出，虽然早在1946年就有人将二分查找的方法公诸于世，但直到1962年才有人写出没有bug的二分查找程序。 ”——乔恩·本特利，《编程珠玑（第1版）》第35-36页。</p>
<p><strong>你能正确无误的写出二分查找代码么？不妨一试。</strong></p>
<h2 id="二分查找代码">二分查找代码</h2>
<p>二分查找的原理想必不用多解释了，不过有一点必须提醒读者的是，二分查找是针对的排好序的数组。OK，纸上读来终觉浅，觉知此事要躬行。我先来写一份，下面是我写的一份二分查找的实现（之前去某一家公司面试也曾被叫当场实现二分查找，不过结果可能跟你一样，当时就未能完整无误写出），有任何问题或错误，恳请不吝指正：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//二分查找V0.1实现版</span>
<span class="co">//copyright@2011 July</span>

<span class="co">//首先要把握下面几个要点：</span>
<span class="co">//right = n-1 =&gt; while(left &lt;= right) =&gt; right = middle-1;</span>
<span class="co">//right = n   =&gt; while(left &lt;  right) =&gt; right = middle;</span>
<span class="co">//middle的计算不能写在while循环外，否则无法得到更新。</span>

<span class="dt">int</span> binary_search(<span class="dt">int</span> array[], <span class="dt">int</span> n, <span class="dt">int</span> value)
{
    <span class="dt">int</span> left = <span class="dv">0</span>;
    <span class="dt">int</span> right = n - <span class="dv">1</span>;
    <span class="co">//如果这里是int right = n 的话，那么下面有两处地方需要修改，以保证一一对应：</span>
    <span class="co">//1、下面循环的条件则是while(left &lt; right)</span>
    <span class="co">//2、循环内当 array[middle] &gt; value 的时候，right = mid</span>

    <span class="kw">while</span> (left &lt;= right)  <span class="co">//循环条件，适时而变</span>
    {
        <span class="dt">int</span> middle = left + ((right - left) &gt;&gt; <span class="dv">1</span>);  <span class="co">//防止溢出，移位也更高效。同时，每次循环都需要更新。</span>

        <span class="kw">if</span> (array[middle] &gt; value)
        {
            right = middle - <span class="dv">1</span>;  <span class="co">//right赋值，适时而变</span>
        }
        <span class="kw">else</span> <span class="kw">if</span>(array[middle] &lt; value)
        {
            left = middle + <span class="dv">1</span>;
        }
        <span class="kw">else</span>
            <span class="kw">return</span> middle;
        <span class="co">//可能会有读者认为刚开始时就要判断相等，但毕竟数组中不相等的情况更多</span>
        <span class="co">//如果每次循环都判断一下是否相等，将耗费时间</span>
    }
    <span class="kw">return</span> -<span class="dv">1</span>;
}</code></pre>
<p>简单测试下，运行结果如下所示（当然，一次测试正确不代表程序便0 bug了，且测试深度远远不够）：</p>
<figure>
<img src="../images/25.1.gif" alt="img" /><figcaption>img</figcaption>
</figure>
<h2 id="测试">测试</h2>
<p>也许你之前已经把二分查找实现过很多次了，但现在不妨再次测试一下。关闭所有网页，窗口，打开记事本，或者编辑器，或者直接在本文评论下，不参考上面我写的或其他任何人的程序，给自己十分钟到N个小时不等的时间，立即编写一个二分查找程序。</p>
<p>当然，能正确写出来不代表任何什么，不能正确写出来亦不代表什么，仅仅针对Jon Bentley的言论做一个简单的测试而已。</p>
<h2 id="总结">总结</h2>
<p>本文发表后，马上就有很多朋友自己尝试了。根据从朋友们在本文评论下留下的代码，发现出错率最高的在以下这么几个地方：</p>
<p>注释里已经说得很明白了，可还是会有不少朋友犯此类的错误：</p>
<pre><code>首先要把握下面几个要点：
right = n-1 =&gt; while(left &lt;= right) =&gt; right = middle-1;
middle的计算不能写在while循环外，否则无法得到更新。</code></pre>
<p>还有一个最最常犯的错误，具体可以参考<a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken</a>，其中提到了JDK5中该BUG：</p>
<pre><code>middle = (left+right)&gt;&gt;1; 这样的话left与right的值比较大的时候，其和可能溢出。</code></pre>
<p>这个也是错误的:</p>
<pre><code>right = n   =&gt; while(left &lt;  right) =&gt; right = middle;</code></pre>
<p>如果搜索数组中不存在的数字的时候,可能会导致死循环. 因为最后left = middle, right = middle + 1,这样每次更新left和middle总是不变的.</p>
<h1 id="第二十六章基于给定的文档生成倒排索引的编码与实践">第二十六章：基于给定的文档生成倒排索引的编码与实践</h1>
<p>作者：July、yansha。</p>
<p>出处：结构之法算法之道</p>
<p>** 第二十六章基于给定的文档生成倒排索引的编码与实践 **</p>
<ul>
<li>引言</li>
<li>第一节索引的构建方法</li>
<li>第二节Hash表的构建与实现</li>
<li>第三节倒排索引文件的生成与实现</li>
<li>第四节程序需求功能的改进</li>
<li>对相同日期与不同日期的处理</li>
<li>为关键词添上编码</li>
<li>第五节算法的二次改进</li>
<li>省去二次Hash</li>
<li>除去排序针对不同日期的记录直接插入</li>
<li>后记</li>
</ul>
<h4 id="引言-1">引言</h4>
<p>本周实现倒排索引。实现过程中，寻找资料，结果发现找份资料诸多不易：1、网上搜倒排索引实现，结果千篇一律，例子都是那几个同样的单词；2、到谷歌学术上想找点稍微有价值水平的资料，结果下篇论文还收费或者要求注册之类；3、大部分技术书籍只有理论，没有实践。于是，朋友戏言：网上一般有价值的东西不多。希望，本blog的出现能改变此现状。</p>
<p>在第二十四章、倒排索引关键词不重复Hash编码中，我们针对一个给定的倒排索引文件，提取出其中的关键词，然后针对这些关键词进行Hash不重复编码。本章，咱们再倒退一步，即给定一个正排文档（暂略过文本解析，分词等步骤，日后会慢慢考虑这些且一并予以实现），要求生成对应的倒排索引文件。同时，本章还是基于Hash索引之上（运用暴雪的Hash函数可以比较完美的解决大数据量下的冲突问题），日后自会实现B+树索引。</p>
<p>与此同时，本编程艺术系列逐步从为面试服务而转到实战性的编程当中了，教初学者如何编程，如何运用高效的算法解决实际应用中的编程问题，将逐步成为本编程艺术系列的主旨之一。</p>
<p>OK，接下来，咱们针对给定的正排文档一步一步来生成倒排索引文件，有任何问题，欢迎随时不吝赐教或批评指正。谢谢。</p>
<h4 id="第一节索引的构建方法">第一节、索引的构建方法</h4>
<ul>
<li>根据信息检索导论（Christtopher D.Manning等著，王斌译）一书给的提示，我们可以选择两种构建索引的算法：BSBI算法，与SPIMI算法。</li>
</ul>
<p>BSBI算法，基于磁盘的外部排序算法，此算法首先将词项映射成其ID的数据结构，如Hash映射。而后将文档解析成词项ID-文档ID对，并在内存中一直处理，直到累积至放满一个固定大小的块空间为止，我们选择合适的块大小，使之能方便加载到内存中并允许在内存中快速排序，快速排序后的块转换成倒排索引格式后写入磁盘。</p>
<pre><code>建立倒排索引的步骤如下：</code></pre>
<ul>
<li>将文档分割成几个大小相等的部分；</li>
<li>对词项ID-文档ID进行排序；</li>
<li>将具有同一词项ID的所有文档ID放到倒排记录表中，其中每条倒排记录仅仅是一个文档ID；</li>
<li>将基于块的倒排索引写到磁盘上。</li>
</ul>
<p>此算法假如说最后可能会产生10个块。其伪码如下：</p>
<pre><code>BSBI NDEXConSTRUCTION()
n &lt;- 0
while(all documents have not been processed)
    do n&lt;-n+1
        block &lt;- PARSENEXTBLOCK()    //文档分析
        BSBI-INVERT(block)
        WRITEBLOCKTODISK(block,fn)
        MERGEBLOCKS(f1,...,fn;fmerged)</code></pre>
<p>（基于块的排序索引算法，该算法将每个块的倒排索引文件存入文件f1,...,fn中，最后合并成fmerged 如果该算法应用最后一步产生了10个块，那么接下来便会将10个块索引同时合并成一个索引文件。）</p>
<p>合并时，同时打开所有块对应的文件，内存中维护了为10个块准备的读缓冲区和一个为最终合并索引准备的写缓冲区。每次迭代中，利用优先级队列（如堆结构或类似的数据结构）选择最小的未处理的词项ID进行处理。如下图所示（图片引自深入搜索引擎--海里信息的压缩、索引和查询，梁斌译），分块索引，分块排序，最终全部合并（说实话，跟MapReduce还是有些类似的）：</p>
<figure>
<img src="../images/26/26.1.gif" />
</figure>
<p>读入该词项的倒排记录表并合并，合并结果写回磁盘中。需要时，再次从文件中读入数据到每个读缓冲区（基于磁盘的外部排序算法的更多可以参考：程序员编程艺术 <a href="10.0.md">第十章、如何给10^7个数据量的磁盘文件排序</a>）。</p>
<p>BSBI算法主要的时间消耗在排序上，选择什么排序方法呢，简单的快速排序足矣，其时间复杂度为O（N*logN），其中N是所需要排序的项（词项ID-文档ID对）的数目的上界。</p>
<p>SPIMI算法，内存式单遍扫描索引算法</p>
<p>与上述BSBI算法不同的是：SPIMI使用词项而不是其ID，它将每个块的词典写入磁盘，对于写一块则重新采用新的词典，只要硬盘空间足够大，它能索引任何大小的文档集。</p>
<p>倒排索引 = 词典（关键词或词项+词项频率）+倒排记录表。建倒排索引的步骤如下：</p>
<ul>
<li>从头开始扫描每一个词项-文档ID（信息）对，遇一词，构建索引；</li>
<li>继续扫描，若遇一新词，则再建一新索引块（加入词典，通过Hash表实现，同时，建一新的倒排记录表）；若遇一旧词，则找到其倒排记录表的位置，添加其后</li>
<li>在内存内基于分块完成排序，后合并分块；</li>
<li>写入磁盘。</li>
</ul>
<p>其伪码如下：</p>
<pre><code>SPIMI-Invert(Token_stream)
output.file=NEWFILE()
dictionary = NEWHASH()
while (free memory available)
    do token &lt;-next(token_stream) //逐一处理每个词项-文档ID对
        if term(token) !(- dictionary
           /*如果词项是第一次出现，那么加入hash词典，同时，建立一个新的倒排索引表*/
           then postings_list = AddToDictionary(dictionary,term(token))
        /*如果不是第一次出现，那么直接返回其倒排记录表，在下面添加其后*/
        else postings_list = GetPostingList(dictionary,term(token))
    if full(postings_list)
        then postings_list =DoublePostingList(dictionary,term(token))
    /*SPIMI与BSBI的区别就在于此，前者直接在倒排记录表中增加此项新纪录*/
    AddToPosTingsList (postings_list,docID(token))
sorted_terms &lt;- SortTerms(dictionary)
WriteBlockToDisk(sorted_terms,dictionary,output_file)
return output_file</code></pre>
<p><strong>SPIMI与BSBI的主要区别：</strong></p>
<p>SPIMI当发现关键词是第一次出现时，会直接在倒排记录表中增加一项（与BSBI算法不同）。同时，与BSBI算法一开始就整理出所有的词项ID-文档ID，并对它们进行排序的做法不同（而这恰恰是BSBI的做法），这里的每个倒排记录表都是动态增长的（也就是说，倒排记录表的大小会不断调整），同时，扫描一遍就可以实现全体倒排记录表的收集。</p>
<p><strong>SPIMI这样做有两点好处:</strong></p>
<p>由于不需要排序操作，因此处理的速度更快， 由于保留了倒排记录表对词项的归属关系，因此能节省内存，词项的ID也不需要保存。这样，每次单独的SPIMI-Invert调用能够处理的块大小可以非常大，整个倒排索引的构建过程也可以非常高效。</p>
<p>但不得不提的是，由于事先并不知道每个词项的倒排记录表大小，算法一开始只能分配一个较小的倒排记录表空间，每次当该空间放满的时候，就会申请加倍的空间，</p>
<p>与此同时，自然而然便会浪费一部分空间（当然，此前因为不保存词项ID，倒也省下一点空间，总体而言，算作是抵销了）。</p>
<p>不过，至少SPIMI所用的空间会比BSBI所用空间少。当内存耗尽后，包括词典和倒排记录表的块索引将被写到磁盘上，但在此之前，为使倒排记录表按照词典顺序来加快最后的合并操作，所以要对词项进行排序操作。</p>
<p>小数据量与大数据量的区别</p>
<ul>
<li>在小数据量时，有足够的内存保证该创建过程可以一次完成；</li>
<li>数据规模增大后，可以采用分组索引，然后再归并索 引的策略。该策略是，</li>
</ul>
<p>建立索引的模块根据当时运行系统所在的计算机的内存大小，将索引分为 k 组，使得每组运算所需内存都小于系统能够提供的最大使用内存的大小。 按照倒排索引的生成算法，生成 k 组倒排索引。 然后将这 k 组索引归并，即将相同索引词对应的数据合并到一起，就得到了以索引词为主键的最终的倒排文件索引，即反向索引。</p>
<p>为了测试的方便，本文针对小数据量进行从正排文档到倒排索引文件的实现。而且针对大数量的K路归并算法或基于磁盘的外部排序算法本编程艺术系列第十章中已有详细阐述。</p>
<h4 id="第二节hash表的构建与实现">第二节、Hash表的构建与实现</h4>
<p>如下，给定如下图所示的正排文档，每一行的信息分别为（中间用##########隔开）：文档ID、订阅源（子频道）、 频道分类、 网站类ID（大频道）、时间、 md5、文档权值、关键词、作者等等。 <img src="../images/26/26.2.gif" /></p>
<p>要求基于给定的上述正排文档。生成如第二十四章所示的倒排索引文件（注，关键词所在的文章如果是同一个日期的话，是挨在同一行的，用“#”符号隔开）： <img src="../images/26/26.3.gif" /></p>
<p>我们知道：为网页建立全文索引是网页预处理的核心部分，包括分析网页和建立倒排文件。二者是顺序进行，先分析网页，后建立倒排文件（也称为反向索引），如图所示：</p>
<figure>
<img src="../images/26/26.4.gif" />
</figure>
<p>正如上图粗略所示，我们知道倒排索引创建的过程如下：</p>
<ul>
<li>写爬虫抓取相关的网页，而后提取相关网页或文章中所有的关键词；</li>
<li>分词，找出所有单词；</li>
<li>过滤不相干的信息（如广告等信息）；</li>
<li>构建倒排索引，关键词=&gt;（文章ID 出现次数 出现的位置）生成词典文件 频率文件 位置文件；</li>
<li>压缩。</li>
</ul>
<p>因为已经给定了正排文档，接下来，咱们跳过一系列文本解析，分词等中间步骤，直接根据正排文档生成倒排索引文档（幸亏有yansha相助，不然，寸步难行，其微博地址为：<a href="http://weibo.com/yanshazi">http://weibo.com/yanshazi</a>，欢迎关注他）。</p>
<p>OK，闲不多说，咱们来一步一步实现吧。</p>
<p>建相关的数据结构</p>
<p>根据给定的正排文档，我们可以建立如下的两个结构体表示这些信息：文档ID、订阅源（子频道）、 频道分类、 网站类ID（大频道）、时间、 md5、文档权值、关键词、作者等等。如下所示：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> key_node
{
    <span class="dt">char</span> *pkey;     <span class="co">// 关键词实体</span>
    <span class="dt">int</span> count;      <span class="co">// 关键词出现次数</span>
    <span class="dt">int</span> pos;        <span class="co">// 关键词在hash表中位置</span>
    <span class="kw">struct</span> doc_node *next;  <span class="co">// 指向文档结点</span>
}KEYNODE, *key_list;

key_list key_array[TABLE_SIZE];

<span class="kw">typedef</span> <span class="kw">struct</span> doc_node
{
    <span class="dt">char</span> id[WORD_MAX_LEN];  <span class="co">//文档ID</span>
    <span class="dt">int</span> classOne;           <span class="co">//订阅源（子频道）</span>
    <span class="dt">char</span> classTwo[WORD_MAX_LEN];    <span class="co">//频道分类</span>
    <span class="dt">int</span> classThree;                 <span class="co">//网站类ID（大频道）</span>
    <span class="dt">char</span> time[WORD_MAX_LEN];        <span class="co">//时间</span>
    <span class="dt">char</span> md5[WORD_MAX_LEN];         <span class="co">//md5</span>
    <span class="dt">int</span> weight;                     <span class="co">//文档权值</span>
    <span class="kw">struct</span> doc_node *next;
}DOCNODE, *doc_list;</code></pre>
<p>我们知道，通过第二十四章的暴雪的Hash表算法，可以比较好的避免相关冲突的问题。下面，我们再次引用其代码： 基于暴雪的Hash之上的改造算法</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//函数prepareCryptTable以下的函数生成一个长度为0x100的cryptTable[0x100]</span>
<span class="dt">void</span> PrepareCryptTable()
{
    <span class="dt">unsigned</span> <span class="dt">long</span> seed = <span class="bn">0x00100001</span>, index1 = <span class="dv">0</span>, index2 = <span class="dv">0</span>, i;

    <span class="kw">for</span>( index1 = <span class="dv">0</span>; index1 &lt;<span class="bn">0x100</span>; index1++ )
    {
        <span class="kw">for</span>( index2 = index1, i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++, index2 += <span class="bn">0x100</span>)
        {
            <span class="dt">unsigned</span> <span class="dt">long</span> temp1, temp2;
            seed = (seed * <span class="dv">125</span> + <span class="dv">3</span>) % <span class="bn">0x2AAAAB</span>;
            temp1 = (seed &amp; <span class="bn">0xFFFF</span>)&lt;&lt;<span class="bn">0x10</span>;
            seed = (seed * <span class="dv">125</span> + <span class="dv">3</span>) % <span class="bn">0x2AAAAB</span>;
            temp2 = (seed &amp; <span class="bn">0xFFFF</span>);
            cryptTable[index2] = ( temp1 | temp2 );
        }
    }
}

<span class="co">//函数HashString以下函数计算lpszFileName 字符串的hash值，其中dwHashType 为hash的类型，</span>
<span class="dt">unsigned</span> <span class="dt">long</span> HashString(<span class="dt">const</span> <span class="dt">char</span> *lpszkeyName, <span class="dt">unsigned</span> <span class="dt">long</span> dwHashType )
{
    <span class="dt">unsigned</span> <span class="dt">char</span> *key  = (<span class="dt">unsigned</span> <span class="dt">char</span> *)lpszkeyName;
    <span class="dt">unsigned</span> <span class="dt">long</span> seed1 = <span class="bn">0x7FED7FED</span>;
    <span class="dt">unsigned</span> <span class="dt">long</span> seed2 = <span class="bn">0xEEEEEEEE</span>;
    <span class="dt">int</span> ch;

    <span class="kw">while</span>( *key != <span class="dv">0</span> )
    {
        ch = *key++;
        seed1 = cryptTable[(dwHashType&lt;&lt;<span class="dv">8</span>) + ch] ^ (seed1 + seed2);
        seed2 = ch + seed1 + seed2 + (seed2&lt;&lt;<span class="dv">5</span>) + <span class="dv">3</span>;
    }
    <span class="kw">return</span> seed1;
}

<span class="co">//按关键字查询，如果成功返回hash表中索引位置</span>
key_list SearchByString(<span class="dt">const</span> <span class="dt">char</span> *string_in)
{
    <span class="dt">const</span> <span class="dt">int</span> HASH_OFFSET = <span class="dv">0</span>, HASH_C = <span class="dv">1</span>, HASH_D = <span class="dv">2</span>;
    <span class="dt">unsigned</span> <span class="dt">int</span> nHash = HashString(string_in, HASH_OFFSET);
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashC = HashString(string_in, HASH_C);
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashD = HashString(string_in, HASH_D);
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashStart = nHash % TABLE_SIZE;
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashPos = nHashStart;

    <span class="kw">while</span> (HashTable[nHashPos].bExists)
    {
        <span class="kw">if</span> (HashATable[nHashPos] == (<span class="dt">int</span>) nHashC &amp;&amp; HashBTable[nHashPos] == (<span class="dt">int</span>) nHashD)
        {
            <span class="kw">break</span>;
            <span class="co">//查询与插入不同，此处不需修改</span>
        }
        <span class="kw">else</span>
        {
            nHashPos = (nHashPos + <span class="dv">1</span>) % TABLE_SIZE;
        }

        <span class="kw">if</span> (nHashPos == nHashStart)
        {
            <span class="kw">break</span>;
        }
    }

    <span class="kw">if</span>( key_array[nHashPos] &amp;&amp; strlen(key_array[nHashPos]-&gt;pkey))
    {
        <span class="kw">return</span> key_array[nHashPos];
    }

    <span class="kw">return</span> NULL;
}

<span class="co">//按索引查询，如果成功返回关键字（此函数在本章中没有被用到，可以忽略）</span>
key_list SearchByIndex(<span class="dt">unsigned</span> <span class="dt">int</span> nIndex)
{
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashPos = nIndex;
    <span class="kw">if</span> (nIndex &lt; TABLE_SIZE)
    {
        <span class="kw">if</span>(key_array[nHashPos] &amp;&amp; strlen(key_array[nHashPos]-&gt;pkey))
        {
            <span class="kw">return</span> key_array[nHashPos];
        }
    }

    <span class="kw">return</span> NULL;
}

<span class="co">//插入关键字，如果成功返回hash值</span>
<span class="dt">int</span> InsertString(<span class="dt">const</span> <span class="dt">char</span> *str)
{
    <span class="dt">const</span> <span class="dt">int</span> HASH_OFFSET = <span class="dv">0</span>, HASH_A = <span class="dv">1</span>, HASH_B = <span class="dv">2</span>;
    <span class="dt">unsigned</span> <span class="dt">int</span> nHash = HashString(str, HASH_OFFSET);
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashA = HashString(str, HASH_A);
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashB = HashString(str, HASH_B);
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashStart = nHash % TABLE_SIZE;
    <span class="dt">unsigned</span> <span class="dt">int</span> nHashPos = nHashStart;
    <span class="dt">int</span> len;

    <span class="kw">while</span> (HashTable[nHashPos].bExists)
    {
        nHashPos = (nHashPos + <span class="dv">1</span>) % TABLE_SIZE;

        <span class="kw">if</span> (nHashPos == nHashStart)
            <span class="kw">break</span>;
    }

    len = strlen(str);
    <span class="kw">if</span> (!HashTable[nHashPos].bExists &amp;&amp; (len &lt; WORD_MAX_LEN))
    {
        HashATable[nHashPos] = nHashA;
        HashBTable[nHashPos] = nHashB;

        key_array[nHashPos] = (KEYNODE *) malloc (<span class="kw">sizeof</span>(KEYNODE) * <span class="dv">1</span>);
        <span class="kw">if</span>(key_array[nHashPos] == NULL)
        {
            printf(<span class="st">&quot;10000 EMS ERROR !!!!</span><span class="ch">\n</span><span class="st">&quot;</span>);
            <span class="kw">return</span> <span class="dv">0</span>;
        }

        key_array[nHashPos]-&gt;pkey = (<span class="dt">char</span> *)malloc(len<span class="dv">+1</span>);
        <span class="kw">if</span>(key_array[nHashPos]-&gt;pkey == NULL)
        {
            printf(<span class="st">&quot;10000 EMS ERROR !!!!</span><span class="ch">\n</span><span class="st">&quot;</span>);
            <span class="kw">return</span> <span class="dv">0</span>;
        }

        memset(key_array[nHashPos]-&gt;pkey, <span class="dv">0</span>, len<span class="dv">+1</span>);
        strncpy(key_array[nHashPos]-&gt;pkey, str, len);
        *((key_array[nHashPos]-&gt;pkey)+len) = <span class="dv">0</span>;
        key_array[nHashPos]-&gt;pos = nHashPos;
        key_array[nHashPos]-&gt;count = <span class="dv">1</span>;
        key_array[nHashPos]-&gt;next = NULL;
        HashTable[nHashPos].bExists = <span class="dv">1</span>;
        <span class="kw">return</span> nHashPos;
    }

    <span class="kw">if</span>(HashTable[nHashPos].bExists)
        printf(<span class="st">&quot;30000 in the hash table %s !!!</span><span class="ch">\n</span><span class="st">&quot;</span>, str);
    <span class="kw">else</span>
        printf(<span class="st">&quot;90000 strkey error !!!</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">return</span> -<span class="dv">1</span>;
}</code></pre>
<p>有了这个Hash表，接下来，我们就可以把词插入Hash表进行存储了。</p>
<h4 id="第三节倒排索引文件的生成与实现">第三节、倒排索引文件的生成与实现</h4>
<p>Hash表实现了（存于HashSearch.h中），还得编写一系列的函数，如下所示（所有代码还只是初步实现了功能，稍后在第四部分中将予以改进与优化）：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//处理空白字符和空白行</span>
<span class="dt">int</span> GetRealString(<span class="dt">char</span> *pbuf)
{
    <span class="dt">int</span> len = strlen(pbuf) - <span class="dv">1</span>;
    <span class="kw">while</span> (len &gt; <span class="dv">0</span> &amp;&amp; (pbuf[len] == (<span class="dt">char</span>)<span class="bn">0x0d</span> || pbuf[len] == (<span class="dt">char</span>)<span class="bn">0x0a</span> || pbuf[len] == &#39; &#39; || pbuf[len] == <span class="ch">&#39;\t&#39;</span>))
    {
        len--;
    }

    <span class="kw">if</span> (len &lt; <span class="dv">0</span>)
    {
        *pbuf = &#39;\<span class="dv">0</span>&#39;;
        <span class="kw">return</span> len;
    }
    pbuf[len<span class="dv">+1</span>] = &#39;\<span class="dv">0</span>&#39;;
    <span class="kw">return</span> len + <span class="dv">1</span>;
}

<span class="co">//重新strcoll字符串比较函数</span>
<span class="dt">int</span> strcoll(<span class="dt">const</span> <span class="dt">void</span> *s1, <span class="dt">const</span> <span class="dt">void</span> *s2)
{
    <span class="dt">char</span> *c_s1 = (<span class="dt">char</span> *)s1;
    <span class="dt">char</span> *c_s2 = (<span class="dt">char</span> *)s2;
    <span class="kw">while</span> (*c_s1 == *c_s2++)
    {
        <span class="kw">if</span> (*c_s1++ == &#39;\<span class="dv">0</span>&#39;)
        {
            <span class="kw">return</span> <span class="dv">0</span>;
        }
    }

    <span class="kw">return</span> *c_s1 - *--c_s2;
}

<span class="co">//从行缓冲中得到各项信息，将其写入items数组</span>
<span class="dt">void</span> GetItems(<span class="dt">char</span> *&amp;move, <span class="dt">int</span> &amp;count, <span class="dt">int</span> &amp;wordnum)
{
    <span class="dt">char</span> *front = move;
    <span class="dt">bool</span> flag = <span class="kw">false</span>;
    <span class="dt">int</span> len;
    move = strstr(move, <span class="st">&quot;#####&quot;</span>);
    <span class="kw">if</span> (*(move + <span class="dv">5</span>) == &#39;#&#39;)
    {
        flag = <span class="kw">true</span>;
    }

    <span class="kw">if</span> (move)
    {
        len = move - front;
        strncpy(items[count], front, len);
    }
    items[count][len] = &#39;\<span class="dv">0</span>&#39;;
    count++;

    <span class="kw">if</span> (flag)
    {
        move = move + <span class="dv">10</span>;
    } <span class="kw">else</span>
    {
        move = move + <span class="dv">5</span>;
    }
}

<span class="co">//保存关键字相应的文档内容</span>
doc_list SaveItems()
{
    doc_list infolist = (doc_list) malloc(<span class="kw">sizeof</span>(DOCNODE));
    strcpy_s(infolist-&gt;id, items[<span class="dv">0</span>]);
    infolist-&gt;classOne = atoi(items[<span class="dv">1</span>]);
    strcpy_s(infolist-&gt;classTwo, items[<span class="dv">2</span>]);
    infolist-&gt;classThree = atoi(items[<span class="dv">3</span>]);
    strcpy_s(infolist-&gt;time, items[<span class="dv">4</span>]);
    strcpy_s(infolist-&gt;md5, items[<span class="dv">5</span>]);
    infolist-&gt;weight = atoi(items[<span class="dv">6</span>]);
    <span class="kw">return</span> infolist;
}

<span class="co">//得到目录下所有文件名</span>
<span class="dt">int</span> GetFileName(<span class="dt">char</span> filename[][FILENAME_MAX_LEN])
{
    _finddata_t file;
    <span class="dt">long</span> handle;
    <span class="dt">int</span> filenum = <span class="dv">0</span>;
    <span class="co">//C:\Users\zhangxu\Desktop\CreateInvertedIndex\data</span>
    <span class="kw">if</span> ((handle = _findfirst(<span class="st">&quot;C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">zhangxu</span><span class="ch">\\</span><span class="st">Desktop</span><span class="ch">\\</span><span class="st">CreateInvertedIndex</span><span class="ch">\\</span><span class="st">data</span><span class="ch">\\</span><span class="st">*.txt&quot;</span>, &amp;file)) == -<span class="dv">1</span>)
    {
        printf(<span class="st">&quot;Not Found</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">else</span>
    {
        <span class="kw">do</span>
        {
            strcpy_s(filename[filenum++], file.name);
        } <span class="kw">while</span> (!_findnext(handle, &amp;file));
    }
    _findclose(handle);
    <span class="kw">return</span> filenum;
}

<span class="co">//以读方式打开文件，如果成功返回文件指针</span>
FILE* OpenReadFile(<span class="dt">int</span> index, <span class="dt">char</span> filename[][FILENAME_MAX_LEN])
{
    <span class="dt">char</span> *abspath;
    <span class="dt">char</span> dirpath[] = {<span class="st">&quot;data</span><span class="ch">\\</span><span class="st">&quot;</span>};
    abspath = (<span class="dt">char</span> *)malloc(ABSPATH_MAX_LEN);
    strcpy_s(abspath, ABSPATH_MAX_LEN, dirpath);
    strcat_s(abspath, FILENAME_MAX_LEN, filename[index]);

    FILE *fp = fopen (abspath, <span class="st">&quot;r&quot;</span>);
    <span class="kw">if</span> (fp == NULL)
    {
        printf(<span class="st">&quot;open read file error!</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">return</span> NULL;
    }
    <span class="kw">else</span>
    {
        <span class="kw">return</span> fp;
    }
}

<span class="co">//以写方式打开文件，如果成功返回文件指针</span>
FILE* OpenWriteFile(<span class="dt">const</span> <span class="dt">char</span> *in_file_path)
{
    <span class="kw">if</span> (in_file_path == NULL)
    {
        printf(<span class="st">&quot;output file path error!</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">return</span> NULL;
    }

    FILE *fp = fopen(in_file_path, <span class="st">&quot;w+&quot;</span>);
    <span class="kw">if</span> (fp == NULL)
    {
        printf(<span class="st">&quot;open write file error!</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> fp;
}</code></pre>
<p>最后，主函数编写如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    key_list keylist;
    <span class="dt">char</span> *pbuf, *move;
    <span class="dt">int</span> filenum = GetFileName(filename);
    FILE *fr;
    pbuf = (<span class="dt">char</span> *)malloc(BUF_MAX_LEN);
    memset(pbuf, <span class="dv">0</span>, BUF_MAX_LEN);

    FILE *fw = OpenWriteFile(<span class="st">&quot;index.txt&quot;</span>);
    <span class="kw">if</span> (fw == NULL)
    {
        <span class="kw">return</span> <span class="dv">0</span>;
    }

    PrepareCryptTable();    <span class="co">//初始化Hash表</span>

    <span class="dt">int</span> wordnum = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; filenum; i++)
    {
        fr = OpenReadFile(i, filename);
        <span class="kw">if</span> (fr == NULL)
        {
            <span class="kw">break</span>;
        }

        <span class="co">// 每次读取一行处理</span>
        <span class="kw">while</span> (fgets(pbuf, BUF_MAX_LEN, fr))
        {
            <span class="dt">int</span> count = <span class="dv">0</span>;
            move = pbuf;
            <span class="kw">if</span> (GetRealString(pbuf) &lt;= <span class="dv">1</span>)
                <span class="kw">continue</span>;

            <span class="kw">while</span> (move != NULL)
            {
                <span class="co">// 找到第一个非&#39;#&#39;的字符</span>
                <span class="kw">while</span> (*move == &#39;#&#39;)
                    move++;

                <span class="kw">if</span> (!strcmp(move, <span class="st">&quot;&quot;</span>))
                    <span class="kw">break</span>;

                GetItems(move, count, wordnum);
            }

            <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">7</span>; i &lt; count; i++)
            {
                <span class="co">// 将关键字对应的文档内容加入文档结点链表中</span>
                <span class="kw">if</span> (keylist = SearchByString(items[i]))     <span class="co">//到hash表内查询</span>
                {
                    doc_list infolist = SaveItems();
                    infolist-&gt;next = keylist-&gt;next;
                    keylist-&gt;count++;
                    keylist-&gt;next = infolist;
                }
                <span class="kw">else</span>
                {
                    <span class="co">// 如果关键字第一次出现，则将其加入hash表</span>
                    <span class="dt">int</span> pos = InsertString(items[i]);       <span class="co">//插入hash表</span>
                    keylist = key_array[pos];
                    doc_list infolist = SaveItems();
                    infolist-&gt;next = NULL;
                    keylist-&gt;next = infolist;
                    <span class="kw">if</span> (pos != -<span class="dv">1</span>)
                    {
                        strcpy_s(words[wordnum++], items[i]);
                    }
                }
            }
        }
    }

    <span class="co">// 通过快排对关键字进行排序</span>
    qsort(words, WORD_MAX_NUM, WORD_MAX_LEN, strcoll);

    <span class="co">// 遍历关键字数组，将关键字及其对应的文档内容写入文件中</span>
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; WORD_MAX_NUM; i++)
    {
        keylist = SearchByString(words[i]);
        <span class="kw">if</span> (keylist != NULL)
        {
            fprintf(fw, <span class="st">&quot;%s %d</span><span class="ch">\n</span><span class="st">&quot;</span>, words[i], keylist-&gt;count);
            doc_list infolist = keylist-&gt;next;
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; keylist-&gt;count; j++)
            {
                <span class="co">//文档ID，订阅源（子频道） 频道分类 网站类ID（大频道） 时间  md5，文档权值</span>
                fprintf(fw, <span class="st">&quot;%s %d %s %d %s %s %d</span><span class="ch">\n</span><span class="st">&quot;</span>, infolist-&gt;id, infolist-&gt;classOne,
                    infolist-&gt;classTwo, infolist-&gt;classThree, infolist-&gt;time, infolist-&gt;md5, infolist-&gt;weight);
                infolist = infolist-&gt;next;
            }
        }
    }

    free(pbuf);
    fclose(fr);
    fclose(fw);
    system(<span class="st">&quot;pause&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>程序编译运行后，生成的倒排索引文件为index.txt，其与原来给定的正排文档对照如下： <img src="../images/26/26.5.gif" /></p>
<p>有没有发现关键词奥恰洛夫出现在的三篇文章是同一个日期1210的，貌似与本文开头指定的倒排索引格式要求不符？因为第二部分开头中，已明确说明：“注，关键词所在的文章如果是同一个日期的话，是挨在同一行的，用“#”符号隔开”。OK，有疑问是好事，代表你思考了，请直接转至下文第4部分。</p>
<h4 id="第四节程序需求功能的改进">第四节、程序需求功能的改进</h4>
<h6 id="对相同日期与不同日期的处理">4.1、对相同日期与不同日期的处理</h6>
<p>细心的读者可能还是会注意到：在第二部分开头中，要求基于给定的上述正排文档。生成如第二十四章所示的倒排索引文件是下面这样子的，即是： <img src="../images/26/26.6.gif" /></p>
<p>也就是说，上面建索引的过程本该是如下的： <img src="../images/26/26.7.gif" /></p>
<p>与第一部分所述的SMIPI算法有什么区别？对的，就在于对在同一个日期的出现的关键词的处理。如果是遇一旧词，则找到其倒排记录表的位置：相同日期，添加到之前同一日期的记录之后（第一个记录的后面记下同一日期的记录数目）；不同日期，另起一行新增记录。</p>
<ul>
<li>相同（单个）日期，根据文档权值排序</li>
<li>不同日期，根据时间排序</li>
</ul>
<p>代码主要修改如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//function: 对链表进行冒泡排序</span>
<span class="dt">void</span> ListSort(key_list keylist)
{
    doc_list p = keylist-&gt;next;
    doc_list <span class="kw">final</span> = NULL;
    <span class="kw">while</span> (<span class="kw">true</span>)
    {
        <span class="dt">bool</span> isfinish = <span class="kw">true</span>;
        <span class="kw">while</span> (p-&gt;next != <span class="kw">final</span>) {
            <span class="kw">if</span> (strcmp(p-&gt;time, p-&gt;next-&gt;time) &lt; <span class="dv">0</span>)
            {
                SwapDocNode(p);
                isfinish = <span class="kw">false</span>;
            }
            p = p-&gt;next;
        }
        <span class="kw">final</span> = p;
        p = keylist-&gt;next;
        <span class="kw">if</span> (isfinish || p-&gt;next == <span class="kw">final</span>) {
            <span class="kw">break</span>;
        }
    }
}

<span class="dt">int</span> main()
{
    key_list keylist;
    <span class="dt">char</span> *pbuf, *move;
    <span class="dt">int</span> filenum = GetFileName(filename);
    FILE *frp;
    pbuf = (<span class="dt">char</span> *)malloc(BUF_MAX_LEN);
    memset(pbuf, <span class="dv">0</span>, BUF_MAX_LEN);

    FILE *fwp = OpenWriteFile(<span class="st">&quot;index.txt&quot;</span>);
    <span class="kw">if</span> (fwp == NULL) {
        <span class="kw">return</span> <span class="dv">0</span>;
    }

    PrepareCryptTable();

    <span class="dt">int</span> wordnum = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; filenum; i++)
    {
        frp = OpenReadFile(i, filename);
        <span class="kw">if</span> (frp == NULL) {
            <span class="kw">break</span>;
        }

        <span class="co">// 每次读取一行处理</span>
        <span class="kw">while</span> (fgets(pbuf, BUF_MAX_LEN, frp))
        {
            <span class="dt">int</span> count = <span class="dv">0</span>;
            move = pbuf;
            <span class="kw">if</span> (GetRealString(pbuf) &lt;= <span class="dv">1</span>)
                <span class="kw">continue</span>;

            <span class="kw">while</span> (move != NULL)
            {
                <span class="co">// 找到第一个非&#39;#&#39;的字符</span>
                <span class="kw">while</span> (*move == &#39;#&#39;)
                    move++;

                <span class="kw">if</span> (!strcmp(move, <span class="st">&quot;&quot;</span>))
                    <span class="kw">break</span>;

                GetItems(move, count, wordnum);
            }

            <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">7</span>; i &lt; count; i++) {
                <span class="co">// 将关键字对应的文档内容加入文档结点链表中</span>
                <span class="co">// 如果关键字第一次出现，则将其加入hash表</span>
                <span class="kw">if</span> (keylist = SearchByString(items[i])) {
                    doc_list infolist = SaveItems();
                    infolist-&gt;next = keylist-&gt;next;
                    keylist-&gt;count++;
                    keylist-&gt;next = infolist;
                } <span class="kw">else</span> {
                    <span class="dt">int</span> pos = InsertString(items[i]);
                    keylist = key_array[pos];
                    doc_list infolist = SaveItems();
                    infolist-&gt;next = NULL;
                    keylist-&gt;next = infolist;
                    <span class="kw">if</span> (pos != -<span class="dv">1</span>) {
                        strcpy_s(words[wordnum++], items[i]);
                    }
                }
            }
        }
    }

    <span class="co">// 通过快排对关键字进行排序</span>
    qsort(words, WORD_MAX_NUM, WORD_MAX_LEN, strcoll);

    <span class="co">// 遍历关键字数组，将关键字及其对应的文档内容写入文件中</span>
    <span class="dt">int</span> rownum = <span class="dv">1</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; WORD_MAX_NUM; i++) {
        keylist = SearchByString(words[i]);
        <span class="kw">if</span> (keylist != NULL) {
            doc_list infolist = keylist-&gt;next;

            <span class="dt">char</span> date[<span class="dv">9</span>];

            <span class="co">// 截取年月日</span>
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; keylist-&gt;count; j++)
            {
                strncpy_s(date, infolist-&gt;time, <span class="dv">8</span>);
                date[<span class="dv">8</span>] = &#39;\<span class="dv">0</span>&#39;;
                strncpy_s(infolist-&gt;time, date, <span class="dv">9</span>);
                infolist = infolist-&gt;next;
            }

            <span class="co">// 对链表根据时间进行排序</span>
            ListSort(keylist);

            infolist = keylist-&gt;next;
            <span class="dt">int</span> *count = <span class="kw">new</span> <span class="dt">int</span>[WORD_MAX_NUM];
            memset(count, <span class="dv">0</span>, WORD_MAX_NUM);
            strcpy_s(date, infolist-&gt;time);
            <span class="dt">int</span> num = <span class="dv">0</span>;
            <span class="co">// 得到单个日期的文档数目</span>
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; keylist-&gt;count; j++)
            {
                <span class="kw">if</span> (strcmp(date, infolist-&gt;time) == <span class="dv">0</span>) {
                    count[num]++;
                } <span class="kw">else</span> {
                    count[++num]++;
                }
                strcpy_s(date, infolist-&gt;time);
                infolist = infolist-&gt;next;
            }
            fprintf(fwp, <span class="st">&quot;%s %d %d</span><span class="ch">\n</span><span class="st">&quot;</span>, words[i], num + <span class="dv">1</span>, rownum);
            WriteFile(keylist, num, fwp, count);
            rownum++;
        }
    }

    free(pbuf);
<span class="co">//  fclose(frp);</span>
    fclose(fwp);
    system(<span class="st">&quot;pause&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>修改后编译运行，生成的index.txt文件如下： <img src="../images/26/26.8.gif" /></p>
<h6 id="为关键词添上编码">4.2、为关键词添上编码</h6>
<p>如上图所示，已经满足需求了。但可以再在每个关键词的背后添加一个计数表示索引到了第多少个关键词： <img src="../images/26/26.9.gif" /></p>
<h4 id="第五节算法的二次改进">第五节、算法的二次改进</h4>
<h6 id="省去二次hash">5.1、省去二次Hash</h6>
<p>针对本文评论下读者的留言，做了下思考，自觉可以省去二次hash：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">7</span>; i &lt; count; i++)
        {
            <span class="co">// 将关键字对应的文档内容加入文档结点链表中</span>
            <span class="co">//也就是说当查询到hash表中没有某个关键词之,后便会插入</span>
            <span class="co">//而查询的时候，search会调用hashstring，得到了nHashC ，nHashD</span>
            <span class="co">//插入的时候又调用了一次hashstring，得到了nHashA，nHashB</span>
            <span class="co">//而如果查询的时候，是针对同一个关键词查询的，所以也就是说nHashC&amp;nHashD，与nHashA&amp;nHashB是相同的，无需二次hash</span>
            <span class="co">//所以，若要改进，改的也就是下面这个if~else语句里头。July，2011.12.30。</span>
            <span class="kw">if</span> (keylist = SearchByString(items[i]))     <span class="co">//到hash表内查询</span>
            {
                doc_list infolist = SaveItems();
                infolist-&gt;next = keylist-&gt;next;
                keylist-&gt;count++;
                keylist-&gt;next = infolist;
            }
            <span class="kw">else</span>
            {
                <span class="co">// 如果关键字第一次出现，则将其加入hash表</span>
                <span class="dt">int</span> pos = InsertString(items[i]);       <span class="co">//插入hash表</span>
                keylist = key_array[pos];
                doc_list infolist = SaveItems();
                infolist-&gt;next = NULL;
                keylist-&gt;next = infolist;
                <span class="kw">if</span> (pos != -<span class="dv">1</span>)
                {
                    strcpy_s(words[wordnum++], items[i]);
                }
            }
        }
    }
}
<span class="co">// 通过快排对关键字进行排序</span>
qsort(words, WORD_MAX_NUM, WORD_MAX_LEN, strcoll);</code></pre>
<h6 id="除去排序针对不同日期的记录直接插入">5.2、除去排序，针对不同日期的记录直接插入</h6>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//对链表进行冒泡排序。这里可以改成快速排序：等到统计完所有有关这个关键词的文章之后，才能对他集体快排。</span>
<span class="co">//但其实完全可以用插入排序，不同日期的，根据时间的先后找到插入位置进行插入：</span>
<span class="co">//假如说已有三条不同日期的记录 A B C</span>
<span class="co">//来了D后，发现D在C之前，B之后，那么就必须为它找到B C之间的插入位置，</span>
<span class="co">//A B D C。July、2011.12.31。</span>
<span class="dt">void</span> ListSort(key_list keylist)
{
    doc_list p = keylist-&gt;next;
    doc_list <span class="kw">final</span> = NULL;
    <span class="kw">while</span> (<span class="kw">true</span>)
    {
        <span class="dt">bool</span> isfinish = <span class="kw">true</span>;
        <span class="kw">while</span> (p-&gt;next != <span class="kw">final</span>) {
            <span class="kw">if</span> (strcmp(p-&gt;time, p-&gt;next-&gt;time) &lt; <span class="dv">0</span>) <span class="co">//不同日期的按最早到最晚排序</span>
            {
                SwapDocNode(p);
                isfinish = <span class="kw">false</span>;
            }
            p = p-&gt;next;
        }
        <span class="kw">final</span> = p;
        p = keylist-&gt;next;
        <span class="kw">if</span> (isfinish || p-&gt;next == <span class="kw">final</span>) {
            <span class="kw">break</span>;
        }
    }
}</code></pre>
<p>综上5.1、5.2两节免去冒泡排序和，省去二次hash和免去冒泡排序，修改后如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">7</span>; i &lt; count; i++) {
            <span class="co">// 将关键字对应的文档内容加入文档结点链表中</span>
            <span class="co">// 如果关键字第一次出现，则将其加入hash表</span>
            InitHashValue(items[i], hashvalue);
            <span class="kw">if</span> (keynode = SearchByString(items[i], hashvalue)) {
                doc_list infonode = SaveItems();
                doc_list p = keynode-&gt;next;
                <span class="co">// 根据时间由早到晚排序</span>
                <span class="kw">if</span> (strcmp(infonode-&gt;time, p-&gt;time) &lt; <span class="dv">0</span>) {
                    <span class="co">//考虑infonode插入keynode后的情况</span>
                    infonode-&gt;next = p;
                    keynode-&gt;next = infonode;
                } <span class="kw">else</span> {
                    <span class="co">//考虑其他情况</span>
                    doc_list pre = p;
                    p = p-&gt;next;
                    <span class="kw">while</span> (p)
                    {
                        <span class="kw">if</span> (strcmp(infonode-&gt;time, p-&gt;time) &gt; <span class="dv">0</span>) {
                            p = p-&gt;next;
                            pre = pre-&gt;next;
                        } <span class="kw">else</span> {
                            <span class="kw">break</span>;
                        }
                    }
                    infonode-&gt;next = p;
                    pre-&gt;next = infonode;
                }
                keynode-&gt;count++;
            } <span class="kw">else</span> {
                <span class="dt">int</span> pos = InsertString(items[i], hashvalue);
                keynode = key_array[pos];
                doc_list infolist = SaveItems();
                infolist-&gt;next = NULL;
                keynode-&gt;next = infolist;
                <span class="kw">if</span> (pos != -<span class="dv">1</span>) {
                    strcpy_s(words[wordnum++], items[i]);
                }
            }
        }
    }
}

<span class="co">// 通过快排对关键字进行排序</span>
qsort(words, WORD_MAX_NUM, WORD_MAX_LEN, strcoll);</code></pre>
<p>修改后编译运行的效果图如下（用了另外一份更大的数据文件进行测试）： <img src="../images/26/26.10.gif" /></p>
<p>本章全部源码请到以下两处任一一处下载（欢迎读者朋友们继续优化，若能反馈于我，则幸甚不过了）：</p>
<ul>
<li>http://download.csdn.net/detail/v_july_v/4012605（csdn下载处）</li>
<li>https://github.com/fuxiang90/CreateInvertedIndex.（github下载处）</li>
</ul>
<h4 id="后记-1">后记</h4>
<p>本文代码还有很多的地方可以改进和优化，请待后续更新。当然，代码看起来也很青嫩，亟待提高阿。</p>
<p>近几日后，准备编程艺术室内38位兄弟的靓照和blog或空间地址公布在博客内，给读者一个联系他们的方式，顺便还能替他们征征友 招招婚之类的。ys，土豆，水哥，老梦，3，飞羽，风清扬，well，weedge，xiaolin，555等等三十八位兄弟皆都对编程艺术系列贡献卓著。</p>
<p>最后说一句，读者朋友们中如果是初学编程的话切勿跟风学算法，夯实编程基础才是最重要的。预祝各位元旦快乐。谢谢，本章完。</p>
<p>原文链接：<a href="http://blog.csdn.net/v_july_v/article/details/7109500">http://blog.csdn.net/v_july_v/article/details/7109500</a></p>
<h1 id="第二十七章不改变正负数相对顺序重新排列数组">第二十七章：不改变正负数相对顺序重新排列数组</h1>
<h2 id="时间on空间o1-无解">时间O(N)，空间O(1) (无解?)</h2>
<h2 id="前言-2">前言</h2>
<p>在这篇文章：九月腾讯，创新工场，淘宝等公司最新面试十三题的第5题(一个未排序整数数组，有正负数，重新排列使负数排在正数前面，并且要求不改变原来的正负数之间相对顺序)，自从去年九月收录了此题至今，一直未曾看到令人满意的答案，为何呢?</p>
<p>因为一般达不到题目所要求的：时间复杂度O(N),空间O(1)，且保证原来正负数之间的相对位置不变。本编程艺术系列第27章就来阐述这个问题，若有任何漏洞，欢迎随时不吝指正。谢谢。</p>
<h2 id="重新排列使负数排在正数前面">重新排列使负数排在正数前面</h2>
<p>原题是这样的：</p>
<p>一个未排序整数数组，有正负数，重新排列使负数排在正数前面，并且要求不改变原来的正负数之间相对顺序。</p>
<p>比如： input: 1,7,-5,9,-12,15 ，ans: -5,-12,1,7,9,15 。且要求时间复杂度O(N),空间O(1) 。</p>
<p>OK，下面咱们就来试着一步一步解这道题，如下5种思路（从复杂度O(N^2)到O(N*logN)，从不符合题目条件到一步步趋近于条件)）：</p>
<p>step 1.</p>
<p>最简单的，如果不考虑时间复杂度，最简单的思路是从头扫描这个数组，每碰到一个正数时，拿出这个数字，并把位于这个数字后面的所有数字往前挪动一位。挪完之后在数组的末尾有一个空位，这时把该正数放入这个空位。由于碰到一个正，需要移动O(N)个数字，因此总的时间复杂度是O(N^2)。</p>
<p>step 2.</p>
<p>既然题目要求的是把负数放在数组的前半部分，正数放在数组的后半部分，因此所有的负数应该位于正数的前面。也就是说我们在扫描这个数组的时候，如果发现有正数出现在负数的前面，我们可以交换他们的顺序，交换之后就符合要求了。</p>
<p>因此我们可以维护两个指针，第一个指针初始化为数组的第一个数字，它只向后移动；第二个指针初始化为数组的最后一个数字，它只向前移动。在两个指针相遇之前，第一个指针总是位于第二个指针的前面。如果第一个指针指向的数字是正而第二个指针指向的数字是负数，我们就交换这两个数字。 但遗憾的是上述方法改变了原来正负数之间的相对顺序。所以，咱们得另寻良策。</p>
<p>step 3.</p>
<p>首先，定义这样一个过程为“翻转”：(a1,a2,...,am,b1,b2,...,bn) --&gt; (b1,b2,...,bn,a1,a2,...,am)。其次，对于待处理的未排序整数数组，从头到尾进行扫描，寻找(正正...正负...负负)串；每找到这样一个串，则计数器加1；若计数为奇数，则对当前串做一个“翻转”；反复扫描，直到再也找不到(正正...正负...负负)串。 此思路来自朋友胡果果，空间复杂度虽为O(1)，但其时间复杂度O(N*logN)。更多具体细节参看原文：http://qing.weibo.com/1570303725/5d98eeed33000hcb.html 。故，不符合题目要求，继续寻找。</p>
<p>step 4.</p>
<p>我们可以这样，设置一个起始点j, 一个翻转点k,一个终止点L，从右侧起，起始点在第一个出现的负数, 翻转点在起始点后第一个出现的正数,终止点在翻转点后出现的第一个负数(或结束)。 如果无翻转点, 则不操作，如果有翻转点, 则待终止点出现后, 做翻转, 即 ab =&gt; ba 这样的操作。翻转后, 负数串一定在左侧, 然后从负数串的右侧开始记录起始点, 继续往下找下一个翻转点。</p>
<p>例子中的就是(下划线代表要交换顺序的两个数字)：</p>
<pre><code>1, 7, -5, 9, -12, 15
第一次翻转: 1, 7, -5, -12,9, 15   =&gt;  1, -12, -5, 7, 9, 15
第二次翻转: -5, -12, 1, 7, 9, 15</code></pre>
<p>此思路2果真解决了么?NO，用下面这个例子试一下，我们就能立马看出了漏洞：</p>
<pre><code>1, 7, -5, -6， 9, -12, 15（此种情况未能处理）
1 7 -5 -6 -12 9 15
1 -12 -5 -6 7 9 15
-6 -12 -5 1 7 9 15   (此时，正负数之间的相对顺序已经改变，本应该是-5，-6，-12，而现在是-6 -12 -5)</code></pre>
<p>step 5.</p>
<p>看来这个问题的确有点麻烦，不过我们最终貌似还是找到了另外一种解决办法，正如朋友超越神所说的：从后往前扫描，遇到负数，开始记录负数区间，然后遇到正数，记录前面的正数区间，然后把整个负数区间与前面的正数区间进行交换，交换区间但保序的算法类似（a,bc-&gt;bc,a）的字符串原地翻转算法。交换完之后要继续向前一直扫描下去，每次碰到负数区间在正数区间后面，就翻转区间。下面，将详细阐述此思路4。</p>
<h4 id="思路5之区间翻转">思路5之区间翻转</h4>
<p>其实上述思路5非常简单，既然单个翻转无法解决问题，那么咱们可以区间翻转阿。什么叫区间翻转?不知读者朋友们是否还记得本blog之前曾经整理过这样一道题，微软面试100题系列第10题，如下：</p>
<pre><code>10、翻转句子中单词的顺序。
题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如输入“I am a student.”，则输出“student. a am I”。而此题可以在O(N)的时间复杂度内解决：</code></pre>
<p>由于本题需要翻转句子，我们先颠倒句子中的所有字符。这时，不但翻转了句子中单词的顺序，而且单词内字符也被翻转了。我们再颠倒每个单词内的字符。由于单词内的字符被翻转两次，因此顺序仍然和输入时的顺序保持一致。</p>
<p>以上面的输入为例：翻转“I am a student.”中所有字符得到“.tneduts a ma I”，再翻转每个单词中字符的顺序得到“students. a am I”，正是符合要求的输出(编码实现，可以参看此文：http://zhedahht.blog.163.com/blog/static/254111742007289205219/ )。</p>
<p>对的，上述思路3就是这个意思，单词翻转便相当于于区间翻转，既如此，咱们来验证下上述思路2中那个测试用例，如下：</p>
<pre><code>1, 7, -5, -6， 9, -12, 15
1 7 -5 -6 -12 9 15
-12 -6 -5 7 1 9 15   (借用单词翻转的方法，先逐个数字翻转，后正负数整体原地翻转)
-5 -6 -12 1 7 9 15</code></pre>
<h4 id="思路5再次被质疑">思路5再次被质疑</h4>
<p>但是，我还想再问，问题至此被解决了么?真的被KO了么?NO，咱们来看这样一种情况，正如威士忌所说： 看看这个数据，+-+-+-+-+------+，假如Nminus 等于 n/2，由于前面都是+-+-+-，区间交换需要 n/2/2 = n/4次，每次交换是 T(2<em>(Nminus + Nplus)) &gt;= T(n)，n/4 </em> T(n) = T(n*n/4)=O(n^2)。</p>
<p>还有一种更坏的情况，就是+-+-+-+-+------+这种数据可能，后面一大堆的负数，前面正负交替。所以，咱们的美梦再次破灭，路漫漫其修远兮，此题仍然未找到一个完全解决了的方案。</p>
<h2 id="本题思路征集中之一解一点评">本题思路征集中之一解一点评</h2>
<p>关于本题不改变正负数相对顺序重新排列数组，陆陆续续有不少朋友或发来了邮件，或在本文评论下提供了他们自己的思路或解法，思维理性碰撞，共同享受思考的乐趣，我觉挺有意思，精选其中一些解答贴出来，让大家评判、讨论，如下：</p>
<p><strong>第1解：from Muqi：Hi July,</strong></p>
<p>很高兴看到你的问题，真的很有意思！</p>
<p>我这里想到一种解法，主要的思路是通过改变数字内容来实现保留数字之间相对的顺序：</p>
<ul>
<li>比方说数列 3 4 -1 -3 5 2 -7 6 1</li>
<li>那负数相对顺序是： -1 -3 -7， 正数是 3 4 5 2 6 1</li>
<li>我们可以做变形：</li>
<li>负数成为 -1.1 -2.3， -3.7 （整数部分为相对顺序，小数部分为原来的数字）</li>
<li>同理 正数为： 1.3 2.4 3.5 4.2 5.6 7.1</li>
<li>现在数组变成： 1.3 2.4 -1.1 -2.3 3.5 4.2 -3.7 4.6 5.1</li>
</ul>
<p>接下去 先通过置换把所有负数排到前面：具体方法为从前往后扫描数组，每碰到一个负数 就和数组最前面的正数交换， 结果如下：</p>
<p>-1.1 -2.3 -3.7 2.4 3.5 4.2 1.3 4.6 5.1</p>
<p>可以看到负数部分已经完成题目要求（只需要把整数部分去掉即可），接下去对于正数数列 2.4 3.5 4.2 1.3 4.6 5.1， 也用类似的方法还原先前的顺序：具体方法为一次遍历每个数字，检查其整数部分是否与其所在的位置相同，如不相同，将该数字与位置为该数字整数部分的交换, 比如说2.4 整数部分为2，但是现在位于数列第一位，所以与位于第二位的3.5交换，得到：3.5 2.4 4.2 1.3 4.6 5.1（最多只需要O(n)因为每次交换都保证一个数字回到原来的位置，而总共有n个数字），最后和前面负数的处理相同，即去掉整数部分(+1，邀请来参加读书会第2期)。</p>
<p>点评：但此方法在本文评论下马上有人指出：不过，整数变成浮点数，存储空间要扩大一倍，跟申请一个大小为n的数组一个道理，空间复杂度O(N)不符要求。更多请看本文评论下第18楼。(zj060607 &amp; topskycen，+2)。</p>
<p><strong>第2解：form 立宋(+7)：</strong></p>
<p>July巨巨， 由于在csdn上那贴删改留言次数有点多，csdn不让留言了，就发邮件给您吧。应该是最终稿了。</p>
<p>稍微改动下Muqi的方法，可以得到平均时间O(n)，最坏时间O（n^2），空间复杂度O(1)的。当把负数放到数列前半部分操作时，这个负数是和前面的一个正数交换的。交换过后，把这个正数变成他的相反数(5变成-5这种)。那么当第一轮把负数放到前面过后，剩下的部分又形成了一个相同的子问题。当然，后面几轮把负数放到前面后，得把他们重新恢复成相应的正数。</p>
<p>还是用3 4 -1 -3 5 2 -7 6 1为例子：</p>
<ul>
<li>第一轮： -1 -3 -7 [ -3 -4 2 -5 6 1].</li>
<li>第二轮： -1 -3 -7 -(-3) -(-4) -(-5) [-2 6 1].</li>
<li>第三轮： 1 3 7 3 4 5 2 6 1</li>
<li>最终添上-号，-1 -3 -7 3 4 5 2 6 1</li>
</ul>
<p>平均时间复杂度（假设数组是随机的）：</p>
<p>T(n)=T(n/2)+O(n). T(n)=O(n).</p>
<p>如果遇到+++++...+-这种情况，就会导致最坏的时间复杂度。 这也不算是完美的解法。有点怀疑完美的解是不存在的，但不知道怎么证明。</p>
<p>谢谢，mourisl</p>
<p>点评：from litaoye：</p>
<p>我的想法(见下文之综合点评)也许同上述解法2类似，但我确实没看明白解法2的操作过程，并且我认为解法2十有八九是错的。举个例子来说，如</p>
<pre><code> 1,2,-4,-5,3,-6
-4,2,1,-5,3,-6
-4,-5,1,-2,3,-6
-4,-5,-6,-2,3,-1</code></pre>
<p>这样的话-2同-1的顺序就乱了。更多请看本文评论下第29楼。</p>
<p><strong>第3解：</strong></p>
<p>jiangbin00cn在其blog中提出了一种新的思路：假设全体数据为n个，正数m个分别映射到1--m,这m个数是分散分布在空间n中，利用桶排序使得其排列在n-m--n中，这个过程用到了桶排序的思想，只不过每个桶中只有一个元素。具体步骤如下：</p>
<ol type="1">
<li>桶排序能够在 时间O(N)，空间O(1) 实现，那么能否利用桶排序解决该问题，即如何将该问题转换为桶排序问题</li>
<li>通过可逆的修改元素使得数组满足桶排序要求</li>
<li>利用桶排序实现</li>
<li>恢复元素</li>
</ol>
<p>假设原数组中的全体正数按顺序依次为：</p>
<pre><code>a[0],...a[n]
(a[0],a[1],....a[n]） = f(x) =&gt; （b[0],b[1],....b[n]）= g(x) =&gt; （0,1,....,n）  ==&gt; 桶排序
  原始正数(可能相同)               （修改为全不相同正数）
（0,1,....,n） =g&#39;(x)=&gt; （b[0],b[1],....b[n]）=f&#39;(x)=&gt; （a[0],a[1],....a[n]）
                            可逆运算恢复数据               可逆运算恢复数据</code></pre>
<p>结论：</p>
<p>由于桶排序能够在 时间O(N)，空间O(1) 实现，若可逆函数f(x)、g(x)能够在 时间O(N)，空间O(1)中找到并实现，那么就能够解决该问题(+3)。具体代码实现，请参见原文：http://blog.csdn.net/jiangbin00cn/article/details/7331387 。然而，本文评论下第64楼有读者反应：这段桶代码段有问题 ，当查询的数字比如是1, 7, -5, -6， 9, -12, 15 这样没问题 但是 最后一个数字是负数 这个程序就死循环了 1, 7, -5, -6， 9, -12, 15 -16。</p>
<p>点评：from 威士忌(+5)</p>
<p>jiangbin00cn和Muqi的方法都很取巧。其实他们的方法都是压缩了整数值域或者扩大值域来保存附加信息，虽然符合时间O(N)和空间O(1)的要求，但是并不适用所有int值。</p>
<p>这些方法的思路其实很简单，比如：</p>
<pre><code>num[] = {1,7,-5,9,-12,15};
pos[]={2,3,0,4,1,5};
pos的计算扫描2遍num数组即可，有了pos数组当然排序不成问题。</code></pre>
<p>关键解决pos空间问题时，两位做法分别是，Muqi保存到double浮点域，jiangbin00cn是利用进制方法保存到int高位（其实根本不需桶排了），更明显的做法就是<code>flag(num[i])*pos[i]*1000+num[i]</code>转换为3007,-0005,-1012。</p>
<p>很高兴看到如此让人眼前一亮的方法，但是仔细想想的话，就觉得还是不符合要求。</p>
<p><strong>第4解：from topskychen &amp; acmerfight(+6)：</strong></p>
<p>首先明确题目的题意要求空间复杂度是O(1),我的理解就是只能有一个空间来存储数据，其他的任何临时变量都不能出现，包括循环变量和临时开辟的空间（例如数字交换时）。 下边我的解法是在 允许自己输入数据，可以利用数组大小n的情况下产生的，只包含一个额外的变量。 用pos记录正数的最最左位置减一， a[pos]记录负数最右的位置加一</p>
<p>基本步骤：</p>
<ol type="1">
<li>让pos代表最后一个数据的位置</li>
<li>然后输入一个数据存储在最后的位置 a[pos]</li>
<li>如果输入的数据a[pos]是正数，我们就让pos = pos - 1；如果输入的是负数就把这个负数挪到前边，让a[pos]-1来记录负数最右的位置。</li>
<li>发生相应交换</li>
</ol>
<p>代码在本文评论下第28楼。</p>
<p><strong>综合点评</strong></p>
<p>1.from 威士忌，感觉最近的几种解法越来越倒退了，还不如之前nlogn 的来的有价值。</p>
<p>2.from litaoye：只想到了n<em>log(n)，O(1)的方法。双指针分别指向头和尾，头指针找到的正数同尾指针找到的负数交换，直到2个指针相遇。交换过程中将所有交换元素 </em> -1，也就是正数变负数，负数变正数。此时被换到尾部的正数（*-1后已经变为负数），顺序正好倒过来了，把这部分反转一下。整个过程O(n)，把原问题转化为两个规模为n/2的子问题。因此根据主定理，整个过程应当是nlog(n)的，即最坏情况下是n^2的，不过平均情况下也只是nlog(n)的，达不到O(n)。用迭代的方法写，应该可以做到O(1)（用递归，空间复杂度就是log(n)了），感觉这个问题很难找到O(n),O(1)的解法，类似的问题有完美洗牌问题，LZ可以看一下，解法比较复杂，是通过原根构造置换群来解的。本来还有个原地归并的思路，后来发现有问题，没有继续深入。</p>
<p>3.from sbwwkmyd：除非也能找到划分固定环的方法，一直没找到办法将原根的特性应用到这个问题上，完美洗牌问题 是这个问题的一个很小的子集。这个问题应该无解。</p>
<p>4.from July：有friends反应，算法导论第8章线性时间排序思考题8-2：以线性时间原地置换排序，是此题原型。说运行时间为O(n)、稳定、不使用额外空间原地排序，这3个条件中，三者只能满足其二，由此推出第27章此题无解?果真如此么?如何证明?此题作为面试题，能当场K掉99%的面试者/面试官。</p>
<p>也有朋友反应，根据算导第8章中定理8.1：任意一个比较排序算法在最坏情况下，都需要nlgn次比较。即给定n个不同的输入元素，对于任何确定或随机的比较排序算法，其期望运行时间都有下界O(nlgn)。由此推出此题无解。但他们忽略了：不一定非要排序非要比较。</p>
<p>也就是说，尽管：</p>
<ol type="1">
<li>插入.归并.堆.快速排序皆是基于比较排序，且除归并排序外，皆是原地排序算法。</li>
<li>堆/归并排序运行时间上界皆为O(nlgn)。</li>
<li>计数排序非基于比较，非原地排序，但稳定，是基数排序算法的一个子过程。</li>
<li>计数/基数等非原地(需借助外部空间)排序，空间换时间。</li>
</ol>
<p>但本题统统与这些无关，因为追根究底，本题实质性上只是一个排列，重新组合问题，与排序无关。</p>
<p>更多还可参考此论文：《STABLE MINIMUM SPACE PARTITIONING IN LINEAR TIME》。待后续验证。</p>
<h1 id="第二十八章最大连续乘积子串">第二十八章：最大连续乘积子串</h1>
<h2 id="前言-3">前言</h2>
<p>这一章和下一章的问题皆是各大IT公司最喜欢出的笔试面试题之一，比如说前者是小米2013年校招笔试原题，而后者则更是反复出现，如去年9月26日百度一二面试题，10月9日腾讯面试题第1小题，10月13日百度2013校招北京站笔试题第二 大道题第3小题，及去年10月15日2013年Google校招笔试最后一道大题皆是考察下一章的字符串编辑距离问题。</p>
<p>OK，欢迎朋友们在本文下参与讨论，如果在线编译自己的代码（编程语言任选C/C++/Java/C#），可以上英雄会提交你的代码，有任何问题，欢迎随时不吝批评或指正，感谢。</p>
<h2 id="题目描述-5">题目描述：</h2>
<p>**给一个浮点数序列，取最大乘积连续子串的值，例如 -2.5，4，0，3，0.5，8，-1，则取出的最大乘积连续子串为3，0.5，8。也就是说，上述数组中，3 0.5 8这3个数的乘积3<em>0.5</em>8=12是最大的，而且是连续的。</p>
<p>提醒：此最大乘积连续子串与最大乘积子序列不同，请勿混淆，前者子串要求连续，后者子序列不要求连续。也就是说：最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence，LCS）的区别：</p>
<ul>
<li><p>子串（Substring）是串的一个连续的部分，</p></li>
<li><p>子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；</p></li>
</ul>
<p>更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串“ acdfg ”同“ akdfc ”的最长公共子串为“ df ”，而它们的最长公共子序列LCS是“ adf ”，LCS可以使用动态规划法解决。</p>
<p><strong>解答：</strong></p>
<p><strong>解法一、</strong> 穷举，所有的计算组合：</p>
<p>或许，读者初看此题，自然会想到最大乘积子序列问题类似于<a href="http://blog.csdn.net/v_JULY_v/article/details/6444021">最大子数组和问题</a>，可能立马会想到用最简单粗暴的方式：两个for循环直接轮询。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">double</span> max=<span class="dv">0</span>;
<span class="dt">double</span> start=<span class="dv">0</span>;
<span class="dt">double</span> end=<span class="dv">0</span>;
<span class="kw">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;num;i++)
{
    <span class="dt">double</span> x=arrs[i];
    <span class="kw">for</span> (<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; num; j++)
    {
        x*=arrs[j];
        <span class="kw">if</span>(x&gt;max)
        {
            max=x;
            start=arrs[i];
            end=arrs[j];
        }
    }
}</code></pre>
<p><strong>解法二、</strong> 虽说类似于最大子数组和问题，但实际上具体处理起来诸多不同。为什么呢，因为乘积子序列中有正有负也还可能有0。我们可以把问题简化成这样：数组中找一个子序列，使得它的乘积最大；同时找一个子序列，使得它的乘积最小（负数的情况）。因为虽然我们只要一个最大积，但由于负数的存在，我们同时找这两个乘积做起来反而方便。也就是说，不但记录最大乘积，也要记录最小乘积。So，我们让</p>
<ul>
<li>maxCurrent表示当前最大乘积的candidate，</li>
<li>minCurrent反之，表示当前最小乘积的candidate，</li>
<li>而maxProduct则记录到目前为止所有最大乘积candidates的最大值。 （以上用candidate这个词是因为只是可能成为新一轮的最大/最小乘积）</li>
</ul>
<p>由于空集的乘积定义为1，在搜索数组前，maxCurrent，minCurrent，maxProduct都赋为1。 假设在任何时刻你已经有了maxCurrent和minCurrent这两个最大/最小乘积的candidates，新读入数组的元素x(i)后，新的最大乘积candidate只可能是maxCurrent或者minCurrent与x(i)的乘积中的较大者，如果x(i) &lt; 0导致maxCurrent &lt; minCurrent，需要交换这两个candidates的值。</p>
<p>当任何时候maxCurrent &lt; 1，由于1（空集）是比maxCurrent更好的candidate，所以更新maxCurrent为1，类似的可以更新minCurrent。任何时候maxCurrent如果比最好的maxProduct大，更新maxProduct。</p>
<p>代码一：</p>
<pre class="sourceCode c"><code class="sourceCode c">template &lt;typename Comparable&gt;    
Comparable maxprod( <span class="dt">const</span> vector&lt;Comparable&gt;&amp;v)    
{    
    <span class="dt">int</span> i;    
    Comparable maxProduct = <span class="dv">1</span>;    
    Comparable minProduct = <span class="dv">1</span>;    
    Comparable maxCurrent = <span class="dv">1</span>;    
    Comparable minCurrent = <span class="dv">1</span>;    
    <span class="co">//Comparable t;    </span>
    
    <span class="kw">for</span>( i=<span class="dv">0</span>; i&lt; v.size() ;i++)    
    {    
        maxCurrent *= v[i];    
        minCurrent *= v[i];    
        <span class="kw">if</span>(maxCurrent &gt; maxProduct)     
            maxProduct = maxCurrent;    
        <span class="kw">if</span>(minCurrent &gt; maxProduct)    
            maxProduct = minCurrent;    
        <span class="kw">if</span>(maxCurrent &lt; minProduct)    
            minProduct = maxCurrent;    
        <span class="kw">if</span>(minCurrent &lt; minProduct)    
            minProduct = minCurrent;    
        <span class="kw">if</span>(minCurrent &gt; maxCurrent)    
            swap(maxCurrent,minCurrent);    
        <span class="kw">if</span>(maxCurrent&lt;<span class="dv">1</span>)    
            maxCurrent = <span class="dv">1</span>;    
        <span class="co">//if(minCurrent&gt;1)    </span>
        <span class="co">//    minCurrent =1;    </span>
    }    
    <span class="kw">return</span> maxProduct;     
}    </code></pre>
<p>代码二：思路，记录以第i个结尾的最大乘积M和最小乘积m，并且记录这两个区间的起点（终点都是i），不断更新，<a href="http://www.51weixue.com/thread-246-1-1.html">来源</a>：</p>
<pre><code>pair&lt;int,int&gt; maxproduct(double *f,int n)
{   //返回最大乘积的起点终点
    int R = 0, r = 0;   //最大最小区间的 起点
    pair&lt;int,int&gt; ret = make_pair(0, 0);   //最大 最小的区间下标
    double M = f[0], m = f[0], answer = f[0];     // 最大 最小值
    for (int i = 1; i &lt; n; ++i)
    {
        double t0 = f[i] * M, t1 = f[i] * m;  
        if (t0 &gt; t1)
        {
            M = t0;  
            m = t1;  
        }  
        else
        {
            int t = R;  
            R = r;  
            r = t;  
            M = t1;  
            m = t0;  
        }  
        if (M &lt; f[i])
        {
            M = f[i];  
            R = i;  
        }  
        if (m &gt; f[i])
        {
            m = f[i];  
            r = i;  
        }  
        if (answer &lt; M)
        {
            answer = M;  
            ret = make_pair(R, i);  
        }  
    }  
    return ret;  
}  </code></pre>
<p><strong>解法三、</strong> 本题除了上述类似最大子数组和的解法，也可以直接用动态规划求解（其实，上述的解法一本质上也是动态规划，只是解题所表现出来的具体形式与接下来的解法二不同罢了。这个不同就在于下面的解法二会写出动态规划问题中经典常见的DP方程，而解法一是直接求解）。具体解法如下：</p>
<p>假设数组为a[]，直接利用动归来求解，考虑到可能存在负数的情况，我们用Max来表示以a结尾的最大连续子串的乘积值，用Min表示以a结尾的最小的子串的乘积值，那么状态转移方程为：</p>
<p>Max=max{a, Max[i-1]<em>a, Min[i-1]</em>a};<br /> Min=min{a, Max[i-1]<em>a, Min[i-1]</em>a};</p>
<p>初始状态为Max[1]=Min[1]=a[1]。</p>
<p>C/C++代码一，很简洁的一小段代码：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">double</span> func(<span class="dt">double</span> *a,<span class="dt">const</span> <span class="dt">int</span> n)  
{  
    <span class="dt">double</span> *maxA = new <span class="dt">double</span>[n];  
    <span class="dt">double</span> *minA = new <span class="dt">double</span>[n];  
    maxA[<span class="dv">0</span>] = minA[<span class="dv">0</span>] =a[<span class="dv">0</span>];  
    <span class="dt">double</span> value = maxA[<span class="dv">0</span>];  
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span> ; i &lt; n ; ++i)  
    {  
        maxA[i] = max(max(a[i],maxA[i<span class="dv">-1</span>]*a[i]),minA[i<span class="dv">-1</span>]*a[i]);  
        minA[i] = min(min(a[i],maxA[i<span class="dv">-1</span>]*a[i]),minA[i<span class="dv">-1</span>]*a[i]);  
        value=max(value,maxA[i]);  
    }  
    <span class="kw">return</span> value;  
}  </code></pre>
<p>C/C++代码二：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*  </span>
<span class="co"> 给定一个浮点数数组，有正有负数，0，正数组成,数组下标从1算起  </span>
<span class="co"> 求最大连续子序列乘积，并输出这个序列，如果最大子序列乘积为负数，那么就输出-1  </span>
<span class="co"> 用Max[i]表示以a[i]结尾乘积最大的连续子序列  </span>
<span class="co"> 用Min[i]表示以a[i]结尾乘积最小的连续子序列  因为有复数，所以保存这个是必须的  </span>
<span class="co">*/</span>    
<span class="dt">void</span> longest_multiple(<span class="dt">double</span> *a,<span class="dt">int</span> n)
{
    <span class="dt">double</span> *Min=new <span class="dt">double</span>[n<span class="dv">+1</span>]();
    <span class="dt">double</span> *Max=new <span class="dt">double</span>[n<span class="dv">+1</span>]();
    <span class="dt">double</span> *p=new <span class="dt">double</span>[n<span class="dv">+1</span>]();
    <span class="co">//初始化</span>
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;=n;i++)
    {
        p[i]=-<span class="dv">1</span>;
    }
    Min[<span class="dv">1</span>]=a[<span class="dv">1</span>];
    Max[<span class="dv">1</span>]=a[<span class="dv">1</span>];
    <span class="dt">double</span> max_val=Max[<span class="dv">1</span>];
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;=n;i++)
    {
        Max[i]=max(Max[i<span class="dv">-1</span>]*a[i],Min[i<span class="dv">-1</span>]*a[i],a[i]);
        Min[i]=min(Max[i<span class="dv">-1</span>]*a[i],Min[i<span class="dv">-1</span>]*a[i],a[i]);
        <span class="kw">if</span>(max_val&lt;Max[i])
        max_val=Max[i];
    }
    <span class="kw">if</span>(max_val&lt;<span class="dv">0</span>)
        printf(<span class="st">&quot;%d&quot;</span>,-<span class="dv">1</span>);
    <span class="kw">else</span>
        printf(<span class="st">&quot;%d&quot;</span>,max_val);
    <span class="co">//内存释放</span>
    delete [] Max;
    delete [] Min;
}  </code></pre>
<p>C#版完整代码(代码来自参加英雄会在线编程挑战之<a href="http://hero.pongo.cn/Question/Details?ID=19&amp;ExamID=19">1019、最大乘积连续子串</a>的在线提交代码的用户)：</p>
<pre><code>//答题英雄：danielqkj  
using System;  
public class Test   
{  
    void Max(double a, double b, double c)  
    {  
        double d = (a&gt;b)?a:b;  
        return (d&gt;c)?d:c;      
    }  
      
    void Min(double a, double b, double c)  
    {  
        double d = (a&gt;b)?b:a;  
        return (d&gt;c)?c:d;  
    }  
      
      
    public static void Main()  
    {  
        int n = Int32.parse(Console.readline());  
        double[] a = new double[n];  
        double maxvalue = a[0];  
        double[] max = new double[n];  
        double[] min = new double[n];  
        double start, end;  
          
        String[] s = Console.readline().split(&#39; &#39;);  
        for (int i = 0; i &lt; n; i++)  
        {  
            a[i] = Double.parse(s[i])  
        }  
          
        max[0] = a[0];  
        min[0] = a[0];  
        start = 0, end = 0;  
          
        for (int i = 1; i &lt; n; i++)  
        {  
            max[i]=Max(a[i], a[i]*max[i-1], a[i]*min[i-1]);  
            min[i]=Min(a[i], a[i]*max[i-1], a[i]*min[i-1]);  
              
            if (max[i] &gt; maxvalue)  
            {  
                maxvalue = max[i];  
                end = i;  
            }  
        }  
          
        double mmm = maxvalue;  
        while ( (mmm - 0.0) &gt; 0.00001 )  
        {  
            start = end;  
            mmm = mmm / a[start];  
        }  
          
        Console.Writeline(a[start] + &quot; &quot; + a[end] + &quot; &quot; + maxvalue);  
          
    }  
}  </code></pre>
<p><strong>变种</strong></p>
<p>此外，此题还有另外的一个变种形式，即给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意（N-1）个数的组合中乘积最大的一组，并写出算法的时间复杂度。</p>
<p>我们可以把所有可能的（N-1）个数的组合找出来，分别计算它们的乘积，并比较大小。由于总共有N个（N-1）个数的组合，总的时间复杂度为O（N2），显然这不是最好的解法。</p>
<p>OK，以下解答来自编程之美</p>
<p><strong>解法1</strong></p>
<figure>
<img src="../images/28~29/28.1.jpg" />
</figure>
<p><strong>解法2、</strong></p>
<p>此外，还可以通过分析，进一步减少解答问题的计算量。假设N个整数的乘积为P，针对P的正负性进行如下分析（其中，AN-1表示N-1个数的组合，PN-1表示N-1个数的组合的乘积）。</p>
<p>1.P为0</p>
<p>那么，数组中至少包含有一个0。假设除去一个0之外，其他N-1个数的乘积为Q，根据Q的正负性进行讨论：</p>
<p>Q为0<br /> 说明数组中至少有两个0，那么N-1个数的乘积只能为0，返回0；<br /> Q为正数<br /> 返回Q，因为如果以0替换此时AN-1中的任一个数，所得到的PN-1为0，必然小于Q；<br /> Q为负数<br /> 如果以0替换此时AN-1中的任一个数，所得到的PN-1为0，大于Q，乘积最大值为0。</p>
<p>2.P为负数</p>
<p>根据“负负得正”的乘法性质，自然想到从N个整数中去掉一个负数，使得PN-1为一个正数。而要使这个正数最大，这个被去掉的负数的绝对值必须是数组中最小的。我们只需要扫描一遍数组，把绝对值最小的负数给去掉就可以了。</p>
<p>3.P为正数</p>
<p>类似地，如果数组中存在正数值，那么应该去掉最小的正数值，否则去掉绝对值最大的负数值。<br />上面的解法采用了直接求N个整数的乘积P，进而判断P的正负性的办法，但是直接求乘积在编译环境下往往会有溢出的危险（这也就是本题要求不使用除法的潜在用意），事实上可做一个小的转变，不需要直接求乘积，而是求出数组中正数（+）、负数（-）和0的个数，从而判断P的正负性，其余部分与以上面的解法相同。</p>
<p>在时间复杂度方面，由于只需要遍历数组一次，在遍历数组的同时就可得到数组中正数（+）、负数（-）和0的个数，以及数组中绝对值最小的正数和负数，时间复杂度为O（N）。</p>
<h2 id="参考文献及推荐阅读">参考文献及推荐阅读</h2>
<ol type="1">
<li>杨氏矩阵查找、最大乘积连续子串、字符串循环右移、社区很忙等5题集中<a href="http://bbs.csdn.net/topics/390398519">讨论地址</a>；<br /></li>
<li><a href="">http://www.bjwilly.com/archives/395.html</a>；</li>
</ol>
<p>July、二零一三年三月二十一日。</p>
<h1 id="第二十九章字符串编辑距离">第二十九章：字符串编辑距离</h1>
<h2 id="前言-4">前言</h2>
<p>上一章和这一章的问题皆是各大IT公司最喜欢出的笔试面试题之一，比如说前者是小米2013年校招笔试原题，而后者则更是反复出现，如去年9月26日百度一二面试题，10月9日腾讯面试题第1小题，10月13日百度2013校招北京站笔试题第二 大道题第3小题，及去年10月15日2013年Google校招笔试最后一道大题皆是考察的这个字符串编辑距离问题。</p>
<p><strong>题目描述:</strong>给定一个源串和目标串，能够对源串进行如下操作：<br />1.在给定位置上插入一个字符<br />2.替换任意字符<br />3.删除任意字符</p>
<p>写一个程序，返回最小操作数，使得对源串进行这些操作后等于目标串，源串和目标串的长度都小于2000。</p>
<p><strong>提醒：</strong>上文前言中已经说过了，此题反复出现，最近考的最多的是百度和Google的笔试面试经常考察。下图则是2013年Google的校招试题原景重现：</p>
<figure>
<img src="../images/28~29/29.1.jpg" />
</figure>
<p><strong>解法一、</strong>此题跟上面的最大连续乘积子串类似，常见的思路是动态规划，下面是简单的DP状态方程：</p>
<pre><code>//动态规划：    
    
//f[i,j]表示s[0...i]与t[0...j]的最小编辑距离。    
f[i,j] = min { f[i-1,j]+1,  f[i,j-1]+1,  f[i-1,j-1]+(s[i]==t[j]?0:1) }    
    
//分别表示：添加1个，删除1个，替换1个（相同就不用替换）。  </code></pre>
<p><strong>解法二、</strong>本解法来自<a href="http://www.51weixue.com/thread-482-1-1.html">为学论坛</a>。</p>
<p>编辑距离的定义和计算方法如下：<br />Given two strings A and B, edit A to B with the minimum number of edit operations:</p>
<ul>
<li><ol type="a">
<li>.Replace a letter with another letter</li>
</ol></li>
<li><ol start="2" type="a">
<li>.Insert a letter</li>
</ol></li>
<li><ol start="3" type="a">
<li>.Delete a letter</li>
</ol></li>
</ul>
<p>E.g.<br />A = interestingly _i<strong>nterestingly<br />B = bioinformatics bioinformatics</strong><br /> 1011011011001111<br />Edit distance = 11<br /> Instead of minimizing the number of edge operations, we can associate a cost function to the operations and minimize the total cost. Such cost is called edit distance. Instead of using string edit, in computational biology, people like to use string alignment.We use similarity function, instead of cost function, to evaluate the goodness of the alignment.<br /> E.g. of similarity function: match – 2, mismatch, insert, delete – -1.<br />Consider two strings ACAATCC and AGCATGC.<br />One of their alignment is</p>
<figure>
<img src="../images/28~29/29.2.jpg" />
</figure>
<p>In the above alignment, space (‘_’) is introduced to both strings. There are 5 matches, 1 mismatch, 1 insert, and 1 delete.The alignment has similarity score 7.<br />A_CAATCC<br />AGCA_TGC<br />Note that the above alignment has the maximum score.Such alignment is called optimal alignment.String alignment problem tries to find the alignment with the maximum similarity score!String alignment problem is also called global alignment problem.<br />Needleman-Wunsch algorithm Consider two strings S[1..n] and T[1..m].Define V(i, j) be the score of the optimal alignment between S[1..i] and T[1..j].<br />Basis:<br />V(0, 0) = 0<br />V(0, j) = V(0, j-1) + d(_, T[j])：Insert j times<br />V(i, 0) = V(i-1, 0) + d(S,_)：Delete i times<br />that is:</p>
<figure>
<img src="../images/28~29/29.3.jpg" />
</figure>
<p>Example :</p>
<figure>
<img src="../images/28~29/29.4.jpg" />
</figure>
<p>下面是代码，测试数据比较少，若有问题请指正：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@ peng_weida  </span>
<span class="co">//实现代码如下：  </span>
<span class="co">//头文件StrEditDistance.h  </span>
<span class="ot">#pragma once  </span>
<span class="ot">#include &lt;string&gt;  </span>
class CStrEditDistance  
{  
public:  
    CStrEditDistance(std::string&amp; vStrRow, std::string&amp; vStrColumn);  
    ~CStrEditDistance(<span class="dt">void</span>);  
    <span class="dt">int</span>  getScore()    { <span class="kw">return</span> m_Score;   }  
    <span class="dt">int</span>  getEditDis()  { <span class="kw">return</span> m_EditDis; }  
    <span class="dt">void</span> setEditDis(<span class="dt">int</span> vDis) { m_EditDis = vDis; }  
    <span class="dt">void</span> setScore(<span class="dt">int</span> vScore) { m_Score = vScore; }  
private:  
    <span class="dt">void</span> process(<span class="dt">const</span> std::string&amp; vStrRow, <span class="dt">const</span> std::string&amp; vStrColumn);  
    <span class="dt">int</span> getMaxValue(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> c)  
    {  
        <span class="kw">if</span> (a &lt; b){ <span class="kw">if</span> (b &lt; c) <span class="kw">return</span> c; <span class="kw">return</span> b; }  
        <span class="kw">else</span> { <span class="kw">if</span> (b &gt; c) <span class="kw">return</span> a; <span class="kw">return</span> a &lt; c ? c : a; }  
    }  
private:  
    <span class="dt">int</span>   m_EditDis;  
    <span class="dt">int</span>   m_Score;  
};  
<span class="co">//源文件StrEditDistance.cpp  </span>
<span class="ot">#include &quot;StrEditDistance.h&quot;  </span>
<span class="ot">#include &lt;iostream&gt;  </span>
<span class="ot">#include &lt;iomanip&gt;  </span>
<span class="ot">#define MATCH        2  </span>
<span class="ot">#define MISS_MATCH   -1  </span>
<span class="ot">#define INSERT       -1  </span>
<span class="ot">#define DELETE       -1  </span>
CStrEditDistance::CStrEditDistance(std::string&amp; vStrRow, std::string&amp; vStrColumn)  
{  
    process(vStrRow, vStrColumn);  
}  
CStrEditDistance::~CStrEditDistance(<span class="dt">void</span>)  
{  
}  
<span class="co">//FUNCTION:  </span>
<span class="dt">void</span> CStrEditDistance::process(<span class="dt">const</span> std::string&amp; vStrRow, <span class="dt">const</span> std::string&amp; vStrColumn)  
{  
    <span class="dt">int</span> editDis = <span class="dv">0</span>;     <span class="co">//编辑距离  </span>
    <span class="dt">int</span> row = vStrColumn.length();    
    <span class="dt">int</span> column = vStrRow.length();  
    <span class="dt">const</span> <span class="dt">int</span> sizeR = row + <span class="dv">1</span>;  
    <span class="dt">const</span> <span class="dt">int</span> sizeC = column + <span class="dv">1</span>;  
   
    <span class="dt">int</span> **pScore = new <span class="dt">int</span>*[sizeR];  <span class="co">//二维指针  </span>
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= row; i++)  
    pScore = new <span class="dt">int</span>[sizeC];  
   
    <span class="co">//初始化第一行和第一列  </span>
    <span class="kw">for</span> (<span class="dt">int</span> c = <span class="dv">0</span>; c &lt;= column; c++)  
        pScore[<span class="dv">0</span>][c] = <span class="dv">0</span> - c;  
    <span class="kw">for</span> (<span class="dt">int</span> r = <span class="dv">0</span>; r &lt;= row; r++)  
        pScore[r][<span class="dv">0</span>] = <span class="dv">0</span> - r;  
   
    <span class="co">//从v(1,1)开始每列计算  </span>
    <span class="kw">for</span> (<span class="dt">int</span> c = <span class="dv">1</span>; c &lt;= column; c++)  
    {  
        <span class="kw">for</span> (<span class="dt">int</span> r = <span class="dv">1</span>; r &lt;= row; r++)  
        {  
          <span class="co">//计算v(i,j)  </span>
          <span class="dt">int</span> valueMatch;  
          <span class="kw">if</span> (vStrColumn[r<span class="dv">-1</span>] == vStrRow[c<span class="dv">-1</span>])  
              valueMatch = MATCH;  
          <span class="kw">else</span>  
              valueMatch = MISS_MATCH;    
          <span class="dt">int</span> A = pScore[r<span class="dv">-1</span>][c] + INSERT;  
          <span class="dt">int</span> B = pScore[r][c<span class="dv">-1</span>] + DELETE;  
          <span class="dt">int</span> C = pScore[r<span class="dv">-1</span>][c<span class="dv">-1</span>] + valueMatch;  
          pScore[r][c] = getMaxValue(A, B, C);  
        }  
    }  
   
    <span class="co">//计算编辑距离  </span>
    <span class="dt">int</span> r = row, c = column;  
    <span class="kw">while</span>(r &gt; <span class="dv">0</span> &amp;&amp; c &gt; <span class="dv">0</span>)  
    {  
        <span class="kw">if</span> (pScore[r][c]+<span class="dv">1</span> == pScore[r<span class="dv">-1</span>][c])      { editDis++; r--; <span class="kw">continue</span>; }  
        <span class="kw">else</span> <span class="kw">if</span> (pScore[r][c]+<span class="dv">1</span> == pScore[r][c<span class="dv">-1</span>]) { editDis++; c--; <span class="kw">continue</span>; }  
        <span class="kw">else</span> <span class="kw">if</span> (pScore[r][c]+<span class="dv">1</span> == pScore[r<span class="dv">-1</span>][c<span class="dv">-1</span>]){ editDis++; r--; c--; <span class="kw">continue</span>; }  
        <span class="kw">else</span> { r--; c--; }  
    }  
    <span class="kw">if</span> (r &gt; <span class="dv">0</span> &amp;&amp; c == <span class="dv">0</span>)  editDis += r;  
    <span class="kw">else</span> <span class="kw">if</span> (c &gt; <span class="dv">0</span> &amp;&amp; r == <span class="dv">0</span>) editDis += c;  
   
    std::cout &lt;&lt; std::endl;  
    <span class="co">//----------------DEBUG-------------------//  </span>
    <span class="co">//打印数据  </span>
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= row; i++)  
    {  
         <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= column; j++)  
         std::cout &lt;&lt; std::setw(<span class="dv">2</span>) &lt;&lt; pScore[j] &lt;&lt; <span class="st">&quot;  &quot;</span>;  
         std::cout &lt;&lt; std::endl;  
    }  
    std::cout &lt;&lt; std::endl;  
   
    <span class="co">//设置编辑距离和得分  </span>
    setEditDis(editDis);  
    setScore(pScore[row][column]);  
   
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= row; i++)   <span class="co">//释放内存  </span>
    {  
        delete pScore;  
        pScore = NULL;  
    }  
    delete[] pScore;  
}  </code></pre>
<p><strong>类似</strong><br />上述问题类似于编程之美上的下述一题「以下内容摘自编程之美第3.3节」：</p>
<p>许多程序会大量使用字符串。对于不同的字符串，我们希望能够有办法判断其相似程度。我们定义了一套操作方法来把两个不相同的字符串变得相同，具体的操作方法为：</p>
<p>1.修改一个字符（如把“a”替换为“b”）；<br />2.增加一个字符（如把“abdd ”变为“aebdd ”）；<br />3.删除一个字符（如把“travelling”变为“traveling”）。</p>
<p>比如，对于“abcdefg”和“abcdef ”两个字符串来说，我们认为可以通过增加/减少一个“g”的方式来达到目的。上面的两种方案，都仅需要一次操作。把这个操作所需要的次数定义为两个字符串的距离，而相似度等于“距离+1”的倒数。也就是说，“abcdefg”和“abcdef”的距离为1，相似度为1 / 2 = 0.5。<br />给定任意两个字符串，你是否能写出一个算法来计算出它们的相似度呢？</p>
<figure>
<img src="../images/28~29/29.5.jpg" />
</figure>
<p>这样，很快就可以完成一个递归程序，如下所示：</p>
<pre class="sourceCode c"><code class="sourceCode c">Int CalculateStringDistance(string strA, <span class="dt">int</span> pABegin, <span class="dt">int</span> pAEnd,    
   string strB, <span class="dt">int</span> pBBegin, <span class="dt">int</span> pBEnd)     
{    
     <span class="kw">if</span>(pABegin &gt; pAEnd)    
     {    
          <span class="kw">if</span>(pBBegin &gt; pBEnd)    
               <span class="kw">return</span> <span class="dv">0</span>;     
          <span class="kw">else</span>    
     
               <span class="kw">return</span> pBEnd – pBBegin + <span class="dv">1</span>;    
     }    
    
     <span class="kw">if</span>(pBBegin &gt; pBEnd)    
     {    
          <span class="kw">if</span>(pABegin &gt; pAEnd)    
               <span class="kw">return</span> <span class="dv">0</span>;    
          <span class="kw">else</span>    
               <span class="kw">return</span> pAEnd – pABegin + <span class="dv">1</span>;    
     }    
    
     <span class="kw">if</span>(strA[pABegin] == strB[pBBegin])    
     {    
          <span class="kw">return</span> CalculateStringDistance(strA, pABegin + <span class="dv">1</span>, pAEnd,    
            strB, pBBegin + <span class="dv">1</span>, pBEnd);    
     }    
     <span class="kw">else</span>    
     {    
          <span class="dt">int</span> t1 = CalculateStringDistance(strA, pABegin, pAEnd, strB,     
            pBBegin + <span class="dv">1</span>, pBEnd);    
          <span class="dt">int</span> t2 = CalculateStringDistance(strA, pABegin + <span class="dv">1</span>, pAEnd,     
            strB,pBBegin, pBEnd);    
          <span class="dt">int</span> t3 = CalculateStringDistance(strA, pABegin + <span class="dv">1</span>, pAEnd,    
            strB,pBBegin + <span class="dv">1</span>, pBEnd);    
          <span class="kw">return</span> minValue(t1,t2,t3) + <span class="dv">1</span>;    
     }    
}    </code></pre>
<p>上面的递归程序，有什么地方需要改进呢？在递归的过程中，有些数据被重复计算了。比如，如果开始我们调用CalculateStringDistance(strA,1, 2, strB, 1, 2)，下图是部分展开的递归调用。</p>
<figure>
<img src="../images/28~29/29.6.jpg" />
</figure>
<p>可以看到，圈中的两个子问题被重复计算了。为了避免这种不必要的重复计算，可以把子问题计算后的解存储起来。如何修改递归程序呢？还是DP！请看此<a href="http://www.cnblogs.com/yujunyong/articles/2004724.html">链接</a>。</p>
<h2 id="深入">深入</h2>
<p>1.详细读者朋友们也已经看到了，百度/Google经常喜欢出这个字符串编辑距离，实际上，关于这个“编辑距离”问题在搜索引擎中有着重要的作用，如搜索引擎关键字查询中拼写错误的提示，如下图所示，当你输入“<a href="https://www.google.com.hk/search?hl=zh-CN&amp;newwindow=1&amp;safe=strict&amp;site=&amp;source=hp&amp;q=Jult&amp;btnK=Google+%E6%90%9C%E7%B4%A2">Jult</a>”后，因为没有这个单词“Jult”，所以搜索引擎猜测你可能是输入错误，进而会提示你是不是找“July”：</p>
<figure>
<img src="../images/28~29/29.7.jpg" />
</figure>
<p>但这个拼写错误检查的原理是什么呢？Google是基于贝叶斯统计推断的方法，相关原理详情可以看下Google的研发总监Peter Norvig写的<a href="http://norvig.com/spell-correct.html">这篇文章</a>，以及fuanyif写的<a href="http://www.ruanyifeng.com/blog/2012/10/spelling_corrector.html">这篇</a>。</p>
<p>2.关于什么是“编辑距离”：一个快速、高效的Levenshtein算法实现，这个是计算两个字符串的算法，Levenshtein距离又称为“编辑距离”，是指两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。当然，次数越小越相似。这里有一个BT树的<a href="http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees">数据结构</a>，挺有意思的。</p>
<p>3.最后，Lucene中也有这个算法的实现(我想，一般的搜索引擎一般都应该会有此项拼写错误检查功能的实现)，下面是lucene的源码(并没有太多优化，与实际工程中java注重实用性的原则并不背离)：</p>
<pre><code>public final class LevensteinDistance {  
   
    public LevensteinDistance () {  
    }  
      
// Compute Levenshtein distance:   
// see org.apache.commons.lang.StringUtils#getLevenshteinDistance(String, String)  
      
    public float getDistance (String target, String other) {  
      char[] sa;  
      int n;  
      int p[];   
//&#39;previous&#39; cost array, horizontally  
      int d[];   
// cost array, horizontally  
      int _d[];   
//placeholder to assist in swapping p and d  
   
        sa = target.toCharArray();  
        n = sa.length;  
        p = new int[n+1];   
        d = new int[n+1];   
         
        final int m = other.length();  
        if (n == 0 || m == 0) {  
          if (n == m) {  
            return 1;  
          }  
          else {  
            return 0;  
          }  
        }   
          
// indexes into strings s and t  
        int i;   
// iterates through s  
        int j;   
// iterates through t  
   
        char t_j;   
// jth character of t  
   
        int cost;   
// cost  
   
        for (i = 0; i&lt;=n; i++) {  
            p[i] = i;  
        }  
   
        for (j = 1; j&lt;=m; j++) {  
            t_j = other.charAt(j-1);  
            d[0] = j;  
   
            for (i=1; i&lt;=n; i++) {  
                cost = sa[i-1]==t_j ? 0 : 1;  
                  
// minimum of cell to the left+1, to the top+1, diagonally left and up +cost  
                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);  
            }  
   
              
// copy current distance counts to &#39;previous row&#39; distance counts  
            _d = p;  
            p = d;  
            d = _d;  
        }  
   
          
// our last action in the above loop was to switch d and p, so p now  
          
// actually has the most recent cost counts  
        return 1.0f - ((float) p[n] / Math.max(other.length(), sa.length));  
    }  
   
}  </code></pre>
<h2 id="扩展">扩展</h2>
<p>当然，面试官还可以继续问下去，如请问，如何设计一个比较这篇文章和上一篇文章相似性的算法？这个问题的讨论可以看看<a href="http://t.cn/zl82CAH">这里</a>。OK，字符串编辑距离这个问题实用性很强，限于篇幅，详情读者自己深入吧。</p>
<h1 id="第三十章字符串转换成整数">第三十章：字符串转换成整数</h1>
<p>输入一个表示整数的字符串，把该字符串转换成整数并输出，例如输入字符串&quot;345&quot;，则输出整数345。 给定函数原型<code>int StrToInt(const char *str)</code> ，完成函数StrToInt，实现字符串转换成整数的功能，不得用库函数atoi（即便准许使用，其对于溢出情况的处理也达不到题目的要求，详情请参看下文第7节末）。</p>
<p>我们来一步一步分析（共9小节，重点在下文第8小节及后续内容），直至写出第一份准确的代码：</p>
<p><em><strong>1</strong></em>. 本题考查的实际上就是字符串转换成整数的问题，或者说是要你自行实现atoi函数。那如何实现把表示整数的字符串正确地转换成整数呢？以&quot;345&quot;作为例子：</p>
<ol type="1">
<li>当我们扫描到字符串的第一个字符'3'时，由于我们知道这是第一位，所以得到数字3。<br /></li>
<li>当扫描到第二个数字'4'时，而之前我们知道前面有一个3，所以便在后面加上一个数字4，那前面的3相当于30，因此得到数字：3*10+4=34。<br /></li>
<li>继续扫描到字符'5'，'5'的前面已经有了34，由于前面的34相当于340，加上后面扫描到的5，最终得到的数是：34*10+5=345。<br />因此，此题的思路便是：每扫描到一个字符，我们便把在之前得到的数字乘以10，然后再加上当前字符表示的数字。</li>
</ol>
<p><em><strong>2</strong></em>. 思路有了，有一些细节需要注意，如zhedahht所说：</p>
<ol type="1">
<li>“由于整数可能不仅仅之含有数字，还有可能以'+'或者'-'开头，表示整数的正负。因此我们需要把这个字符串的第一个字符做特殊处理。如果第一个字符是'+'号，则不需要做任何操作；如果第一个字符是'-'号，则表明这个整数是个负数，在最后的时候我们要把得到的数值变成负数。<br /></li>
<li>接着我们试着处理非法输入。由于输入的是指针，在使用指针之前，我们要做的第一件是判断这个指针是不是为空。如果试着去访问空指针，将不可避免地导致程序崩溃。<br /></li>
<li>另外，输入的字符串中可能含有不是数字的字符。每当碰到这些非法的字符，我们就没有必要再继续转换。<br /></li>
<li>最后一个需要考虑的问题是溢出问题。由于输入的数字是以字符串的形式输入，因此有可能输入一个很大的数字转换之后会超过能够表示的最大的整数而溢出。”</li>
</ol>
<p>比如，当给的字符串是如左边图片所示的时候，有考虑到么？当然，它们各自对应的正确输出如右边图片所示（假定你是在32位系统下，且编译环境是VS2008以上）：</p>
<figure>
<img src="../images/30~31/30.1.jpg" />
</figure>
<p><em><strong>3</strong></em>. 很快，可能你就会写下如下代码：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@zhedahht 2007    </span>
<span class="kw">enum</span> Status {kValid = <span class="dv">0</span>, kInvalid};  
<span class="dt">int</span> g_nStatus = kValid;  
  
<span class="co">// Convert a string into an integer  </span>
<span class="dt">int</span> StrToInt(<span class="dt">const</span> <span class="dt">char</span>* str)  
{  
    g_nStatus = kInvalid;  
    <span class="dt">long</span> <span class="dt">long</span> num = <span class="dv">0</span>;  
  
    <span class="kw">if</span>(str != NULL)  
    {  
        <span class="dt">const</span> <span class="dt">char</span>* digit = str;  
  
        <span class="co">// the first char in the string can be &#39;+&#39; or &#39;-&#39;  </span>
        <span class="dt">bool</span> minus = <span class="kw">false</span>;  
        <span class="kw">if</span>(*digit == &#39;+&#39;)  
            digit ++;  
        <span class="kw">else</span> <span class="kw">if</span>(*digit == &#39;-&#39;)  
        {  
            digit ++;  
            minus = <span class="kw">true</span>;  
        }  
  
        <span class="co">// the remaining chars in the string  </span>
        <span class="kw">while</span>(*digit != &#39;\<span class="dv">0</span>&#39;)  
        {  
            <span class="kw">if</span>(*digit &gt;= &#39;<span class="dv">0</span>&#39; &amp;&amp; *digit &lt;= &#39;<span class="dv">9</span>&#39;)  
            {  
                num = num * <span class="dv">10</span> + (*digit - &#39;<span class="dv">0</span>&#39;);  
  
                <span class="co">// overflow    </span>
                <span class="kw">if</span>(num &gt; std::numeric_limits&lt;<span class="dt">int</span>&gt;::max())  
                {  
                    num = <span class="dv">0</span>;  
                    <span class="kw">break</span>;  
                }  
  
                digit ++;  
            }  
            <span class="co">// if the char is not a digit, invalid input  </span>
            <span class="kw">else</span>  
            {  
                num = <span class="dv">0</span>;  
                <span class="kw">break</span>;  
            }  
        }  
  
        <span class="kw">if</span>(*digit == &#39;\<span class="dv">0</span>&#39;)  
        {  
            g_nStatus = kValid;  
            <span class="kw">if</span>(minus)  
                num = <span class="dv">0</span> - num;  
        }  
    }  
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(num);  
}  </code></pre>
<p>run下上述程序，会发现当输入字符串是下图中红叉叉部分所对应的时候，程序结果出错:</p>
<figure>
<img src="../images/30~31/30.2.jpg" />
</figure>
<p>两个问题：</p>
<p>1.当输入的字符串不是数字，而是字符的时候，比如“1a”，上述程序直接返回了0（而正确的结果应该是得到1）：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// if the char is not a digit, invalid input  </span>
                  <span class="kw">else</span>  
                  {  
                      num = <span class="dv">0</span>;  
                      <span class="kw">break</span>;  
                  } </code></pre>
<p>2.处理溢出时，有问题。因为它遇到溢出情况时，直接返回了0：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// overflow    </span>
                <span class="kw">if</span>(num &gt; std::numeric_limits&lt;<span class="dt">int</span>&gt;::max())  
                {  
                    num = <span class="dv">0</span>;  
                    <span class="kw">break</span>;  
                }  </code></pre>
<p><em><strong>4</strong></em>. 把代码做下微调，如下（注：库函数atoi规定超过int值，按最大值maxint：2147483647来，超过-int按最小值minint：-2147483648来）：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@SP_daiyq 2013/5/29  </span>
<span class="dt">int</span> StrToInt(<span class="dt">const</span> <span class="dt">char</span>* str)  
{  
    <span class="dt">int</span> res = <span class="dv">0</span>; <span class="co">// result  </span>
    <span class="dt">int</span> i = <span class="dv">0</span>; <span class="co">// index of str  </span>
    <span class="dt">int</span> signal = &#39;+&#39;; <span class="co">// signal &#39;+&#39; or &#39;-&#39;  </span>
    <span class="dt">int</span> cur; <span class="co">// current digit  </span>
  
    <span class="kw">if</span> (!str)  
        <span class="kw">return</span> <span class="dv">0</span>;  
  
    <span class="co">// skip backspace  </span>
    <span class="kw">while</span> (isspace(str[i]))  
        i++;  
  
    <span class="co">// skip signal  </span>
    <span class="kw">if</span> (str[i] == &#39;+&#39; || str[i] == &#39;-&#39;)  
    {  
        signal = str[i];  
        i++;  
    }  
  
    <span class="co">// get result  </span>
    <span class="kw">while</span> (str[i] &gt;= &#39;<span class="dv">0</span>&#39; &amp;&amp; str[i] &lt;= &#39;<span class="dv">9</span>&#39;)  
    {  
        cur = str[i] - &#39;<span class="dv">0</span>&#39;;  
  
        <span class="co">// judge overlap or not  </span>
        <span class="kw">if</span> ( (signal == &#39;+&#39;) &amp;&amp; (cur &gt; INT_MAX - res*<span class="dv">10</span>) )  
        {  
            res = INT_MAX;  
            <span class="kw">break</span>;  
        }  
        <span class="kw">else</span> <span class="kw">if</span> ( (signal == &#39;-&#39;) &amp;&amp; (cur -<span class="dv">1</span> &gt; INT_MAX - res*<span class="dv">10</span>) )  
        {  
            res = INT_MIN;  
            <span class="kw">break</span>;  
        }  
  
        res = res * <span class="dv">10</span> + cur;  
        i++;  
    }  
  
    <span class="kw">return</span> (signal == &#39;-&#39;) ? -res : res;  
}  </code></pre>
<p>此时会发现，上面第3小节末所述的第1个小问题（当输入的字符串不是数字，而是字符的时候）解决了：</p>
<figure>
<img src="../images/30~31/30.3.jpg" />
</figure>
<p>但， 上文第3小节末所述的第2个小问题：溢出问题却没有解决。即当给定下述测试数据的时候，问题就来了：</p>
<figure>
<img src="../images/30~31/30.4.jpg" />
</figure>
<p>什么问题呢？比如说用上述代码转换这个字符串：&quot; 10522545459&quot;，它本应得到的正确结果应该是2147483647，但程序实际得到的结果却是：1932610867。故很明显，程序没有解决好上面的第2个小问题：溢出问题。原因是什么呢？咱们来分析下代码，看是如何具体处理溢出情况的：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// judge overlap or not  </span>
        <span class="kw">if</span> ( (signal == &#39;+&#39;) &amp;&amp; (cur &gt; INT_MAX - res*<span class="dv">10</span>) )  
        {  
            res = INT_MAX;  
            <span class="kw">break</span>;  
        }  
        <span class="kw">else</span> <span class="kw">if</span> ( (signal == &#39;-&#39;) &amp;&amp; (cur -<span class="dv">1</span> &gt; INT_MAX - res*<span class="dv">10</span>) )  
        {  
            res = INT_MIN;  
            <span class="kw">break</span>;  
        }  </code></pre>
<p>接着上面的例子来，比如给定字符串&quot; 10522545459&quot;，除去空格有11位，而MAX_INT，即2147483647是10位数，当扫描到最后一个字符‘9’的时候，程序会比较 9 和 2147483647 - 1052254545*10的大小。<br />问题立马就暴露出来了，因为此时让res*10，即让1052254545*10 &gt; MAX_INT，溢出无疑，程序已经出错，再执行下面这行代码已无意义：</p>
<pre class="sourceCode c"><code class="sourceCode c">  cur &gt; INT_MAX - res*<span class="dv">10</span>    </code></pre>
<p>也就是说，对于字符串&quot;10522545459&quot;, 当扫描到最后一个字符‘9’时，根据上文第1小节的字符串转换成整数的思路：“每扫描到一个字符，我们便把在之前得到的数字乘以10，然后再加上当前字符表示的数字”，为了得到最终的整数，我们得如此计算：<br />1052254545*10 + 4，<br />实际上当程序计算到1052254545*10时，<br />1052254545*10 &gt; 2147483647<br />此时已经溢出了,若再执意计算，则程序逻辑将出错，故此后也就不能再判断字串的最后一位4是否大于2147483647%10了（耐不得烦想尽快看到最终正确代码的读者可以直接跳到下文第8节）。</p>
<p><em><strong>5</strong></em>. 上面说给的程序没有“很好的解决溢出问题。由于输入的数字是以字符串的形式输入，因此有可能输入一个很大的数字转换之后会超过能够表示的最大的整数而溢出”。那么，到底代码该如何写呢？</p>
<p>像下面这样？：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@fuwutu 2013/5/29  </span>
<span class="dt">int</span> StrToInt(<span class="dt">const</span> <span class="dt">char</span>* str)  
{  
    bool negative = false;  
    <span class="dt">long</span> <span class="dt">long</span> result = <span class="dv">0</span>;  
    <span class="kw">while</span> (*str == &#39; &#39; || *str == <span class="ch">&#39;\t&#39;</span>)  
    {  
        ++str;  
    }  
    <span class="kw">if</span> (*str == &#39;-&#39;)  
    {  
        negative = true;  
        ++str;  
    }  
    <span class="kw">else</span> <span class="kw">if</span> (*str == &#39;+&#39;)  
    {  
        ++str;  
    }  
  
    <span class="kw">while</span> (*str != &#39;\<span class="dv">0</span>&#39;)  
    {  
        <span class="dt">int</span> n = *str - &#39;<span class="dv">0</span>&#39;;  
        <span class="kw">if</span> (n &lt; <span class="dv">0</span> || n &gt; <span class="dv">9</span>)  
        {  
            <span class="kw">break</span>;  
        }  
  
        <span class="kw">if</span> (negative)  
        {  
            result = result * <span class="dv">10</span> - n;  
            <span class="kw">if</span> (result &lt; -2147483648LL)  
            {  
                result = -2147483648LL;  
            }  
        }  
        <span class="kw">else</span>  
        {  
            result = result * <span class="dv">10</span> + n;  
            <span class="kw">if</span> (result &gt; 2147483647LL)  
            {  
                result = 2147483647LL;  
            }  
        }  
        ++str;  
    }  
  
  <span class="kw">return</span> result;  
}  </code></pre>
<p>run下程序，看看运行结果：</p>
<figure>
<img src="../images/30~31/30.5.jpg" />
</figure>
<p>上图所示程序貌似通过了，然实际上它还是未能处理数据溢出的问题，因为它只是做了个取巧，即把返回的值result定义成了long long，如下所示：</p>
<pre class="sourceCode c"><code class="sourceCode c">  <span class="dt">long</span> <span class="dt">long</span> result = <span class="dv">0</span>;  </code></pre>
<p>故严格说来，我们依然未写出准确的规范代码</p>
<p><em><strong>6</strong></em>. 那到底该如何解决这个数据溢出的问题呢？咱们先来看看Microsoft是如何实现atoi的吧：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//atol函数  </span>
<span class="co">//Copyright (c) 1989-1997, Microsoft Corporation. All rights reserved.  </span>
<span class="dt">long</span> __cdecl atol(  
    <span class="dt">const</span> <span class="dt">char</span> *nptr  
    )  
{  
    <span class="dt">int</span> c; <span class="co">/* current char */</span>  
    <span class="dt">long</span> total; <span class="co">/* current total */</span>  
    <span class="dt">int</span> sign; <span class="co">/* if &#39;-&#39;, then negative, otherwise positive */</span>  
  
    <span class="co">/* skip whitespace */</span>  
    <span class="kw">while</span> ( isspace((<span class="dt">int</span>)(<span class="dt">unsigned</span> <span class="dt">char</span>)*nptr) )  
        ++nptr;  
  
    c = (<span class="dt">int</span>)(<span class="dt">unsigned</span> <span class="dt">char</span>)*nptr++;  
    sign = c; <span class="co">/* save sign indication */</span>  
    <span class="kw">if</span> (c == &#39;-&#39; || c == &#39;+&#39;)  
        c = (<span class="dt">int</span>)(<span class="dt">unsigned</span> <span class="dt">char</span>)*nptr++; <span class="co">/* skip sign */</span>  
  
    total = <span class="dv">0</span>;  
  
    <span class="kw">while</span> (isdigit(c)) {  
        total = <span class="dv">10</span> * total + (c - &#39;<span class="dv">0</span>&#39;); <span class="co">/* accumulate digit */</span>  
        c = (<span class="dt">int</span>)(<span class="dt">unsigned</span> <span class="dt">char</span>)*nptr++; <span class="co">/* get next char */</span>  
    }  
  
    <span class="kw">if</span> (sign == &#39;-&#39;)  
        <span class="kw">return</span> -total;  
    <span class="kw">else</span>  
        <span class="kw">return</span> total; <span class="co">/* return result, negated if necessary */</span>  
}  </code></pre>
<p>其中，isspace和isdigit函数的实现代码为：</p>
<pre class="sourceCode c"><code class="sourceCode c">isspace(<span class="dt">int</span> x)    
{    
    <span class="kw">if</span>(x==&#39; &#39;||x==&#39;/t&#39;||x==&#39;/n&#39;||x==&#39;/f&#39;||x==&#39;/b&#39;||x==&#39;/r&#39;)    
        <span class="kw">return</span> <span class="dv">1</span>;    
    <span class="kw">else</span>     
        <span class="kw">return</span> <span class="dv">0</span>;    
}    
  
isdigit(<span class="dt">int</span> x)    
{    
    <span class="kw">if</span>(x&lt;=&#39;<span class="dv">9</span>&#39;&amp;&amp;x&gt;=&#39;<span class="dv">0</span>&#39;)             
        <span class="kw">return</span> <span class="dv">1</span>;     
    <span class="kw">else</span>     
        <span class="kw">return</span> <span class="dv">0</span>;    
}   </code></pre>
<p>然后atoi调用上面的atol函数，如下所示：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//atoi调用上述的atol  </span>
<span class="dt">int</span> __cdecl atoi(  
    <span class="dt">const</span> <span class="dt">char</span> *nptr  
    )  
{  
    <span class="co">//Overflow is not detected. Because of this, we can just use  </span>
    <span class="kw">return</span> (<span class="dt">int</span>)atol(nptr);  
}  </code></pre>
<p>但很遗憾的是，上述atoi标准代码依然返回的是long：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">long</span> total; <span class="co">/* current total */</span>  
<span class="kw">if</span> (sign == &#39;-&#39;)  
    <span class="kw">return</span> -total;  
<span class="kw">else</span>  
    <span class="kw">return</span> total; <span class="co">/* return result, negated if necessary */</span>  </code></pre>
<p>再者，下面这里定义成long的total与10相乘，即total*10很容易溢出：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">long</span> total; <span class="co">/* current total */</span>  
total = <span class="dv">10</span> * total + (c - &#39;<span class="dv">0</span>&#39;); <span class="co">/* accumulate digit */</span>  </code></pre>
<p>最后，根据本文评论下的读者meiyuli反应：“测试数据是字符串&quot;-21474836480&quot;，api算出来的是-2147483648，用上述代码算出来的结果是0”，如此，上述微软的这个atoi源码是有问题的。<br /><em><strong>7</strong></em>. microsoft既然不行，读者想必很自然的想到linux。So，咱们接下来便看看linux内核中是如何实现此字符串转换为整数的问题的。linux内核中提供了以下几个函数：</p>
<ol type="1">
<li>simple_strtol，把一个字符串转换为一个有符号长整数；<br /></li>
<li>simple_strtoll，把一个字符串转换为一个有符号长长整数；<br /></li>
<li>simple_strtoul，把一个字符串转换为一个无符号长整数；<br /></li>
<li>simple_strtoull，把一个字符串转换为一个无符号长长整数</li>
</ol>
<p>相关源码及分析如下。<br />首先，atoi调下面的strtol：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//linux/lib/vsprintf.c  </span>
<span class="co">//Copyright (C) 1991, 1992  Linus Torvalds  </span>
<span class="co">//simple_strtol - convert a string to a signed long  </span>
<span class="dt">long</span> simple_strtol(<span class="dt">const</span> <span class="dt">char</span> *cp, <span class="dt">char</span> **endp, <span class="dt">unsigned</span> <span class="dt">int</span> base)  
{  
    <span class="kw">if</span> (*cp == &#39;-&#39;)  
        <span class="kw">return</span> -simple_strtoul(cp + <span class="dv">1</span>, endp, base);  
  
    <span class="kw">return</span> simple_strtoul(cp, endp, base);  
}  
EXPORT_SYMBOL(simple_strtol);  </code></pre>
<p>然后，上面的strtol调下面的strtoul：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//simple_strtoul - convert a string to an unsigned long  </span>
<span class="dt">unsigned</span> <span class="dt">long</span> simple_strtoul(<span class="dt">const</span> <span class="dt">char</span> *cp, <span class="dt">char</span> **endp, <span class="dt">unsigned</span> <span class="dt">int</span> base)  
{  
    <span class="kw">return</span> simple_strtoull(cp, endp, base);  
}  </code></pre>
<p>接着，上面的strtoul调下面的strtoull：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//simple_strtoll - convert a string to a signed long long  </span>
<span class="dt">long</span> <span class="dt">long</span> simple_strtoll(<span class="dt">const</span> <span class="dt">char</span> *cp, <span class="dt">char</span> **endp, <span class="dt">unsigned</span> <span class="dt">int</span> base)  
{  
    <span class="kw">if</span> (*cp == &#39;-&#39;)  
        <span class="kw">return</span> -simple_strtoull(cp + <span class="dv">1</span>, endp, base);  
  
    <span class="kw">return</span> simple_strtoull(cp, endp, base);  
}  </code></pre>
<p>最后，strtoull调<code>_parse_integer_fixup_radix</code>和<code>_parse_integer</code>来处理相关逻辑：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//simple_strtoull - convert a string to an unsigned long long  </span>
<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> simple_strtoull(<span class="dt">const</span> <span class="dt">char</span> *cp, <span class="dt">char</span> **endp, <span class="dt">unsigned</span> <span class="dt">int</span> base)  
{  
    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> result;  
    <span class="dt">unsigned</span> <span class="dt">int</span> rv;  
  
    cp = _parse_integer_fixup_radix(cp, &amp;base);  
    rv = _parse_integer(cp, base, &amp;result);  
    <span class="co">/* FIXME */</span>  
    cp += (rv &amp; ~KSTRTOX_OVERFLOW);  
  
    <span class="kw">if</span> (endp)  
        *endp = (<span class="dt">char</span> *)cp;  
  
    <span class="kw">return</span> result;  
}  </code></pre>
<p>重头戏来了。接下来，我们来看上面strtoull函数中的<code>parse_integer_fixup_radix</code>和<code>_parse_integer</code>两段代码。如鲨鱼所说</p>
<ul>
<li>“真正的处理逻辑主要是在<code>_parse_integer</code>里面，关于溢出的处理，<code>_parse_integer</code>处理的很优美，<br /></li>
<li>而<code>_parse_integer_fixup_radix</code>是用来自动根据字符串判断进制的”。</li>
</ul>
<p>先来看<code>_parse_integer</code>函数：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//lib/kstrtox.c, line 39    </span>
<span class="co">//Convert non-negative integer string representation in explicitly given radix to an integer.    </span>
<span class="co">//Return number of characters consumed maybe or-ed with overflow bit.    </span>
<span class="co">//If overflow occurs, result integer (incorrect) is still returned.    </span>
<span class="dt">unsigned</span> <span class="dt">int</span> _parse_integer(<span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">unsigned</span> <span class="dt">int</span> base, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> *p)    
{    
    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> res;    
    <span class="dt">unsigned</span> <span class="dt">int</span> rv;    
    <span class="dt">int</span> overflow;    
    
    res = <span class="dv">0</span>;    
    rv = <span class="dv">0</span>;    
    overflow = <span class="dv">0</span>;    
    <span class="kw">while</span> (*s) {    
        <span class="dt">unsigned</span> <span class="dt">int</span> val;    
    
        <span class="kw">if</span> (&#39;<span class="dv">0</span>&#39; &lt;= *s &amp;&amp; *s &lt;= &#39;<span class="dv">9</span>&#39;)    
            val = *s - &#39;<span class="dv">0</span>&#39;;    
        <span class="kw">else</span> <span class="kw">if</span> (&#39;a&#39; &lt;= _tolower(*s) &amp;&amp; _tolower(*s) &lt;= &#39;f&#39;)    
            val = _tolower(*s) - &#39;a&#39; + <span class="dv">10</span>;    
        <span class="kw">else</span>    
            <span class="kw">break</span>;    
    
        <span class="kw">if</span> (val &gt;= base)    
            <span class="kw">break</span>;    
        <span class="co">/*  </span>
<span class="co">         * Check for overflow only if we are within range of  </span>
<span class="co">         * it in the max base we support (16)  </span>
<span class="co">         */</span>    
        <span class="kw">if</span> (unlikely(res &amp; (~0ull &lt;&lt; <span class="dv">60</span>))) {    
            <span class="kw">if</span> (res &gt; div_u64(ULLONG_MAX - val, base))    
                overflow = <span class="dv">1</span>;    
        }    
        res = res * base + val;    
        rv++;    
        s++;    
    }    
    *p = res;    
    <span class="kw">if</span> (overflow)    
        rv |= KSTRTOX_OVERFLOW;    
    <span class="kw">return</span> rv;    
}  </code></pre>
<p>解释下两个小细节：</p>
<p>1.上头出现了个unlikely，其实unlikely和likely经常出现在linux相关内核源码中</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span>(likely(value)){  
    <span class="co">//等价于if(likely(value)) == if(value)  </span>
}  
<span class="kw">else</span>{  
}  </code></pre>
<p>likely表示value为真的可能性更大，而unlikely表示value为假的可能性更大，这两个宏被定义成：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//include/linux/compiler.h  </span>
<span class="ot"># ifndef likely  </span>
<span class="ot">#  define likely(x) (__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 1))  </span>
<span class="ot"># endif  </span>
<span class="ot"># ifndef unlikely  </span>
<span class="ot">#  define unlikely(x)   (__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 0))  </span>
<span class="ot"># endif  </span></code></pre>
<p>2.呈现下div_u64的代码：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//include/linux/math64.h  </span>
<span class="co">//div_u64  </span>
<span class="dt">static</span> <span class="kw">inline</span> u64 div_u64(u64 dividend, u32 divisor)  
{  
    u32 remainder;  
    <span class="kw">return</span> div_u64_rem(dividend, divisor, &amp;remainder);  
}  
  
<span class="co">//div_u64_rem  </span>
<span class="dt">static</span> <span class="kw">inline</span> u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)  
{  
    *remainder = dividend % divisor;  
    <span class="kw">return</span> dividend / divisor;  
} </code></pre>
<p>最后看下<code>_parse_integer_fixup_radix</code>函数：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//lib/kstrtox.c, line 23  </span>
<span class="dt">const</span> <span class="dt">char</span> *_parse_integer_fixup_radix(<span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">unsigned</span> <span class="dt">int</span> *base)  
{  
    <span class="kw">if</span> (*base == <span class="dv">0</span>) {  
        <span class="kw">if</span> (s[<span class="dv">0</span>] == &#39;<span class="dv">0</span>&#39;) {  
            <span class="kw">if</span> (_tolower(s[<span class="dv">1</span>]) == &#39;x&#39; &amp;&amp; isxdigit(s[<span class="dv">2</span>]))  
                *base = <span class="dv">16</span>;  
            <span class="kw">else</span>  
                *base = <span class="dv">8</span>;  
        } <span class="kw">else</span>  
            *base = <span class="dv">10</span>;  
    }  
    <span class="kw">if</span> (*base == <span class="dv">16</span> &amp;&amp; s[<span class="dv">0</span>] == &#39;<span class="dv">0</span>&#39; &amp;&amp; _tolower(s[<span class="dv">1</span>]) == &#39;x&#39;)  
        s += <span class="dv">2</span>;  
    <span class="kw">return</span> s;  
}  </code></pre>
<p>读者MJN君在我的建议下，对上述linux内核中的atoi函数进行了测试，咱们来看下测试结果如何。</p>
<figure>
<img src="../images/30~31/30.6.jpg" />
</figure>
<p>如上，根据程序的输出结果可以看出，对于某些溢出的情况，atoi程序的处理并不符合本题的要求。<br />也就是说，atoi程序对溢出的处理是一个标准，而本题要求对溢出的处理则是另外一个标准，所以说直接用atoi程序达不到本题的要求，但你不能因为本题的标准而否认atoi程序的正确性。<br />既然直接借用atoi的源码（原理是parseXXX，<code>int i=Integer.parseInt(String str)</code>，把str转换成int的方法），不符合题目要求，则咱们另寻他路。<br />路漫漫其修远兮，吾等将上下而求索，但与此同时，我们已渐入佳境。</p>
<p><em><strong>8</strong></em>. 根据我们第1小节达成一致的字符串转换成整数的思路：“每扫描到一个字符，我们便把在之前得到的数字乘以10，然后再加上当前字符表示的数字”，相信读者已经觉察到，在扫描到最后一个字符的时候，如果之前得到的数比较大，此时若再让其扩大10倍，相对来说是比较容易溢出的。</p>
<p>但车到山前必有路，既然让一个比较大的int整型数括大10倍，比较容易溢出， 那么在不好判断是否溢出的情况下，可以尝试使用除法。即如MJN所说：</p>
<ol type="1">
<li>与其将n扩大10倍,，冒着溢出的风险, 再与MAX_INT进行比较（如果已经溢出, 则比较的结果没有意义），<br /></li>
<li>不如未雨绸缪先用n与MAX_INT/10进行比较： 若n&gt;MAX_INT/10（当然同时还要考虑n=MAX_INT/10的情况）， 说明最终得到的整数一定会溢出， 故此时可以当即进行溢出处理，直接返回最大值MAX_INT，从而也就免去了计算n*10这一步骤。</li>
</ol>
<p>也就是说，计算n*10前,先比较n与MAX_INT/10大小，若n&gt;MAX_INT/10，那么n*10肯定大于MAX_INT，即代表最后得到的整数n肯定溢出，既然溢出，不能再计算n*10，直接提前返回MAX_INT就行了。</p>
<p>一直以来，我们努力的目的归根结底是为了更好的处理溢出，但上述做法最重要的是巧妙的规避了计算n*10这一乘法步骤，转换成计算除法MAX_INT/10代替，不能不说此法颇妙。</p>
<p>他的代码如下，如有问题请指出：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@njnu_mjn 2013  </span>
<span class="dt">int</span> StrToDecInt(<span class="dt">const</span> <span class="dt">char</span>* str)      
{      
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> MAX = (<span class="dt">int</span>)((<span class="dt">unsigned</span>)~<span class="dv">0</span> &gt;&gt; <span class="dv">1</span>);      
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> MIN = -(<span class="dt">int</span>)((<span class="dt">unsigned</span>)~<span class="dv">0</span> &gt;&gt; <span class="dv">1</span>) - <span class="dv">1</span>;      
    <span class="dt">unsigned</span> <span class="dt">int</span> n = <span class="dv">0</span>;      
    <span class="dt">int</span> sign = <span class="dv">1</span>;      
    <span class="dt">int</span> c;      
      
    <span class="kw">while</span> (isspace(*str))      
        ++str;      
    <span class="kw">if</span> (*str == &#39;+&#39; || *str == &#39;-&#39;)      
    {      
        <span class="kw">if</span> (*str == &#39;-&#39;)      
            sign = -<span class="dv">1</span>;      
        ++str;      
    }      
    <span class="kw">while</span> (isdigit(*str))      
    {      
        c = *str - &#39;<span class="dv">0</span>&#39;;      
        <span class="kw">if</span> (sign &gt; <span class="dv">0</span> &amp;&amp; (n &gt; MAX/<span class="dv">10</span> || (n == MAX/<span class="dv">10</span> &amp;&amp; c &gt; MAX%<span class="dv">10</span>)))      
        {      
            n = MAX;      
            <span class="kw">break</span>;      
        }      
        <span class="kw">else</span> <span class="kw">if</span> (sign &lt; <span class="dv">0</span> &amp;&amp; (n &gt; (<span class="dt">unsigned</span>)MIN/<span class="dv">10</span>       
                              || (n == (<span class="dt">unsigned</span>)MIN/<span class="dv">10</span> &amp;&amp; c &gt; (<span class="dt">unsigned</span>)MIN%<span class="dv">10</span>)))      
        {      
            n = MIN;      
            <span class="kw">break</span>;      
        }      
        n = n * <span class="dv">10</span> + c;      
        ++str;      
    }      
    <span class="kw">return</span> sign &gt; <span class="dv">0</span> ? n : -n;      
}    </code></pre>
<p>上述代码从测试结果来看，暂未发现什么问题</p>
<figure>
<img src="../images/30~31/30.7.jpg" />
</figure>
<p>咱们再来总结下上述代码是如何处理溢出情况的。对于正数来说，它溢出的可能性有两种：</p>
<ol type="1">
<li>一种是诸如2147483650，即n &gt; MAX/10 的；<br /></li>
<li>一种是诸如2147483649，即n == MAX/10 &amp;&amp; c &gt; MAX%10。<br />故咱们上面处理溢出情况的代码便是：</li>
</ol>
<pre class="sourceCode c"><code class="sourceCode c">c = *str - &#39;<span class="dv">0</span>&#39;;    
<span class="kw">if</span> (sign &gt; <span class="dv">0</span> &amp;&amp; (n &gt; MAX/<span class="dv">10</span> || (n == MAX/<span class="dv">10</span> &amp;&amp; c &gt; MAX%<span class="dv">10</span>)))    
{    
    n = MAX;    
    <span class="kw">break</span>;    
}    
<span class="kw">else</span> <span class="kw">if</span> (sign &lt; <span class="dv">0</span> &amp;&amp; (n &gt; (<span class="dt">unsigned</span>)MIN/<span class="dv">10</span>     
                  || (n == (<span class="dt">unsigned</span>)MIN/<span class="dv">10</span> &amp;&amp; c &gt; (<span class="dt">unsigned</span>)MIN%<span class="dv">10</span>)))    
{    
    n = MIN;    
    <span class="kw">break</span>;    
}    </code></pre>
<p>不过，即便如此，有些细节是改进的，如他自己所说：</p>
<p>1.n的声明及定义应该为</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> n = <span class="dv">0</span>; </code></pre>
<p>2.将MAX/10,MAX%10,(unsigned)MIN/10及(unsigned)MIN%10保存到变量中, 防止重复计算</p>
<p>这样，优化后的代码为：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@njnu_mjn 2013  </span>
<span class="dt">int</span> StrToDecInt(<span class="dt">const</span> <span class="dt">char</span>* str)    
{    
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> MAX = (<span class="dt">int</span>)((<span class="dt">unsigned</span>)~<span class="dv">0</span> &gt;&gt; <span class="dv">1</span>);    
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> MIN = -(<span class="dt">int</span>)((<span class="dt">unsigned</span>)~<span class="dv">0</span> &gt;&gt; <span class="dv">1</span>) - <span class="dv">1</span>;    
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> MAX_DIV = (<span class="dt">int</span>)((<span class="dt">unsigned</span>)~<span class="dv">0</span> &gt;&gt; <span class="dv">1</span>) / <span class="dv">10</span>;    
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> MIN_DIV = (<span class="dt">int</span>)((((<span class="dt">unsigned</span>)~<span class="dv">0</span> &gt;&gt; <span class="dv">1</span>) + <span class="dv">1</span>) / <span class="dv">10</span>);    
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> MAX_R = (<span class="dt">int</span>)((<span class="dt">unsigned</span>)~<span class="dv">0</span> &gt;&gt; <span class="dv">1</span>) % <span class="dv">10</span>;    
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> MIN_R = (<span class="dt">int</span>)((((<span class="dt">unsigned</span>)~<span class="dv">0</span> &gt;&gt; <span class="dv">1</span>) + <span class="dv">1</span>) % <span class="dv">10</span>);    
    <span class="dt">int</span> n = <span class="dv">0</span>;    
    <span class="dt">int</span> sign = <span class="dv">1</span>;    
    <span class="dt">int</span> c;    
    
    <span class="kw">while</span> (isspace(*str))    
        ++str;    
    <span class="kw">if</span> (*str == &#39;+&#39; || *str == &#39;-&#39;)    
    {    
        <span class="kw">if</span> (*str == &#39;-&#39;)    
            sign = -<span class="dv">1</span>;    
        ++str;    
    }    
    <span class="kw">while</span> (isdigit(*str))    
    {    
        c = *str - &#39;<span class="dv">0</span>&#39;;    
        <span class="kw">if</span> (sign &gt; <span class="dv">0</span> &amp;&amp; (n &gt; MAX_DIV || (n == MAX_DIV &amp;&amp; c &gt;= MAX_R)))    
        {    
            n = MAX;    
            <span class="kw">break</span>;    
        }    
        <span class="kw">else</span> <span class="kw">if</span> (sign &lt; <span class="dv">0</span> &amp;&amp; (n &gt; MIN_DIV     
                          || (n == MIN_DIV &amp;&amp; c &gt;= MIN_R)))    
        {    
            n = MIN;    
            <span class="kw">break</span>;    
        }    
        n = n * <span class="dv">10</span> + c;    
        ++str;    
    }    
    <span class="kw">return</span> sign &gt; <span class="dv">0</span> ? n : -n;    
}    </code></pre>
<p>部分数据的测试结果如下图所示：</p>
<figure>
<img src="../images/30~31/30.8.jpg" />
</figure>
<p>是否已是完美？如MJN君本人所说“我的实现与linux内核的atoi函数的实现, 都有一个共同的问题: 即使出错, 函数也返回了一个值, 导致调用者误认为自己传入的参数是正确的, 但是可能会导致程序的其他部分产生莫名的错误且很难调试”。</p>
<p><em><strong>9</strong></em>. 最后看下Nut/OS中atoi的实现，同时，本小节内容主要来自参考文献条目9，即MJN的博客：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;compiler.h&gt;  </span>
<span class="ot">#include &lt;stdlib.h&gt;  </span>
  
<span class="dt">int</span> atoi(CONST <span class="dt">char</span> *str)  
{  
    <span class="kw">return</span> ((<span class="dt">int</span>) strtol(str, (<span class="dt">char</span> **) NULL, <span class="dv">10</span>));  
}  </code></pre>
<p>上述代码中strtol实现的思想跟上文第7节所述的MJN君的思路类似，也是除法代替乘法。加上测试函数后的具体代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;errno.h&gt;  </span>
<span class="ot">#include &lt;stdio.h&gt;  </span>
<span class="ot">#include &lt;ctype.h&gt;  </span>
<span class="ot">#include &lt;limits.h&gt;  </span>
  
<span class="ot">#define CONST const  </span>
  
<span class="dt">long</span> mstrtol(CONST <span class="dt">char</span> *nptr, <span class="dt">char</span> **endptr, <span class="dt">int</span> base)  
{  
    <span class="dt">register</span> CONST <span class="dt">char</span> *s;  
    <span class="dt">register</span> <span class="dt">long</span> acc, cutoff;  
    <span class="dt">register</span> <span class="dt">int</span> c;  
    <span class="dt">register</span> <span class="dt">int</span> neg, any, cutlim;  
  
    <span class="co">/* </span>
<span class="co">     * Skip white space and pick up leading +/- sign if any. </span>
<span class="co">     * If base is 0, allow 0x for hex and 0 for octal, else </span>
<span class="co">     * assume decimal; if base is already 16, allow 0x. </span>
<span class="co">     */</span>  
    s = nptr;  
    <span class="kw">do</span>
    {
        c = (<span class="dt">unsigned</span> <span class="dt">char</span>) *s++;
    }
    <span class="kw">while</span> (isspace(c));
    <span class="kw">if</span> (c == &#39;-&#39;)
    {
        neg = <span class="dv">1</span>;
        c = *s++;
    }
    <span class="kw">else</span>
    {
        neg = <span class="dv">0</span>;
        <span class="kw">if</span> (c == &#39;+&#39;)
            c = *s++;
    }
    <span class="kw">if</span> ((base == <span class="dv">0</span> || base == <span class="dv">16</span>) &amp;&amp; c == &#39;<span class="dv">0</span>&#39; &amp;&amp; (*s == &#39;x&#39; || *s == &#39;X&#39;))
    {
        c = s[<span class="dv">1</span>];
        s += <span class="dv">2</span>;
        base = <span class="dv">16</span>;
    }
    <span class="kw">if</span> (base == <span class="dv">0</span>)
        base = c == &#39;<span class="dv">0</span>&#39; ? <span class="dv">8</span> : <span class="dv">10</span>;
  
    <span class="co">/* </span>
<span class="co">     * Compute the cutoff value between legal numbers and illegal </span>
<span class="co">     * numbers.  That is the largest legal value, divided by the </span>
<span class="co">     * base.  An input number that is greater than this value, if </span>
<span class="co">     * followed by a legal input character, is too big.  One that </span>
<span class="co">     * is equal to this value may be valid or not; the limit </span>
<span class="co">     * between valid and invalid numbers is then based on the last </span>
<span class="co">     * digit.  For instance, if the range for longs is </span>
<span class="co">     * [-2147483648..2147483647] and the input base is 10, </span>
<span class="co">     * cutoff will be set to 214748364 and cutlim to either </span>
<span class="co">     * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated </span>
<span class="co">     * a value &gt; 214748364, or equal but the next digit is &gt; 7 (or 8), </span>
<span class="co">     * the number is too big, and we will return a range error. </span>
<span class="co">     * </span>
<span class="co">     * Set any if any &#39;digits&#39; consumed; make it negative to indicate </span>
<span class="co">     * overflow. </span>
<span class="co">     */</span>  
    cutoff = neg ? LONG_MIN : LONG_MAX;
    cutlim = cutoff % base;
    cutoff /= base;
    <span class="kw">if</span> (neg)
    {
        <span class="kw">if</span> (cutlim &gt; <span class="dv">0</span>)
    {
            cutlim -= base;
            cutoff += <span class="dv">1</span>;
        }
        cutlim = -cutlim;
    }
    <span class="kw">for</span> (acc = <span class="dv">0</span>, any = <span class="dv">0</span>;; c = (<span class="dt">unsigned</span> <span class="dt">char</span>) *s++)
    {
        <span class="kw">if</span> (isdigit(c))
            c -= &#39;<span class="dv">0</span>&#39;;
        <span class="kw">else</span> <span class="kw">if</span> (isalpha(c))
            c -= isupper(c) ? &#39;A&#39; - <span class="dv">10</span> : &#39;a&#39; - <span class="dv">10</span>;
        <span class="kw">else</span>
            <span class="kw">break</span>;
        <span class="kw">if</span> (c &gt;= base)
            <span class="kw">break</span>;
        <span class="kw">if</span> (any &lt; <span class="dv">0</span>)
            <span class="kw">continue</span>;
        <span class="kw">if</span> (neg)
        {
            <span class="kw">if</span> ((acc &lt; cutoff || acc == cutoff) &amp;&amp; c &gt; cutlim)
            {
                any = -<span class="dv">1</span>;
                acc = LONG_MIN;
                errno = ERANGE;
            }
            <span class="kw">else</span>
            {
                any = <span class="dv">1</span>;
                acc *= base;
                acc -= c;
            }
        }
        <span class="kw">else</span>
        {
            <span class="kw">if</span> ((acc &gt; cutoff || acc == cutoff) &amp;&amp; c &gt; cutlim)
            {
                any = -<span class="dv">1</span>;
                acc = LONG_MAX;
                errno = ERANGE;
            }
            <span class="kw">else</span>
            {
                any = <span class="dv">1</span>;
                acc *= base;
                acc += c;
            }
        }
    }
    <span class="kw">if</span> (endptr != <span class="dv">0</span>)
        *endptr = (<span class="dt">char</span> *) (any ? s - <span class="dv">1</span> : nptr);
    <span class="kw">return</span> (acc);
}
  
<span class="dt">int</span> matoi2(CONST <span class="dt">char</span> *str)  
{  
    <span class="kw">return</span> ((<span class="dt">int</span>) mstrtol(str, (<span class="dt">char</span> **) NULL, <span class="dv">10</span>));  
}  
  
<span class="dt">int</span> mgetline(<span class="dt">char</span>* buf, size_t n)
{
    size_t idx = <span class="dv">0</span>;
    <span class="dt">int</span> c;

    <span class="kw">while</span> (--n &gt; <span class="dv">0</span> &amp;&amp; (c = getchar()) != EOF &amp;&amp; c != <span class="ch">&#39;\n&#39;</span>)
    {
        buf[idx++] = c;
    }
    buf[idx] = &#39;\<span class="dv">0</span>&#39;;
    <span class="kw">return</span> idx;
}  
  
<span class="ot">#define MAX_LINE 200  </span>
  
<span class="dt">int</span> main()
{
    <span class="dt">char</span> buf[MAX_LINE];
    <span class="kw">while</span> (mgetline(buf, MAX_LINE) &gt;= <span class="dv">0</span>)
    {
        <span class="kw">if</span> (strcmp(buf, <span class="st">&quot;quit&quot;</span>) == <span class="dv">0</span>) <span class="kw">break</span>;
        printf(<span class="st">&quot;matoi2=%d</span><span class="ch">\n</span><span class="st">&quot;</span>, matoi2(buf));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>同样，MJN对上述实现测试了下，结果如下:</p>
<figure>
<img src="../images/30~31/30.9.jpg" />
</figure>
<p>程序貌似对溢出的处理是正确的, 真的吗? 再把测试数据换成&quot;10522545454&quot;（与&quot;10522545459&quot;的区别在于最后一个字符）</p>
<figure>
<img src="../images/30~31/30.10.jpg" />
</figure>
<p>症结就在于下面这段代码：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span> (neg)
{
    <span class="kw">if</span> ((acc &lt; cutoff || acc == cutoff) &amp;&amp; c &gt; cutlim)
    {
        any = -<span class="dv">1</span>;
        acc = LONG_MIN;
        errno = ERANGE;
    }
    <span class="kw">else</span>
    {
        any = <span class="dv">1</span>;
        acc *= base;
        acc -= c;
    }
}
<span class="kw">else</span>
{
    <span class="kw">if</span> ((acc &gt; cutoff || acc == cutoff) &amp;&amp; c &gt; cutlim)
    {
        any = -<span class="dv">1</span>;
        acc = LONG_MAX;
        errno = ERANGE;
    }
}</code></pre>
<p>要想得到正确的输出结果，需要改动两个地方：</p>
<p>1.其中这行：</p>
<pre class="sourceCode c"><code class="sourceCode c">  <span class="kw">if</span> ((acc &gt; cutoff || acc == cutoff) &amp;&amp; c &gt; cutlim)    </code></pre>
<p>应该改为：</p>
<pre class="sourceCode c"><code class="sourceCode c">  <span class="kw">if</span> ( acc &gt; cutoff ||  (acc == cutoff) &amp;&amp; c &gt; cutlim)  )    </code></pre>
<p>2.与此同时，这行:</p>
<pre class="sourceCode c"><code class="sourceCode c">  <span class="kw">if</span> ((acc &lt; cutoff || acc == cutoff) &amp;&amp; c &gt; cutlim) {    </code></pre>
<p>改为</p>
<pre class="sourceCode c"><code class="sourceCode c">  <span class="kw">if</span> (acc &lt; cutoff || (acc == cutoff &amp;&amp; c &gt; cutlim)) {    </code></pre>
<p>为何要这样修改呢？细心的读者相信还是会记得上文第8节中关于正数的两种溢出情况的可能性：“对于正数来说，它溢出的可能性有两种：</p>
<ol type="1">
<li>一种是诸如2147483650，即n &gt; MAX/10 的；<br /></li>
<li>一种是诸如2147483649，即n == MAX/10 &amp;&amp; c &gt; MAX%10。</li>
</ol>
<p>也就是说无论是&quot;10522545459&quot;，还是&quot;10522545454&quot;，都是属于第1种情况，即“诸如2147483650，即n &gt; MAX/10的”，此时直接返回MAX_INT即可，所以不需要也不能再去判断n == MAX/10的情况。 这个处理思路类似于上文第8节处理溢出情况的代码：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span> (sign &gt; <span class="dv">0</span> &amp;&amp; (n &gt; MAX/<span class="dv">10</span> || (n == MAX/<span class="dv">10</span> &amp;&amp; c &gt; MAX%<span class="dv">10</span>)))      
{
    n = MAX;
    <span class="kw">break</span>;
}
<span class="kw">else</span> <span class="kw">if</span> (sign &lt; <span class="dv">0</span> &amp;&amp; (n &gt; (<span class="dt">unsigned</span>)MIN/<span class="dv">10</span>
                              || (n == (<span class="dt">unsigned</span>)MIN/<span class="dv">10</span> &amp;&amp; c &gt; (<span class="dt">unsigned</span>)MIN%<span class="dv">10</span>)))
{
    n = MIN;
    <span class="kw">break</span>;
}</code></pre>
<p>So，修改过后的代码测试正常:</p>
<figure>
<img src="../images/30~31/30.11.jpg" />
</figure>
<p>OK，字符串转换成整数这一问题已基本解决。但如果面试官继续问你，如何把整数转换成字符串呢？欢迎于本文评论下或hero上show出你的思路或代码。</p>
<h2 id="参考文献及推荐阅读-1">参考文献及推荐阅读</h2>
<ol type="1">
<li><a href="">http://zhedahht.blog.163.com/blog/static/25411174200731139971/</a>；</li>
<li>字符串转换成整数题目<a href="http://hero.pongo.cn/Question/Details?ID=47&amp;ExamID=45">完整描述</a>；<br /></li>
<li>linux3.8.4版本下的相关字符串整数转换函数<a href="https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/lib/vsprintf.c?id=refs/tags/v3.9.4]">概览</a>；<br /></li>
<li>关于linux中的<a href="http://blog.21ic.com/user1/5593/archives/2010/68193.html]">likely和unlikely</a>；<br /></li>
<li>atio函数的<a href="http://blog.csdn.net/njnu_mjn/article/details/9099405">实现</a>；<br /></li>
<li>atoi函数的实现: linux内核atoi函数的测试：<a href="">http://blog.csdn.net/njnu_mjn/article/details/9104143</a>；<br /></li>
<li>Nut/OS中<a href="http://www.ethernut.de/api/atoi_8c_source.html">atoi函数的实现</a>；<br />一读者写的hero上“字符串转换成整数”一题的<a href="http://blog.csdn.net/u011070134/article/details/9116831">解题报告</a>（测试正确）；</li>
</ol>
<h1 id="第三十一章带通配符的字符串匹配问题">第三十一章：带通配符的字符串匹配问题</h1>
<p>字符串匹配问题，给定一串字符串，按照指定规则对其进行匹配，并将匹配的结果保存至output数组中，多个匹配项用空格间隔，最后一个不需要空格。</p>
<p>要求：</p>
<ol type="1">
<li>匹配规则中包含通配符?和*，其中?表示匹配任意一个字符，*表示匹配任意多个（&gt;=0）字符。<br /></li>
<li>匹配规则要求匹配最大的字符子串，例如a*d,匹配abbdd而非abbd,即最大匹配子串。<br /></li>
<li>匹配后的输入串不再进行匹配，从当前匹配后的字符串重新匹配其他字符串。</li>
</ol>
<p>请实现函数：</p>
<pre class="sourceCode c"><code class="sourceCode c">  <span class="dt">char</span>* my_find(<span class="dt">char</span> input[], <span class="dt">char</span> rule[])</code></pre>
<p>举例说明：</p>
<figure>
<img src="../images/30~31/31.1.jpg" alt="31.1.jpg" /><figcaption>31.1.jpg</figcaption>
</figure>
<p>注意事项：<br />1. 自行实现函数my_find，勿在my_find函数里夹杂输出，且不准用C、C++库，和Java的String对象；<br />2. 请注意代码的时间，空间复杂度，及可读性，简洁性；<br />3. input=aaa，rule=aa时，返回一个结果aa，即可。</p>
<p><em><strong>1</strong></em>. 本题与上述第三十章的题不同，上题字符串转换成整数更多考察对思维的全面性和对细节的处理，本题则更多的是编程技巧。闲不多说，直接上代码：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@cao_peng 2013/4/23  </span>
<span class="dt">int</span> str_len(<span class="dt">char</span> *a)
{  <span class="co">//字符串长度</span>
    <span class="kw">if</span> (a == <span class="dv">0</span>)
    {
        <span class="kw">return</span> <span class="dv">0</span>;
    }
    <span class="dt">char</span> *t = a;
    <span class="kw">for</span> (;*t;++t)
        ;
    <span class="kw">return</span> (<span class="dt">int</span>) (t - a);
}

<span class="dt">void</span> str_copy(<span class="dt">char</span> *a,<span class="dt">const</span> <span class="dt">char</span> *b,<span class="dt">int</span> len)
{  <span class="co">//拷贝字符串 a = b</span>
    <span class="kw">for</span> (;len &gt; <span class="dv">0</span>; --len, ++b,++a)
    {
        *a = *b;
    }
    *a = <span class="dv">0</span>;
}

<span class="dt">char</span> *str_join(<span class="dt">char</span> *a,<span class="dt">const</span> <span class="dt">char</span> *b,<span class="dt">int</span> lenb)
{ <span class="co">//连接字符串 第一个字符串被回收</span>
    <span class="dt">char</span> *t;
    <span class="kw">if</span> (a == <span class="dv">0</span>)
    {
        t = (<span class="dt">char</span> *) malloc(<span class="kw">sizeof</span>(<span class="dt">char</span>) * (lenb + <span class="dv">1</span>));
        str_copy(t, b, lenb);
        <span class="kw">return</span> t;
    }
    <span class="kw">else</span>
    {
        <span class="dt">int</span> lena = str_len(a);
        t = (<span class="dt">char</span> *) malloc(<span class="kw">sizeof</span>(<span class="dt">char</span>) * (lena + lenb + <span class="dv">2</span>));
        str_copy(t, a, lena);
        *(t + lena) = &#39; &#39;;
        str_copy(t + lena + <span class="dv">1</span>, b, lenb);
        free(a);
        <span class="kw">return</span> t;
    }
}

<span class="dt">int</span> canMatch(<span class="dt">char</span> *input, <span class="dt">char</span> *rule)
{ <span class="co">// 返回最长匹配长度 -1表示不匹配</span>
    <span class="kw">if</span> (*rule == <span class="dv">0</span>)
    { <span class="co">//已经到rule尾端</span>
        <span class="kw">return</span> <span class="dv">0</span>;
    }
    <span class="dt">int</span> r = -<span class="dv">1</span> ,may;
    <span class="kw">if</span> (*rule == &#39;*&#39;)
    {
        r = canMatch(input, rule + <span class="dv">1</span>);  <span class="co">// *匹配0个字符</span>
        <span class="kw">if</span> (*input)
        {
            may = canMatch(input + <span class="dv">1</span>, rule);  <span class="co">// *匹配非0个字符</span>
            <span class="kw">if</span> ((may &gt;= <span class="dv">0</span>) &amp;&amp; (++may &gt; r))
            {
                r = may;
            }
        }
    }
    <span class="kw">if</span> (*input == <span class="dv">0</span>)
    {  <span class="co">//到尾端</span>
        <span class="kw">return</span> r;
    }
    <span class="kw">if</span> ((*rule == &#39;?&#39;) || (*rule == *input))
    {
        may = canMatch(input + <span class="dv">1</span>, rule + <span class="dv">1</span>);
        <span class="kw">if</span> ((may &gt;= <span class="dv">0</span>) &amp;&amp; (++may &gt; r))
        {
            r = may;
        }
    }
    <span class="kw">return</span> r;
}

<span class="dt">char</span> * my_find(<span class="dt">char</span> input[], <span class="dt">char</span> rule[])
{
    <span class="dt">int</span> len = str_len(input);
    <span class="dt">int</span> *match = (<span class="dt">int</span> *) malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>) * len);  <span class="co">//input第i位最多能匹配多少位 匹配不上是-1</span>
    <span class="dt">int</span> i,max_pos = - <span class="dv">1</span>;
    <span class="dt">char</span> *output = <span class="dv">0</span>;

    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; len; ++i)
    {
        match[i] = canMatch(input + i, rule);
        <span class="kw">if</span> ((max_pos &lt; <span class="dv">0</span>) || (match[i] &gt; match[max_pos]))
        {
            max_pos = i;
        }
    }
    <span class="kw">if</span> ((max_pos &lt; <span class="dv">0</span>) || (match[max_pos] &lt;= <span class="dv">0</span>))
    {  <span class="co">//不匹配</span>
        output = (<span class="dt">char</span> *) malloc(<span class="kw">sizeof</span>(<span class="dt">char</span>));
        *output = <span class="dv">0</span>;   <span class="co">// \0</span>
        <span class="kw">return</span> output;
    }
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; len;)
    {
        <span class="kw">if</span> (match[i] == match[max_pos])
        { <span class="co">//找到匹配</span>
            output = str_join(output, input + i, match[i]);
            i += match[i];
        }
        <span class="kw">else</span>
        {
            ++i;
        }
    }
    free(match);
    <span class="kw">return</span> output;
}</code></pre>
<p><em><strong>2</strong></em>. 本题也可以直接写出DP(Dynamic Programming, 动态规划)方程，如下代码所示：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@chpeih 2013/4/23  </span>
<span class="dt">char</span>* my_find(<span class="dt">char</span> input[], <span class="dt">char</span> rule[])  
{  
    <span class="co">//write your code here  </span>
    <span class="dt">int</span> len1, len2;  
    <span class="kw">for</span>(len1 = <span class="dv">0</span>; input[len1]; len1++);  
    <span class="kw">for</span>(len2 = <span class="dv">0</span>; rule[len2]; len2++);  
    <span class="dt">int</span> MAXN = len1 &gt; len2 ? (len1<span class="dv">+1</span>) : (len2<span class="dv">+1</span>);  
    <span class="dt">int</span>  **dp;  
  
    <span class="co">//dp[i][j]表示字符串1和字符串2分别以i j结尾匹配的最大长度  </span>
    <span class="co">//记录dp[i][j]是由之前那个节点推算过来  i*MAXN+j  </span>
    dp = new <span class="dt">int</span> *[len1<span class="dv">+1</span>];  
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>;i&lt;=len1;i++)  
    {  
        dp[i] = new <span class="dt">int</span>[len2<span class="dv">+1</span>];  
  
    }  
  
    dp[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">0</span>;  
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= len2; i++)  
        dp[<span class="dv">0</span>][i] = -<span class="dv">1</span>;  
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= len1; i++)  
        dp[i][<span class="dv">0</span>] = <span class="dv">0</span>;  
  
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= len1; i++)  
    {  
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= len2; j++)  
        {  
            <span class="kw">if</span>(rule[j<span class="dv">-1</span>] == &#39;*&#39;){  
                dp[i][j] = -<span class="dv">1</span>;  
                <span class="kw">if</span> (dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>] != -<span class="dv">1</span>)  
                {  
                    dp[i][j] = dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>;  
  
                }  
                <span class="kw">if</span> (dp[i<span class="dv">-1</span>][j] != -<span class="dv">1</span> &amp;&amp; dp[i][j] &lt; dp[i<span class="dv">-1</span>][j] + <span class="dv">1</span>)  
                {
                    dp[i][j] = dp[i<span class="dv">-1</span>][j] + <span class="dv">1</span>;  
                }  
            }
            <span class="kw">else</span> <span class="kw">if</span> (rule[j<span class="dv">-1</span>] == &#39;?&#39;)
            {  
                <span class="kw">if</span>(dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>] != -<span class="dv">1</span>){  
                    dp[i][j] = dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>;  
  
                }<span class="kw">else</span> dp[i][j] = -<span class="dv">1</span>;  
            }   
            <span class="kw">else</span>  
            {  
                <span class="kw">if</span>(dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>] != -<span class="dv">1</span> &amp;&amp; input[i<span class="dv">-1</span>] == rule[j<span class="dv">-1</span>]){  
                    dp[i][j] = dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>;  
                }<span class="kw">else</span> dp[i][j] = -<span class="dv">1</span>;  
            }  
        }  
    }  
  
    <span class="dt">int</span> m = -<span class="dv">1</span>;<span class="co">//记录最大字符串长度  </span>
    <span class="dt">int</span> *ans = new <span class="dt">int</span>[len1];  
    <span class="dt">int</span> count_ans = <span class="dv">0</span>;<span class="co">//记录答案个数  </span>
    <span class="dt">char</span> *returnans = new <span class="dt">char</span>[len1<span class="dv">+1</span>];  
    <span class="dt">int</span> count = <span class="dv">0</span>;  
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= len1; i++)  
        <span class="kw">if</span> (dp[i][len2] &gt; m){  
            m = dp[i][len2];  
            count_ans = <span class="dv">0</span>;  
            ans[count_ans++] = i-m;  
        }
        <span class="kw">else</span> <span class="kw">if</span>(dp[i][len2] != -<span class="dv">1</span> &amp;&amp; dp[i][len2] == m)
        {
            ans[count_ans++] = i-m;  
        }  
  
        <span class="kw">if</span> (count_ans!=<span class="dv">0</span>)  
        {      
            <span class="dt">int</span> len = ans[<span class="dv">0</span>];  
            <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>;i &lt; m;i++)  
            {  
                printf(<span class="st">&quot;%c&quot;</span>,input[i+ans[<span class="dv">0</span>]]);  
                returnans[count++] = input[i+ans[<span class="dv">0</span>]];  
            }  
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>;j&lt;count_ans;j++)  
            {  
                printf(<span class="st">&quot; &quot;</span>);  
                returnans[count++] = &#39; &#39;;  
                len = ans[j];  
                <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>;i&lt;m;i++)  
                {  
                    printf(<span class="st">&quot;%c&quot;</span>,input[i+ans[j]]);  
                    returnans[count++] = input[i+ans[j]];  
                }  
            }  
            printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);  
            returnans[count++] = &#39;\<span class="dv">0</span>&#39;;  
        }  
  
        <span class="kw">return</span> returnans;  
}  </code></pre>
<h2 id="参考文献及推荐阅读-2">参考文献及推荐阅读</h2>
<p>1.字符串匹配问题题目<a href="http://hero.pongo.cn/Question/Details?ID=28&amp;ExamID=28">完整描述</a>；</p>
<h1 id="第三十二章最小操作数">第三十二章：最小操作数</h1>
<p>作者：July、caopengcs、红色标记。致谢：fuwutu、demo。</p>
<p>时间：二零一三年八月十二日</p>
<h2 id="题记">题记</h2>
<p>再过一两月，便又到了每年的九月十月校招高峰期，在此依次推荐：</p>
<ol type="1">
<li><p><a href="http://blog.csdn.net/column/details/taopp.html">程序员编程艺术</a>；</p></li>
<li><p><a href="http://blog.csdn.net/v_july_v/article/details/7382693">秒杀99%的海量数据处理面试题</a>；</p></li>
<li><p>《编程之美》；</p></li>
<li><p><a href="http://blog.csdn.net/column/details/ms100.html">微软面试100题系列</a>；</p></li>
<li><p>《剑指offer》</p></li>
</ol>
<p>一年半前在学校的那会，我曾经无比疯狂的创作程序员编程艺术这个系列，因为当时我坚信它能帮到更多的人找到更好的工作，此刻今后，我更加无比坚信这点。</p>
<p>同时，相信你也已看到，编程艺术系列的创作原则是把受众定位为一个编程初学者，从看到问题后最先想到的思路开始讲解，一点一点改进，不断优化。</p>
<p>而本文主要讲下述两个问题：</p>
<ul>
<li>第三十二章：最小操作数问题，主要由caopengcs完成；</li>
<li>第三十三章：木块砌墙问题，主要由红色标记和caopengcs完成。</li>
</ul>
<p>全文由July统一整理修订完成。OK，还是很真诚的那句话：有任何问题，欢迎读者随时批评指正，感谢。</p>
<h2 id="第三十二章最小操作数-1">第三十二章、最小操作数</h2>
<p>题目详情如下：</p>
<p>给定一个单词集合Dict，其中每个单词的长度都相同。现从此单词集合Dict中抽取两个单词A、B，我们希望通过若干次操作把单词A变成单词B，每次操作可以改变单词的一个字母，同时，新产生的单词必须是在给定的单词集合Dict中。求所有行得通步数最少的修改方法。</p>
<p>举个例子如下：</p>
<p>Given: A = &quot;hit&quot; B = &quot;cog&quot; Dict = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;] Return [ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] ]</p>
<p>即把字符串A = &quot;hit&quot;转变成字符串B = &quot;cog&quot;，有以下两种可能：</p>
<p>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;；</p>
<p>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt;&quot;cog&quot;。</p>
<p><strong>详解</strong>：本题是一个典型的图搜索算法问题。此题看似跟本系列的第29章的字符串编辑距离相似，但其实区别特别大，原因是最短编辑距离是让某个单词增加一个字符或减少一个字符或修改一个字符达到目标单词，来求变换的最少次数，但此最小操作数问题就只是改变一个字符。</p>
<p>通过<a href="http://blog.csdn.net/v_JULY_v/article/details/6111353">此文</a>，我们知道，在图搜索算法中，有深度优先遍历DFS和广度优先遍历BFS，而题目中并没有给定图，所以需要我们自己建立图。</p>
<figure>
<img src="../images/32~33/32.1.jpg" />
</figure>
<p>涉及到图就有这么几个问题要思考，节点是什么？边如何建立？图是有方向的还是无方向的？包括建好图之后，如何记录单词序列等等都是我们要考虑的问题。</p>
<h3 id="解法一单向bfs法">解法一、单向BFS法</h3>
<p><strong>1</strong>、建图</p>
<p>对于本题，我们的图的节点就是字典里的单词，两个节点有连边，对应着我们可以把一个单词按照规则变为另外一个单词。比如我们有单词hat，它应该与单词cat有一条连边，因为我们可以把h变为c，反过来我们也可以把c变为h，所以我们建立的连边应该是无向的。</p>
<p>如何建图？有两种办法，</p>
<ul>
<li><p>第一种方法是：我们可以把字典里的任意两个单词，通过循环判断一下这两个单词是否只有一个位置上的字母不同。即假设字典里有n个单词，我们遍历任意两个单词的复杂度是O(n2)，如果每个单词长度为length，我们判断两个单词是否连边的复杂度是O(length)，所以这个建图的总复杂度是O(n2*length)。但当n比较大时，这个复杂度非常高，有没有更好的方法呢？</p></li>
<li><p>第二种方法是：我们把字典里地每个单词的每个位置的字母修改一下，从字典里查找一下（若用基于red-black tree的map查找，其查找复杂度为O(logn)，若用基于hashmap的unordered_map，则查找复杂度为O(1)），修改后的单词是否在字典里出现过。即我们需要遍历字典里地每一个单词O(n)，尝试修改每个位置的每个字母，对每个位置我们需要尝试26个字母（其实是25个，因为要改得和原来不同），因此这部分复杂度是O(26<em>length)，总复杂度是O(26 </em> n * length) （第二种方法优化版：这第二种方法能否更优？在第二种方法中，我们对每个单词每个位置尝试了26次修改，事实上我们可以利用图是无向的这一特点，我们对每个位置试图把该位置的字母变到字典序更大的字母。例如，我们只考虑cat变成hat，而不考虑hat变成cat，因为再之前已经把无向边建立了。这样，只进行一半的修改次数，从而减少程序的运行时间。当然这个优化从复杂度上来讲是常数的，因此称为常数优化，此虽算是一种改进，但不足以成为第三种方法，原因是我们经常忽略O背后隐藏的常数）。</p></li>
</ul>
<p>OK，上面两种方法孰优孰劣呢？直接比较n2<em>length 与 26 </em> n * length的大小。很明显，通常情况下，字典里的单词个数非常多，也就是n比较大，因此第二种方法效果会好一些，稍后的参考代码也会选择上述第二种方法的优化。</p>
<p><strong>2</strong>、记录单词序列</p>
<p>对于最简单的bfs，我们是如何记录路径的？如果只需要记录一条最短路径的话，我们可以对每个走到的位置，记录走到它的前一个位置。这样到终点后，我们可以不断找到它的前一个位置。我们利用了最短路径的一个特点：即第二次经过一个节点的时候，路径长度不比第一次经过它时短。因此这样的路径是没有圈的。</p>
<p>但是本题需要记录全部的路径，我们第二次经过一个节点时，路径长度可能会和第一次经过一个节点时路径长度一样。这是因为，我们可能在第i层中有多个节点可以到达第(i + 1)层的同一个位置，这样那个位置有多条路径都是最短路径。</p>
<p>如何解决呢？——我们记录经过这个位置的前面所有位置的集合。这样一个节点的前驱不是一个节点，而是一个节点的集合。如此，当我们第二次经过一个第(i+ 1)层的位置时，我们便保留前面那第i层位置的集合作为前驱。</p>
<p><strong>3</strong>、遍历</p>
<p>解决了以上两个问题，我们最终得到的是什么？如果有解的话，我们最终得到的是从终点开始的前一个可能单词的集合，对每个单词，我们都有能得到它的上一个单词的集合，直到起点。这就是bfs分层之后的图，我们从终点开始遍历这个图的到起点的所有路径，就得到了所有的解，这个遍历我们可以采用之前介绍的dfs方法（路径的数目可能非常多）。</p>
<p>其实，为了简单起见，我们可以从终点开始bfs，因为记录路径记录的是之前的节点，也就是反向的。这样最终可以按顺序从起点遍历到终点的所有路径。</p>
<p>参考代码如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@caopengcs     </span>
<span class="co">//updated@July 08/12/2013    </span>
<span class="kw">class</span> Solution    
{    
<span class="kw">public</span>:    
    <span class="co">// help 函数负责找到所有的路径    </span>
    <span class="dt">void</span> help(intx,vector&lt;<span class="dt">int</span>&gt; &amp;d, vector&lt;string&gt; &amp;word,vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;next,vector&lt;string&gt; &amp;path,vector&lt;vector&lt;string&gt; &gt; &amp;answer)
    {
        path.push_back(word[x]);    
        <span class="kw">if</span> (d[x] == <span class="dv">0</span>)
        {   <span class="co">//已经达到终点了</span>
            answer.push_back(path);    
        }    
        <span class="kw">else</span>
        {
            <span class="dt">int</span> i;    
            <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt;next[x].size(); ++i)
            {
                help(next[x][i],d, word, next,path,answer);    
            }    
        }    
        path.pop_back();   <span class="co">//回溯    </span>
    }    
  
    vector&lt;vector&lt;string&gt;&gt; findLadders(string start, string end, set&lt;string&gt;&amp; dict)    
    {    
        vector&lt;vector&lt;string&gt; &gt; answer;    
        <span class="kw">if</span> (start == end)
        {   <span class="co">//起点终点恰好相等</span>
            <span class="kw">return</span> answer;    
        }    
        <span class="co">//把起点终点加入字典的map    </span>
        dict.insert(start);    
        dict.insert(end);    
        set&lt;string&gt;::iterator dt;    
        vector&lt;string&gt; word;    
        map&lt;string,<span class="dt">int</span>&gt;allword;    
        <span class="co">//把set转换为map，这样每个单词都有编号了。    </span>
        <span class="kw">for</span> (dt = dict.begin(); dt!= dict.end(); ++dt)
        {
            word.push_back(*dt);    
            allword.insert(make_pair(*dt, allword.size()));    
        }    
  
        <span class="co">//建立连边 邻接表    </span>
        vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; con;    
        <span class="dt">int</span> i,j,n =word.size(),temp,len = word[<span class="dv">0</span>].length();    
        con.resize(n);    
        <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i)
        {
            <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt;len; ++j)
            {
                <span class="dt">char</span> c;    
                <span class="kw">for</span> (c =word[i][j] + <span class="dv">1</span>; c &lt;= &#39;z&#39;; ++c)
                {  <span class="co">//根据上面第二种方法的优化版的思路，让每个单词每个位置变更大</span>
                    <span class="dt">char</span> last =word[i][j];    
                    word[i][j] =c;    
                    map&lt;string,<span class="dt">int</span>&gt;::iterator t = allword.find(word[i]);    
                    <span class="kw">if</span> (t !=allword.end())
                    {
                        con[i].push_back(t-&gt;second);    
                        con[t-&gt;second].push_back(i);    
                    }    
                    word[i][j] =last;    
                }    
            }    
        }    
  
        <span class="co">//以下是标准bfs过程    </span>
        queue&lt;<span class="dt">int</span>&gt; q;    
        vector&lt;<span class="dt">int</span>&gt; d;    
        d.resize(n, -<span class="dv">1</span>);    
        <span class="dt">int</span> from = allword[start],to = allword[end];    
        d[to] = <span class="dv">0</span>;  <span class="co">//d记录的是路径长度，-1表示没经过    </span>
        q.push(to);    
        vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; next;    
        next.resize(n);    
        <span class="kw">while</span> (!q.empty())
        {
            <span class="dt">int</span> x = q.front(), now= d[x] + <span class="dv">1</span>;    
            <span class="co">//now相当于路径长度  </span>
            <span class="co">//当now &gt; d[from]时，则表示所有解都找到了  </span>
            <span class="kw">if</span> ((d[from] &gt;= <span class="dv">0</span>)&amp;&amp; (now &gt; d[from]))
            {
                <span class="kw">break</span>;    
            }    
            q.pop();    
            <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt;con[x].size(); ++i)
            {
                <span class="dt">int</span> y = con[x][i];    
                <span class="co">//第一次经过y  </span>
                <span class="kw">if</span> (d[y] &lt; <span class="dv">0</span>)
                {
                    d[y] = now;    
                    q.push(y);    
                    next[y].push_back(x);    
                }    
                <span class="co">//非第一次经过y  </span>
                <span class="kw">else</span> <span class="kw">if</span> (d[y] ==now)
                {  <span class="co">//是从上一层经过的，所以要保存</span>
                    next[y].push_back(x);    
                }    
            }    
        }    
        <span class="kw">if</span> (d[from] &gt;= <span class="dv">0</span>)
        {  <span class="co">//有解</span>
            vector&lt;string&gt;path;    
            help(from, d,word,next, path,answer);    
        }    
        <span class="kw">return</span> answer;    
    }    
};</code></pre>
<h3 id="解法二双向bfs法">解法二、双向BFS法</h3>
<p>BFS需要把每一步搜到的节点都存下来，很有可能每一步的搜到的节点个数越来越多，但最后的目的节点却只有一个。后半段的很多搜索都是白耗时间了。</p>
<p>上面给出了单向BFS的解法，但看过此前blog中的这篇文章<a href="http://blog.csdn.net/v_JULY_v/article/details/6238029">“A*、Dijkstra、BFS算法性能比较演示”</a>可知：双向BFS性能优于单向BFS。</p>
<p>举个例子如下，第1步，是起点，1个节点，第2步，搜到2个节点，第3步，搜到4个节点，第4步搜到8个节点，第5步搜到16个节点，并且有一个是终点。那这里共出现了31个节点。从起点开始广搜的同时也从终点开始广搜，就有可能在两头各第3步，就相遇了，出现的节点数不超过(1+2+4)*2=14个，如此就节省了一半以上的搜索时间。</p>
<p>下面给出双向BFS的解法，参考代码如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@fuwutu 6/26/2013  </span>
<span class="kw">class</span> Solution  
{  
<span class="kw">public</span>:  
    vector&lt;vector&lt;string&gt;&gt; findLadders(string start, string end, set&lt;string&gt;&amp; dict)  
    {  
        vector&lt;vector&lt;string&gt;&gt; result, result_temp;  
        <span class="kw">if</span> (dict.erase(start) == <span class="dv">1</span> &amp;&amp; dict.erase(end) == <span class="dv">1</span>)   
        {  
            map&lt;string, vector&lt;string&gt;&gt; kids_from_start;  
            map&lt;string, vector&lt;string&gt;&gt; kids_from_end;  
  
            set&lt;string&gt; reach_start;  
            reach_start.insert(start);  
            set&lt;string&gt; reach_end;  
            reach_end.insert(end);  
  
            set&lt;string&gt; meet;  
            <span class="kw">while</span> (meet.empty() &amp;&amp; !reach_start.empty() &amp;&amp; !reach_end.empty())  
            {  
                <span class="kw">if</span> (reach_start.size() &lt; reach_end.size())  
                {  
                    search_next_reach(reach_start, reach_end, meet, kids_from_start, dict);  
                }  
                <span class="kw">else</span>  
                {  
                    search_next_reach(reach_end, reach_start, meet, kids_from_end, dict);  
                }  
            }  
  
            <span class="kw">if</span> (!meet.empty())  
            {  
                <span class="kw">for</span> (set&lt;string&gt;::iterator it = meet.begin(); it != meet.end(); ++it)  
                {  
                    vector&lt;string&gt; words(<span class="dv">1</span>, *it);  
                    result.push_back(words);  
                }  
  
                walk(result, kids_from_start);  
                <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; result.size(); ++i)  
                {  
                    reverse(result[i].begin(), result[i].end());  
                }  
                walk(result, kids_from_end);  
            }  
        }  
  
        <span class="kw">return</span> result;  
    }  
  
<span class="kw">private</span>:  
    <span class="dt">void</span> search_next_reach(set&lt;string&gt;&amp; reach, <span class="dt">const</span> set&lt;string&gt;&amp; other_reach, set&lt;string&gt;&amp; meet, map&lt;string, vector&lt;string&gt;&gt;&amp; path, set&lt;string&gt;&amp; dict)  
    {  
        set&lt;string&gt; temp;  
        reach.swap(temp);  
  
        <span class="kw">for</span> (set&lt;string&gt;::iterator it = temp.begin(); it != temp.end(); ++it)  
        {  
            string s = *it;  
            <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; s.length(); ++i)  
            {  
                <span class="dt">char</span> back = s[i];  
                <span class="kw">for</span> (s[i] = &#39;a&#39;; s[i] &lt;= &#39;z&#39;; ++s[i])  
                {  
                    <span class="kw">if</span> (s[i] != back)  
                    {  
                        <span class="kw">if</span> (reach.count(s) == <span class="dv">1</span>)  
                        {  
                            path[s].push_back(*it);  
                        }  
                        <span class="kw">else</span> <span class="kw">if</span> (dict.erase(s) == <span class="dv">1</span>)  
                        {  
                            path[s].push_back(*it);  
                            reach.insert(s);  
                        }  
                        <span class="kw">else</span> <span class="kw">if</span> (other_reach.count(s) == <span class="dv">1</span>)  
                        {  
                            path[s].push_back(*it);  
                            reach.insert(s);  
                            meet.insert(s);  
                        }  
                    }  
                }  
                s[i] = back;  
            }  
        }  
    }  
  
    <span class="dt">void</span> walk(vector&lt;vector&lt;string&gt;&gt;&amp; all_path, map&lt;string, vector&lt;string&gt;&gt; kids)  
    {  
        vector&lt;vector&lt;string&gt;&gt; temp;  
        <span class="kw">while</span> (!kids[all_path.back().back()].empty())  
        {  
            all_path.swap(temp);  
            all_path.clear();  
            <span class="kw">for</span> (vector&lt;vector&lt;string&gt;&gt;::iterator it = temp.begin(); it != temp.end(); ++it)  
            {  
                vector&lt;string&gt;&amp; one_path = *it;  
                vector&lt;string&gt;&amp; p = kids[one_path.back()];  
                <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; p.size(); ++i)  
                {  
                    all_path.push_back(one_path);  
                    all_path.back().push_back(p[i]);  
                }  
            }  
        }  
    }  
};  </code></pre>
<h2 id="参考链接及推荐阅读">参考链接及推荐阅读</h2>
<ol type="1">
<li>caopengcs，<a href="http://blog.csdn.net/caopengcs/article/details/9919341">最小操作数</a>；</li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/8701148#t4">编程艺术第29章字符串编辑距离</a></li>
<li>matrix67，<a href="http://www.matrix67.com/blog/archives/276">十个利用矩阵乘法解决的经典题目：</a></li>
<li>leetcode上<a href="http://leetcode.com/onlinejudge#question_126">最小操作数一题</a></li>
<li><a href="http://blog.csdn.net/sunnianzhong/article/details/9326289">超然烟火</a></li>
</ol>
<h1 id="第三十三章木块砌墙">第三十三章：木块砌墙</h1>
<p>作者：July、caopengcs、红色标记。致谢：fuwutu、demo。</p>
<p>时间：二零一三年八月十二日</p>
<p><strong>题目</strong>：用 1×1×1, 1× 2×1以及2×1×1的三种木块（横绿竖蓝，且绿蓝长度均为2），</p>
<figure>
<img src="../images/32~33/33.1.png" />
</figure>
<p>搭建高长宽分别为K × 2^N × 1的墙，不能翻转、旋转（其中，0&lt;=N&lt;=1024，1&lt;=K&lt;=4）</p>
<figure>
<img src="../images/32~33/33.2.png" />
</figure>
<p>有多少种方案，输出结果</p>
<p>对1000000007取模。</p>
<p>举个例子如给定高度和长度：N=1 K=2，则答案是7，即有7种搭法，如下图所示：</p>
<figure>
<img src="../images/32~33/33.3.png" />
</figure>
<p><strong>详解</strong>：此题很有意思，涉及的知识点也比较多，包括动态规划，快速矩阵幂，状态压缩，排列组合等等都一一考察了个遍。而且跟一个比较经典的矩阵乘法问题类似：即用1 x 2的多米诺骨牌填满M x N的矩形有多少种方案，M&lt;=5，N&lt;2^31，输出答案mod p的结果</p>
<figure>
<img src="../images/32~33/33.4.gif" />
</figure>
<p>OK，回到正题。下文使用的图示说明(所有看到的都是横切面)：</p>
<figure>
<img src="../images/32~33/33.5.jpg" />
</figure>
<p>首先说明“？方块”的作用</p>
<figure>
<img src="../images/32~33/33.6.jpg" />
</figure>
<p>“？方块”，表示这个位置是空位置，可以任意摆放。</p>
<p>上图的意思就是，当右上角被绿色木块占用，此位置固定不变，其他位置任意摆放，在这种情况下的堆放方案数。</p>
<h3 id="解法一穷举遍历">解法一、穷举遍历</h3>
<p>初看此题，你可能最先想到的思路便是穷举：用二维数组模拟墙，从左下角开始摆放，从左往右，从下往上，最后一个格子是右上角那个位置；每个格子把每种可以摆放木块都摆放一次，每堆满一次算一种用摆放方法。为了便于描述，为木块的每个格子进行编号：</p>
<figure>
<img src="../images/32~33/33.7.jpg" />
</figure>
<p>下面演示当n=1,k=2的算法过程（7种情况）：</p>
<figure>
<img src="../images/32~33/33.8.jpg" />
</figure>
<p>穷举遍历在数据规模比较小的情况下还撑得住，但在0&lt;=N&lt;=1024这样的数据规模下，此方法则立刻变得有心无力，因此我们得寻找更优化的解法。</p>
<h3 id="解法二递归分解">解法二、递归分解</h3>
<p>递归求解就是把一个大问题，分解成小问题，逐个求解，然后再解决大问题。</p>
<h4 id="算法演示">2.1、算法演示</h4>
<p>假如有墙规模为(n,k)，如果从中间切开，被分为规模问(n-1,k)的两堵墙，那么被分开的墙和原墙有什么关系呢？我们首先来看一下几组演示。</p>
<h5 id="n1k2的情况">2.1.1、n=1，k=2的情况</h5>
<p>首先演示，<strong>n=1,k=2</strong>时的情况，如下图2-1：</p>
<figure>
<img src="../images/32~33/33.9.jpg" />
</figure>
<p>图 2-1</p>
<p>上图2-1中：</p>
<p><img src="../images/32~33/33.10.jpg" /> 表示，左边墙的所有堆放方案数 * 右边墙所有堆放方案数 = 2 * 2 = 4</p>
<p><img src="../images/32~33/33.11.jpg" /> 表示，当切开处有一个横条的时候，空位置存在的堆放方案数。左边<em>右边 = 1</em>1 = 2；剩余两组以此类推。</p>
<p>这个是排列组合的知识。</p>
<h5 id="n2k3的情况">2.1.2、n=2，k=3的情况</h5>
<p>其次，我们再来演示下面更具一般性的计算分解，即当__n=2,k=3__的情况，如下图2-2：</p>
<figure>
<img src="../images/32~33/33.12.jpg" />
</figure>
<p>图 2-2</p>
<p>再从分解的结果中，挑选一组进行分解演示：</p>
<figure>
<img src="../images/32~33/33.13.jpg" />
</figure>
<p>图 2-3</p>
<p>通过图2-2和图2-3的分解演示，可以说明，最终都是分解成一列求解。在逐级向上汇总。</p>
<h5 id="n4k3的情况">2.1.3、n=4，k=3的情况</h5>
<p>我们再假设一堵墙n=4，k=3，也就是说，宽度是16，高度是3时，会有以下分解：</p>
<figure>
<img src="../images/32~33/33.14.jpg" />
</figure>
<p>图2-4</p>
<p>根据上面的分解的一个中间结果，再进行分解，如下：</p>
<figure>
<img src="../images/32~33/33.15.jpg" />
</figure>
<p>图2-5</p>
<p>通过上面图2-1~图2-5的演示可以明确如下几点：</p>
<p>1.假设f(n)用于计算问题，那么f(n)依赖于f(n-1)的多种情况。</p>
<p>2.切开处有什么特殊的地方呢？通过上面的演示，我们得知被切开的两堵墙从没有互相嵌入的木块（绿色木块）到全是互相连接的木块，相当于切口绿色木块的全排列（即有绿色或者没有绿色的所有排列），即有2^k种状态（比如k=2，且有绿色用1表示，没有绿色用0表示，那么就有00、01、10、11这4种状态）。根据排列组合的性质，把每一种状态下左右木墙堆放方案数相乘，再把所有乘积求和，就得到木墙的堆放结果数。以此类推，将问题逐步往下分解即可。</p>
<p>3.此外，从图2-5中可以看出，除了需要考虑切口绿色木块的状态，还需要考虑最左边一列和最右边一列的绿色木块状态。我们把这两种边界状态称为左边界状态和右边界状态，分别用leftState和rightState表示。</p>
<p>且在观察图2-5被切分后，所有左边的墙，他们的左边界ls状态始终保持不变，右边界rs状态从0~maxState, maxState = 2^k-1（有绿色方块表示1，没有表示0；ls表示左边界状态，rs表示右边状态）：</p>
<figure>
<img src="../images/32~33/33.16.jpg" />
</figure>
<p>图2-6</p>
<p>同样可以看出右边的墙的右边界状态保持不变，而左边界状态从0~maxState。要堆砌的木墙可以看做是左边界状态=0，和右边界状态=0的一堵墙。</p>
<p>有一点可能要特别说明下，即上文中说，有绿色方块的状态表示标为1，无绿色方块的状态表示标为0，特意又拿上图2-6标记了一些数字，以让绝大部分读者能看得一目了然，如下所示：</p>
<figure>
<img src="../images/32~33/33.17.jpg" />
</figure>
<p>图2-7</p>
<p>这下，你应该很清楚的看到，在上图中，左边木块的状态表示一律为010，右边木块的状态表示则是000~111（即从下至上开始计数，右边木块rs的状态用二进制表示为：000 001 010 011 100 101 110 111，它们各自分别对应整数则是：0 1 2 3 4 5 6 7）。</p>
<h4 id="计算公式">2.2、计算公式</h4>
<p>通过图2-4、图2-5、图2-6的分解过程，我们可以总结出下面公式（leftState=最左边边界状态，rightState=最右边边界状态）：</p>
<figure>
<img src="../images/32~33/33.18.jpg" />
</figure>
<p>即：</p>
<figure>
<img src="../images/32~33/33.19.jpg" />
</figure>
<p>接下来，分3点解释下上述公式：</p>
<p><strong>1</strong>、上述函数返回结果是当左边状态为=leftState，右边状态=rightState时木墙的堆砌方案数，相当于直接分解的左右状态都为0的情况，即直接分解f(n,k,0,0)即可。看到这，读者可能便有疑问了，既然直接分解f(n,k,0,0)即可，为何还要加leftstate和leftstate两个变量呢？回顾下2.1.3节中n=4，k=3的演示例子，即当n=4，k=3时，其分解过程即如下图（上文2.1.3节中的图2-4）</p>
<figure>
<img src="../images/32~33/33.20.jpg" />
</figure>
<p>也就是说，刚开始直接分解f(4,3,0,0)，即n=4，k=3，leftstate=0，rightstate=0，但分解过程中leftstate和rightstate皆从0变化到了maxstate，故才让函数的第3和第4个参数采用leftstate和rightstate这两个变量的形式，公式也就理所当然的写成了f(n,k,leftstate,rightstate)。</p>
<p><strong>2</strong>、然后我们再看下当n=4，k=3分解的一个中间结果，即给定如上图最下面部分中红色框框所框住的木块时：</p>
<figure>
<img src="../images/32~33/33.21.jpg" />
</figure>
<p>它用方程表示即为 f(2,3,2,5)，怎么得来的呢？其实还是又回到了上文2.1.3节中，当n=2，k=3 时（下图即为上文2.1.3节中的图2-5和图2-6）</p>
<figure>
<img src="../images/32~33/33.22.jpg" />
</figure>
<figure>
<img src="../images/32~33/33.23.jpg" />
</figure>
<p>左边界ls状态始终保持不变时，右边界rs状态从0<sub>maxState；右边界状态保持不变时，而左边界状态从0</sub>maxState。</p>
<p>故上述分解过程用方程式可表示为：</p>
<p><strong>f(2,3,2,5) = f(1,3,2,0) * f(1,3,0,5)</strong></p>
<p><strong>+ f(1,3,2,1) * f(1,3,1,5)</strong></p>
<p><strong>+ f(1,3,2,2) * f(1,3,2,5)</strong></p>
<p><strong>+ f(1,3,2,3) * f(1,3,3,5)</strong></p>
<p><strong>+ f(1,3,2,4) * f(1,3,4,5)</strong></p>
<p><strong>+ f(1,3,2,5) * f(1,3,5,5)</strong></p>
<p><strong>+ f(1,3,2,6) * f(1,3,6,5)</strong></p>
<p><strong>+ f(1,3,2,7) * f(1,3,7,5)</strong></p>
<p>说白了，我们曾在2.1节中从图2-2到图2-6正推推导出了公式，然上述过程中，则又再倒推推了一遍公式进行了说明。</p>
<p><strong>3</strong>、最后，作者是怎么想到引入 leftstate 和rightstate 这两个变量的呢？如红色标记所说：&quot;因为切开后，发现绿色条，在分开出不断的变化，当时也进入了死胡同，我就在想，蓝色的怎么办。后来才想明白，与蓝色无关。每一种变化就是一种状态，所以就想到了引入leftstate 和rightstate这两个变量。&quot;</p>
<h4 id="参考代码">2.3、参考代码</h4>
<p>下面代码就是根据上面函数原理编写的。最终执行效率，n=1024,k=4 时，用时0.2800160秒（之前代码用的是字典作为缓存，用时在1.3秒左右，后来改为数组结果，性能大增）。&quot;&quot;</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="co">//copyright@红色标记 12/8/2013    </span>
<span class="co">//updated@July 13/8/2013  </span>
<span class="kw">using</span> System;    
<span class="kw">using</span> System.<span class="fu">Collections</span>.<span class="fu">Generic</span>;    
<span class="kw">using</span> System.<span class="fu">Text</span>;    
<span class="kw">using</span> System.<span class="fu">Collections</span>;    
  
<span class="kw">namespace</span> HeapBlock    
{    
    <span class="kw">public</span> <span class="kw">class</span> WoolWall    
    {            
        <span class="kw">private</span> <span class="dt">int</span> n;    
        <span class="kw">private</span> <span class="dt">int</span> height;    
        <span class="kw">private</span> <span class="dt">int</span> maxState;    
        <span class="kw">private</span> <span class="dt">int</span>[, ,] resultCache;   <span class="co">//结果缓存数组    </span>
  
        <span class="kw">public</span> <span class="fu">WoolWall</span>(<span class="dt">int</span> n, <span class="dt">int</span> height)    
        {    
            <span class="kw">this</span>.<span class="fu">n</span> = n;    
            <span class="kw">this</span>.<span class="fu">height</span> = height;    
            maxState = (<span class="dv">1</span> &lt;&lt; height) - <span class="dv">1</span>;    
            resultCache = <span class="kw">new</span> <span class="dt">int</span>[n + <span class="dv">1</span>, maxState + <span class="dv">1</span>, maxState + <span class="dv">1</span>];   <span class="co">//构建缓存数组，每个值默认为0；    </span>
        }    
  
        <span class="co">/// </span><span class="kw">&lt;summary&gt;</span><span class="co">    </span>
        <span class="co">/// 静态入口。计算堆放方案数。    </span>
        <span class="co">/// </span><span class="kw">&lt;/summary&gt;</span><span class="co">    </span>
        <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;n&quot;</span><span class="kw">&gt;&lt;/param&gt;</span><span class="co">    </span>
        <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;k&quot;</span><span class="kw">&gt;&lt;/param&gt;</span><span class="co">    </span>
        <span class="co">/// </span><span class="kw">&lt;returns&gt;&lt;/returns&gt;</span><span class="co">    </span>
        <span class="kw">public</span> <span class="kw">static</span> <span class="dt">int</span> <span class="fu">Heap</span>(<span class="dt">int</span> n, <span class="dt">int</span> k)    
        {    
            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">WoolWall</span>(n, k).<span class="fu">Heap</span>();    
        }    
  
        <span class="co">/// </span><span class="kw">&lt;summary&gt;</span><span class="co">    </span>
        <span class="co">/// 计算堆放方案数。    </span>
        <span class="co">/// </span><span class="kw">&lt;/summary&gt;</span><span class="co">    </span>
        <span class="co">/// </span><span class="kw">&lt;returns&gt;&lt;/returns&gt;</span><span class="co">    </span>
        <span class="kw">public</span> <span class="dt">int</span> <span class="fu">Heap</span>()    
        {    
            <span class="kw">return</span> (<span class="dt">int</span>)<span class="fu">Heap</span>(n, <span class="dv">0</span>, <span class="dv">0</span>);    
        }    
  
        <span class="kw">private</span> <span class="dt">long</span> <span class="fu">Heap</span>(<span class="dt">int</span> n, <span class="dt">int</span> lState, <span class="dt">int</span> rState)    
        {    
            <span class="co">//如果缓存数组中的值不为0，则表示该结果已经存在缓存中。    </span>
            <span class="co">//直接返回缓存结果。    </span>
            <span class="kw">if</span> (resultCache[n, lState, rState] != <span class="dv">0</span>)    
            {    
                <span class="kw">return</span> resultCache[n, lState, rState];    
            }    
  
            <span class="co">//在只有一列的情况，无法再进行切分    </span>
            <span class="co">//根据列状态计算一列的堆放方案    </span>
            <span class="kw">if</span> (n == <span class="dv">0</span>)    
            {    
                <span class="kw">return</span> <span class="fu">CalcOneColumnHeapCount</span>(lState);    
            }    
  
            <span class="dt">long</span> result = <span class="dv">0</span>;    
            <span class="kw">for</span> (<span class="dt">int</span> state = <span class="dv">0</span>; state &lt;= maxState; state++)    
            {    
                <span class="kw">if</span> (n == <span class="dv">1</span>)    
                {    
                    <span class="co">//在只有两列的情况，判断当前状态在切分之后是否有效    </span>
                    <span class="kw">if</span> (!<span class="fu">StateIsAvailable</span>(n, lState, rState, state))    
                    {    
                        <span class="kw">continue</span>;    
                    }    
                    result += <span class="fu">Heap</span>(n - <span class="dv">1</span>, state | lState, state | lState)  <span class="co">//合并状态。因为只有一列，所以lState和rState相同。    </span>
                        * <span class="fu">Heap</span>(n - <span class="dv">1</span>, state | rState, state | rState);    
                }    
                <span class="kw">else</span>    
                {    
                    result += <span class="fu">Heap</span>(n - <span class="dv">1</span>, lState, state) * <span class="fu">Heap</span>(n - <span class="dv">1</span>, state, rState);     
                }    
                result %= <span class="dv">1000000007</span>;<span class="co">//为了防止结果溢出，根据题目要求求模。    </span>
            }    
  
            resultCache[n, lState, rState] = (<span class="dt">int</span>)result;   <span class="co">//将结果写入缓存数组中    </span>
            resultCache[n, rState, lState] = (<span class="dt">int</span>)result;   <span class="co">//对称的墙结果相同，所以直接写入缓存。    </span>
            <span class="kw">return</span> result;    
        }    
  
        <span class="co">/// </span><span class="kw">&lt;summary&gt;</span><span class="co">    </span>
        <span class="co">/// 根据一列的状态，计算列的堆放方案数。    </span>
        <span class="co">/// </span><span class="kw">&lt;/summary&gt;</span><span class="co">    </span>
        <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;state&quot;</span><span class="kw">&gt;</span><span class="co">状态&lt;/param&gt;    </span>
        <span class="co">/// </span><span class="kw">&lt;returns&gt;&lt;/returns&gt;</span><span class="co">    </span>
        <span class="kw">private</span> <span class="dt">int</span> <span class="fu">CalcOneColumnHeapCount</span>(<span class="dt">int</span> state)    
        {    
            <span class="dt">int</span> sn = <span class="dv">0</span>; <span class="co">//连续计数    </span>
            <span class="dt">int</span> result = <span class="dv">1</span>;    
            <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; height; i++)    
            {    
                <span class="kw">if</span> ((state &amp; <span class="dv">1</span>) == <span class="dv">0</span>)    
                {    
                    sn++;    
                }    
                <span class="kw">else</span>    
                {    
                    <span class="kw">if</span> (sn &gt; <span class="dv">0</span>)    
                    {    
                        result *= <span class="fu">CalcAllState</span>(sn);    
                    }    
                    sn = <span class="dv">0</span>;    
                }    
                state &gt;&gt;= <span class="dv">1</span>;    
            }    
            <span class="kw">if</span> (sn &gt; <span class="dv">0</span>)    
            {    
                result *= <span class="fu">CalcAllState</span>(sn);    
            }    
  
            <span class="kw">return</span> result;    
        }    
  
        <span class="co">/// </span><span class="kw">&lt;summary&gt;</span><span class="co">    </span>
        <span class="co">/// 类似于斐波那契序列。    </span>
        <span class="co">/// f(1)=1    </span>
        <span class="co">/// f(2)=2    </span>
        <span class="co">/// f(n) = f(n-1)*f(n-2);    </span>
        <span class="co">/// 只是初始值不同。    </span>
        <span class="co">/// </span><span class="kw">&lt;/summary&gt;</span><span class="co">    </span>
        <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;k&quot;</span><span class="kw">&gt;&lt;/param&gt;</span><span class="co">    </span>
        <span class="co">/// </span><span class="kw">&lt;returns&gt;&lt;/returns&gt;</span><span class="co">    </span>
        <span class="kw">private</span> <span class="kw">static</span> <span class="dt">int</span> <span class="fu">CalcAllState</span>(<span class="dt">int</span> k)    
        {    
            <span class="kw">return</span> k &lt;= <span class="dv">2</span> ? k : <span class="fu">CalcAllState</span>(k - <span class="dv">1</span>) + <span class="fu">CalcAllState</span>(k - <span class="dv">2</span>);    
        }    
  
        <span class="co">/// </span><span class="kw">&lt;summary&gt;</span><span class="co">    </span>
        <span class="co">/// 判断状态是否可用。    </span>
        <span class="co">/// 当n=1时，分割之后，左墙和右边墙只有一列。    </span>
        <span class="co">/// 所以state的状态码可能会覆盖原来的边缘状态。    </span>
        <span class="co">/// 如果有覆盖，则该状态不可用；没有覆盖则可用。    </span>
        <span class="co">/// 当n&gt;1时，不存在这种情况，都返回状态可用。    </span>
        <span class="co">/// </span><span class="kw">&lt;/summary&gt;</span><span class="co">    </span>
        <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;n&quot;</span><span class="kw">&gt;&lt;/param&gt;</span><span class="co">    </span>
        <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;lState&quot;</span><span class="kw">&gt;</span><span class="co">左边界状态&lt;/param&gt;    </span>
        <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;rState&quot;</span><span class="kw">&gt;</span><span class="co">右边界状态&lt;/param&gt;    </span>
        <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;state&quot;</span><span class="kw">&gt;</span><span class="co">切开位置的当前状态&lt;/param&gt;    </span>
        <span class="co">/// </span><span class="kw">&lt;returns&gt;</span><span class="co">状态有效返回 true,状态不可用返回 false</span><span class="kw">&lt;/returns&gt;</span><span class="co">    </span>
        <span class="kw">private</span> <span class="dt">bool</span> <span class="fu">StateIsAvailable</span>(<span class="dt">int</span> n, <span class="dt">int</span> lState, <span class="dt">int</span> rState, <span class="dt">int</span> state)    
        {    
            <span class="kw">return</span> (n &gt; <span class="dv">1</span>) || ((lState | state) == lState + state &amp;&amp; (rState | state) == rState + state);    
        }    
    }    
}    </code></pre>
<p>上述程序中，</p>
<ul>
<li><p>WoolWall.Heap(1024,4); //直接通过静态方法获得结果</p></li>
<li><p>new WoolWall(n, k).Heap();//通过构造对象获得结果</p></li>
</ul>
<h5 id="核心算法讲解">2.3.1、核心算法讲解</h5>
<p>因为它最终都是分解成一列的情况进行处理，这就会导致很慢。为了提高速度，本文使用了缓存机制来提高性能。缓存原理就是，n,k,leftState,rightState相同的墙，返回的结果肯定相同。利用这个特性，每计算一种结果就放入到缓存中，如果下次计算直接从缓存取出。刚开始缓存用字典类实现，有网友给出了更好的缓存方法——数组。这样性能好了很多，也更加简单。程序结构如下图所示：</p>
<figure>
<img src="../images/32~33/33.24.jpg" />
</figure>
<p>上图反应了Heep调用的主要方法调用，在循环中，result 累加 lResult 和 rResult。</p>
<p>①在实际代码中，首先是从缓存中读取结果，如果没有缓存中读取结果在进行计算。</p>
<p>分解法分解到一列时，不在分解，直接计算机过</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">if</span> (n == <span class="dv">0</span>)  
{  
     <span class="kw">return</span> <span class="fu">CalcOneColumnHeap</span>(lState);  
} </code></pre>
<p>②下面是整个程序的核心代码，通过for循环，求和state=0到state=2^k-1的两边木墙乘积：</p>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">for</span> (<span class="dt">int</span> state = <span class="dv">0</span>; state &lt;= maxState; state++)  
{  
    <span class="kw">if</span> (n == <span class="dv">1</span>)  
    {  
        <span class="kw">if</span> (!<span class="fu">StateIsAvailable</span>(n, lState, rState, state))  
        {  
            <span class="kw">continue</span>;  
        }  
        result += <span class="fu">Heap</span>(n - <span class="dv">1</span>, state | lState, state | lState) *  
            <span class="fu">Heap</span>(n - <span class="dv">1</span>, state | rState, state | rState);  
    }  
    <span class="kw">else</span>  
    {  
        result += <span class="fu">Heap</span>(n - <span class="dv">1</span>, lState, state)  
            * <span class="fu">Heap</span>(n - <span class="dv">1</span>, state, rState);  
    }  
    result %= <span class="dv">1000000007</span>;  
}  </code></pre>
<p>当n=1切分时，需要特殊考虑。如下图：</p>
<figure>
<img src="../images/32~33/33.25.jpg" />
</figure>
<p>图2-8</p>
<p>看上图中，因为左边墙中间被绿色方块占用，所以在（1,0）-（1,1）这个位置（位置的标记方法同解法一）不能再放绿色方块。所以一些状态需要排除，如state=2需要排除。同时在还需要合并状态，如state=1时，左边墙的状态=3。</p>
<p>特别说明下：依据我们上文2.2节中的公式，如果第i行有这种木块，state对应2<sup>(i-1)，加上所有行的贡献就得到state（0就是没有这种横跨木块，2</sup>k-1就是所有行都是横跨木块），然后遍历state，还记得上文中的图2-7么？</p>
<figure>
<img src="../images/32~33/33.26.jpg" />
</figure>
<p>当第i行被这样的木块<img src="../images/32~33/33.27.jpg" />或这样的木块<img src="../images/32~33/33.28.jpg" />占据时，其各自对应的state值分别为：</p>
<p>1.当第1行被占据，state=1；</p>
<p>2.当第2行被占据，state=2；</p>
<p>3.当第1和第2行都被占据，state=3；</p>
<p>4.当第3行被占据，state=4；</p>
<p>5.当第1和第3行被占据，state=5；</p>
<p>6.当第2和第3行被占据，state=6；</p>
<p>7.当第1、2、3行全部都被占据，state=7。</p>
<p>至于原因，即如2.1.3节节末所说：二进制表示为：000 001 010 011 100 101 110 111，它们各自分别对应整数则是：0 1 2 3 4 5 6 7。</p>
<p>具体来说，下面图中所有框出来的位置，不能有绿色的：</p>
<figure>
<img src="../images/32~33/33.29.jpg" />
</figure>
<p>③CalcOneColumnHeap(int state)函数用于计算一列时摆放方案数。</p>
<p>计算方法是， 求和被绿色木块分割开的每一段连续方格的摆放方案数。每一段连续的方格的摆放方案通过CalcAllState方法求得。经过分析，可以得知CalcAllState是类似斐波那契序列的函数。</p>
<p>举个例子如下（分步骤讲述）：</p>
<p>1.令state = 4546（state=2^k-1，k最大为4，故本题中state最大在15，而这里取state=4546只是为了演示如何计算），二进制是：1000111000010。位置上为1，表示被绿色木块占用，0表示空着，可以自由摆放。</p>
<p>2.1000111000010 被分割后 1 000 111 0000 1 0, 那么就有 000=3个连续位置， 0000=4个连续位置 ， 0=1个连续位置。</p>
<p>3.堆放结果=CalcAllState(3) + CalcAllState(4) + CalcAllState(1) = 3 + 5 + 1 = 9。</p>
<h4 id="再次优化">2.4、再次优化</h4>
<p>上面程序因为调用性能的树形结构，形成了大量的函数调用和缓存查找，所以其性能不是很高。 为了得到更高的性能，可以让所有的运算直接依赖于上一次运算的结果，以防止更多的调用。即如果每次运算都算出所有边界状态的结果，那么就能为下一次运算提供足够的信息。后续优化请<a href="http://blog.csdn.net/dw14132124/article/details/9038417#t2">查阅此文第3节</a>。</p>
<h3 id="解法三动态规划">解法三、动态规划</h3>
<p>相信读到上文，不少读者都已经意识到这个问题其实就是一个动态规划问题，接下来咱们换一个角度来分析此问题。</p>
<h4 id="暴力搜索不可行">3.1、暴力搜索不可行</h4>
<p>首先，因为木块的宽度都是1，我们可以想成2维的问题。也就是说三种木板的规格分别为1* 1, 1 * 2, 2 * 1。</p>
<p>通过上文的解法一，我们已经知道这个问题最直接的想法就是暴力搜索，即对每个空格尝试放置哪种木板。但是看看数据规模就知道，这种思路是不可行的。因为有一条边范围长度高达21024，普通的电脑，230左右就到极限了。于是我们得想想别的方法。</p>
<h4 id="另辟蹊径">3.2、另辟蹊径</h4>
<p>为了方便，我们把墙看做有2n行，k列的矩形。这是因为虽然矩形木块不能翻转，但是我们同时拥有1<em>2和2</em>1的两种木块。</p>
<p>假设我们从上到下，从左到右考虑每个1*1的格子是如何被覆盖的。显然，我们每个格子都要被覆盖住。木块的特点决定了我们覆盖一个格子最多只会影响到下一行的格子。这就可以让我们暂时只考虑两行。</p>
<p>假设现我们已经完全覆盖了前(i– 1)行。那么由于覆盖前(i-1)行导致第i行也不“完整”了。如下图：</p>
<p>xxxxxxxxx</p>
<p>ooxooxoxo</p>
<p>我们用x表示已经覆盖的格子，o表示没覆盖的格子。为了方便，我们使用9列。</p>
<p>我们考虑第i行的状态，上图中，第1列我们可以用1<em>1的覆盖掉，也可以用1</em>2的覆盖前两列。第4、5列的覆盖方式和第1、2列是同样的情况。第7列需要覆盖也有两种方式，即用1<em>1的覆盖或者用2</em>1的覆盖，但是这样会导致第（i+1)行第7列也被覆盖。第9列和第7列的情况是一样的。这样把第i行覆盖满了之后，我们再根据第(i+1)行被影响的状态对下一行进行覆盖。</p>
<p>那么每行有多少种状态呢？显然有2k，由于k很小，我们只有大约16种状态。如果我们对于这些状态之间的转换制作一个矩阵，矩阵的第i行第j列的数表示的是我们第m行是状态i，我们把它完整覆盖掉，并且使得第(m + 1)行变成状态j的可能的方法数，这个矩阵我们可以暴力搜索出来，搜索的方式就是枚举第m行的状态，然后尝试放木板，用所有的方法把第m行覆盖掉之后，下一行的状态。当然，我们也可以认为只有两行，并且第一行是2k种状态的一种，第二行起初是空白的，求使得第一行完全覆盖掉，第二行的状态有多少种类型以及每种出现多少次。</p>
<h4 id="动态规划">3.3、动态规划</h4>
<p>这个矩阵作用很大，其实我们覆盖的过程可以认为是这样：第一行是空的，我们看看把它覆盖了，第2行是什么样子的。根据第二行的状态，我们把它覆盖掉，看看第3行是什么样子的。</p>
<p>如果我们知道第i行的状态为s,怎么考虑第i行完全覆盖后，第(i+1)行的状态？那只要看那个矩阵的状态s对应的行就可以了。我们可以考虑一下，把两个这样的方阵相乘得到得结果是什么。这个方阵的第i行第j个元素是这样得到的，是第i行第k个元素与第k行第j个元素的对k的叠加。它的意义是上一行是第m行是状态i，把第m行和第(m+ 1)行同时覆盖住，第(m+2)行的状态是j的方法数。这是因为中间第(m+1)行的所有状态k，我们已经完全遍历了。</p>
<p>于是我们发现，每做一次方阵的乘法，我们相当于把状态推动了一行。那么我们要坐多少次方阵乘法呢？就是题目中墙的长度2<sup>n</sup>,这个数太大了。但是事实上，我们可以不断地平方n次。也就是说我们可以算出A<sup>2</sup>,A<sup>4</sup>, A<sup>8</sup>, A<sup>16</sup>……方法就是不断用结果和自己相乘，这样乘n次就可以了。</p>
<p>因此，我们最关键的问题就是建立矩阵A。我们可以这样表示一行的状态，从左到右分别叫做第0列，第1列……覆盖了我们认为是1，没覆盖我们认为是0，这样一行的状态可以表示维一个整数。某一列的状态我们可以用为运算来表示。例如，状态x第i列是否被覆盖，我们只需要判断x &amp; (1 &lt;&lt; i) 是否非0即可，或者判断(x &gt;&gt; i) &amp; 1， 用右移位的目的是防止溢出，但是本题不需要考虑溢出，因为k很小。 接下来的任务就是递归尝试放置方案了</p>
<h4 id="参考代码-1">3.4、参考代码</h4>
<p>最终结果，我们最初的行是空得，要求最后一行之后也不能被覆盖，所以最终结果是矩阵的第[0][0]位置的元素。另外，本题在乘法过程中会超出32位int的表示范围，需要临时用C/C++的long long，或者java的long。</p>
<p>参考代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@caopengcs 12/08/2013  </span>
<span class="ot">#ifdef WIN32  </span>
<span class="ot">#define ll __int64   </span>
<span class="ot">#else  </span>
<span class="ot">#define ll long long  </span>
<span class="ot">#endif  </span>
  
<span class="co">// 1 covered 0 uncovered  </span>
  
<span class="dt">void</span> cal(<span class="dt">int</span> a[<span class="dv">6</span>][<span class="dv">32</span>][<span class="dv">32</span>],<span class="dt">int</span> n,<span class="dt">int</span> col,<span class="dt">int</span> laststate,<span class="dt">int</span> nowstate)
{
    <span class="kw">if</span> (col &gt;= n)
    {
        ++a[n][laststate][nowstate];  
        <span class="kw">return</span>;  
    }  
    <span class="co">//不填 或者用1*1的填  </span>
    cal(a,n, col + <span class="dv">1</span>, laststate, nowstate);  
    <span class="kw">if</span> (((laststate &gt;&gt; col) &amp; <span class="dv">1</span>) == <span class="dv">0</span>)
    {
        cal(a,n, col + <span class="dv">1</span>, laststate, nowstate | (<span class="dv">1</span> &lt;&lt; col));  
        <span class="kw">if</span> ((col + <span class="dv">1</span> &lt; n) &amp;&amp; (((laststate &gt;&gt; (col + <span class="dv">1</span>)) &amp; <span class="dv">1</span>) == <span class="dv">0</span>))
        {
            cal(a,n, col + <span class="dv">2</span>, laststate, nowstate);  
        }  
    }  
}  
  
<span class="kw">inline</span> <span class="dt">int</span> mul(ll x, ll y)
{
    <span class="kw">return</span> x * y % <span class="dv">1000000007</span>;  
}  
  
<span class="dt">void</span> multiply(<span class="dt">int</span> n,<span class="dt">int</span> a[][<span class="dv">32</span>],<span class="dt">int</span> b[][<span class="dv">32</span>])
{ <span class="co">// b = a * a</span>
    <span class="dt">int</span> i,j, k;  
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i)
    {
        <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; n; ++j)
        {
            <span class="kw">for</span> (k = b[i][j] = <span class="dv">0</span>; k &lt; n; ++k)
            {
                <span class="kw">if</span> ((b[i][j] += mul(a[i][k],a[k][j])) &gt;= <span class="dv">1000000007</span>)
                {
                    b[i][j] -= <span class="dv">1000000007</span>;
                }  
            }  
        }  
    }  
}  
  
<span class="dt">int</span> calculate(<span class="dt">int</span> n,<span class="dt">int</span> k)
{
    <span class="dt">int</span> i, j;  
    <span class="dt">int</span> a[<span class="dv">6</span>][<span class="dv">32</span>][<span class="dv">32</span>],mat[<span class="dv">2</span>][<span class="dv">32</span>][<span class="dv">32</span>];  
    memset(a,<span class="dv">0</span>,<span class="kw">sizeof</span>(a));  
    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt;= <span class="dv">5</span>; ++i)
    {
        <span class="kw">for</span> (j = (<span class="dv">1</span> &lt;&lt; i) - <span class="dv">1</span>; j &gt;= <span class="dv">0</span>; --j)
        {
            cal(a,i, <span class="dv">0</span>, j, <span class="dv">0</span>);  
        }  
    }  
    memcpy(mat[<span class="dv">0</span>], a[k],<span class="kw">sizeof</span>(mat[<span class="dv">0</span>]));  
    k = (<span class="dv">1</span> &lt;&lt; k);  
    <span class="kw">for</span> (i = <span class="dv">0</span>; n; --n)
    {
        multiply(k, mat[i], mat[i ^ <span class="dv">1</span>]);  
        i ^= <span class="dv">1</span>;  
    }  
    <span class="kw">return</span> mat[i][<span class="dv">0</span>][<span class="dv">0</span>];  
}  </code></pre>
<h2 id="参考链接及推荐阅读-1">参考链接及推荐阅读</h2>
<ol type="1">
<li>caopengcs，<a href="http://blog.csdn.net/caopengcs/article/details/9928061">木块砌墙</a></li>
<li>红色标记，<a href="http://blog.csdn.net/dw14132124/article/details/9038417">木块砌墙</a></li>
<li>LoveHarvy，<a href="http://blog.csdn.net/wangyan_boy/article/details/9131501">木块砌墙</a></li>
<li><a href="http://hero.pongo.cn/Question/Details?ID=36&amp;ExamID=36">在线编译测试木块砌墙问题</a></li>
<li>hero上<a href="http://hero.pongo.cn/Question/Details?ExamID=36&amp;ID=36&amp;bsh_bid=273040296">木块砌墙一题</a></li>
</ol>
<h1 id="第三十四三十五章格子取数问题完美洗牌算法">第三十四~三十五章：格子取数问题，完美洗牌算法</h1>
<ul>
<li>题记</li>
<li>第三十四章、格子取数问题</li>
<li>题目详情</li>
<li>题目分析</li>
<li>解法一、直接搜索</li>
<li>解法二、动态规划</li>
<li>第三十五章、完美洗牌算法</li>
<li>题目详情</li>
<li>解法一、蛮力变换</li>
<li>解法二、完美洗牌算法</li>
<li>参考链接</li>
<li>后记</li>
</ul>
<p>作者：July、caopengcs、绿色夹克衫。致谢：西芹_new，陈利人，Peiyush Jain，白石，zinking。</p>
<h2 id="第三十四章格子取数问题">第三十四章:格子取数问题</h2>
<p>** 题目详情：** 有n*n个格子，每个格子里有正数或者0，从最左上角往最右下角走，只能向下和向右，一共走两次（即从左上角走到右下角走两趟），把所有经过的格子的数加起来，求最大值SUM，且两次如果经过同一个格子，则最后总和SUM中该格子的计数只加一次。</p>
<figure>
<img src="../images/34/34.1.jpg" />
</figure>
<p><strong>题目分析</strong>：此题是去年2013年搜狗的校招笔试题。初看到此题，因为要让两次走下来的路径总和最大，读者可能最初想到的思路可能是让每一次的路径都是最优的，即不顾全局，只看局部，让第一次和第二次的路径都是最优。</p>
<p>但问题马上就来了，虽然这一算法保证了连续的两次走法都是最优的，但却不能保证总体最优，相应的反例也不难给出，请看下图：</p>
<figure>
<img src="../images/34/34.2.jpg" />
</figure>
<p>上图中，图一是原始图，那么我们有以下两种走法可供我们选择：</p>
<ul>
<li>如果按照上面的局部贪优走法，那么第一次势必会如图二那样走，导致的结果是第二次要么取到2，要么取到3，</li>
<li>但若不按照上面的局部贪优走法，那么第一次可以如图三那样走，从而第二次走的时候能取到2 4 4，很显然，这种走法求得的最终SUM值更大；</li>
</ul>
<p>为了便于读者理解，我把上面的走法在图二中标记出来，而把应该正确的走法在上图三中标示出来，如下图所示：</p>
<figure>
<img src="../images/34/34.3.jpg" />
</figure>
<p>也就是说，上面图二中的走法太追求每一次最优，所以第一次最优，导致第二次将是很差；而图三第一次虽然不是最优，但保证了第二次不差，所以图三的结果优于图二。由此可知不要只顾局部而贪图一时最优，而丧失了全局最优。</p>
<h3 id="解法一直接搜索">解法一、直接搜索</h3>
<p>局部贪优不行，我们可以考虑穷举，但最终将导致复杂度过高，所以咱们得另寻良策。 <span class="citation" data-cites="西芹_new">@西芹_new</span>，针对此题，可以使用直接搜索法，一共搜（2n-2）步，每一步有四种走法，考虑不相交等条件可以剪去很多枝，代码如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//copyright@西芹_new 2013</span>
<span class="ot">#include &quot;stdafx.h&quot;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define N 5</span>
<span class="dt">int</span> map[<span class="dv">5</span>][<span class="dv">5</span>] =
{
    {<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">0</span>, <span class="dv">2</span>},
    {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>},
    {<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>},
    {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>},
    {<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">0</span>, <span class="dv">2</span>}
};
<span class="dt">int</span> sumMax = <span class="dv">0</span>;
<span class="dt">int</span> p1x = <span class="dv">0</span>;
<span class="dt">int</span> p1y = <span class="dv">0</span>;
<span class="dt">int</span> p2x = <span class="dv">0</span>;
<span class="dt">int</span> p2y = <span class="dv">0</span>;
<span class="dt">int</span> curMax = <span class="dv">0</span>;

<span class="dt">void</span> dfs( <span class="dt">int</span> index)
{
    <span class="kw">if</span> ( index == <span class="dv">2</span> * N - <span class="dv">2</span>)
    {
        <span class="kw">if</span> ( curMax &gt; sumMax)
            sumMax = curMax;
        <span class="kw">return</span>;
    }

    <span class="kw">if</span> ( !(p1x == <span class="dv">0</span> &amp;&amp; p1y == <span class="dv">0</span>) &amp;&amp; !(p2x == N - <span class="dv">1</span> &amp;&amp; p2y == N - <span class="dv">1</span>))
    {
        <span class="kw">if</span> ( p1x &gt;= p2x &amp;&amp; p1y &gt;= p2y )
            <span class="kw">return</span>;
    }

    <span class="co">//right right</span>
    <span class="kw">if</span> ( p1x + <span class="dv">1</span> &lt; N &amp;&amp; p2x + <span class="dv">1</span> &lt; N )
    {
        p1x++;
        p2x++;
        <span class="dt">int</span> sum = map[p1x][p1y] + map[p2x][p2y];
        curMax += sum;
        dfs(index + <span class="dv">1</span>);
        curMax -= sum;
        p1x--;
        p2x--;
    }

    <span class="co">//down down</span>
    <span class="kw">if</span> ( p1y + <span class="dv">1</span> &lt; N &amp;&amp; p2y + <span class="dv">1</span> &lt; N )
    {
        p1y++;
        p2y++;
        <span class="dt">int</span> sum = map[p1x][p1y] + map[p2x][p2y];
        curMax += sum;
        dfs(index + <span class="dv">1</span>);
        curMax -= sum;
        p1y--;
        p2y--;
    }

    <span class="co">//rd</span>
    <span class="kw">if</span> ( p1x + <span class="dv">1</span> &lt; N &amp;&amp; p2y + <span class="dv">1</span> &lt; N )
    {
        p1x++;
        p2y++;
        <span class="dt">int</span> sum = map[p1x][p1y] + map[p2x][p2y];
        curMax += sum;
        dfs(index + <span class="dv">1</span>);
        curMax -= sum;
        p1x--;
        p2y--;
    }

    <span class="co">//dr</span>
    <span class="kw">if</span> ( p1y + <span class="dv">1</span> &lt; N &amp;&amp; p2x + <span class="dv">1</span> &lt; N )
    {
        p1y++;
        p2x++;
        <span class="dt">int</span> sum = map[p1x][p1y] + map[p2x][p2y];
        curMax += sum;
        dfs(index + <span class="dv">1</span>);
        curMax -= sum;
        p1y--;
        p2x--;
    }
}

<span class="dt">int</span> _tmain(<span class="dt">int</span> argc, _TCHAR* argv[])
{
    curMax = map[<span class="dv">0</span>][<span class="dv">0</span>];
    dfs(<span class="dv">0</span>);
    cout &lt;&lt; sumMax - map[N - <span class="dv">1</span>][N - <span class="dv">1</span>] &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h3 id="解法二动态规划">解法二、动态规划</h3>
<p>上述解法一的搜索解法是的时间复杂度是指数型的，如果是只走一次的话，是经典的dp。</p>
<h4 id="dp思路详解">2.1、DP思路详解</h4>
<p>故正如@绿色夹克衫所说：此题也可以用动态规划求解，主要思路就是同时DP 2次所走的状态。</p>
<p>1、先来分析一下这个问题，为了方便讨论，先对矩阵做一个编号，且以5*5的矩阵为例（给这个矩阵起个名字叫M1）：</p>
<p>M1 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8</p>
<p>从左上(0)走到右下(8)共需要走8步（2*5-2）。我们设所走的步数为s。因为限定了只能向右和向下走，因此无论如何走，经过8步后（s = 8)都将走到右下。而DP的状态也是依据所走的步数来记录的。</p>
<p>再来分析一下经过其他s步后所处的位置，根据上面的讨论，可以知道：</p>
<ul>
<li>经过8步后，一定处于右下角(8)；</li>
<li>那么经过5步后(s = 5)，肯定会处于编号为5的位置；</li>
<li>3步后肯定处于编号为3的位置；</li>
<li>s = 4的时候，处于编号为4的位置，此时对于方格中，共有5（相当于n）个不同的位置，也是所有编号中最多的。</li>
</ul>
<p>故推广来说，对于n*n的方格，总共需要走2n - 2步，且当s = n - 1时，编号为n个，也是编号数最多的。</p>
<p>如果用DP[s,i,j]来记录2次所走的状态获得的最大值，其中s表示走s步，i和j分别表示在s步后第1趟走的位置和第2趟走的位置。</p>
<p>2、为了方便描述，再对矩阵做一个编号（给这个矩阵起个名字叫M2）：</p>
<p>M2 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4</p>
<p>把之前定的M1矩阵也再贴下：</p>
<p>M1 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 我们先看M1，在经过6步后，肯定处于M1中编号为6的位置。而M1中共有3个编号为6的，它们分别对应M2中的2 3 4。故对于M2来说，假设第1次经过6步走到了M2中的2，第2次经过6步走到了M2中的4，DP[s,i,j] 则对应 DP[6,2,4]。由于s = 2n - 2,0 &lt;= i&lt;= &lt;= j &lt;= n，所以这个DP共有O(n^3)个状态。</p>
<p>M1 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 再来分析一下状态转移，以DP[6,2,3]为例(就是上面M1中加粗的部分)，可以到达DP[6,2,3]的状态包括DP[5,1,2]，DP[5,1,3]，DP[5,2,2]，DP[5,2,3]。</p>
<p>3、下面，我们就来看看这几个状态：DP[5,1,2]，DP[5,1,3]，DP[5,2,2]，DP[5,2,3]，用加粗表示位置DP[5,1,2] DP[5,1,3] DP[5,2,2] DP[5,2,3] （加红表示要达到的状态DP[6,2,3]）</p>
<p>0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 2 3 4 5 6 2 3 4 5 6 2 3 4 5 6 2 3 4 5 6 3 4 5 6 7 3 4 5 6 7 3 4 5 6 7 3 4 5 6 7 4 5 6 7 8 4 5 6 7 8 4 5 6 7 8 4 5 6 7 8 因此：</p>
<pre><code>DP[6,2,3] = Max(DP[5,1,2] ，DP[5,1,3]，DP[5,2,2]，DP[5,2,3]) + 6,2和6,3格子中对应的数值    （式一） </code></pre>
<p>上面（式一）所示的这个递推看起来没有涉及：“如果两次经过同一个格子，那么该数只加一次的这个条件”，讨论这个条件需要换一个例子，以DP[6,2,2]为例：DP[6,2,2]可以由DP[5,1,1]，DP[5,1,2]，DP[5,2,2]到达，但由于i = j，也就是2次走到同一个格子，那么数值只能加1次。 所以当i = j时，</p>
<pre><code>DP[6,2,2] = Max(DP[5,1,1]，DP[5,1,2]，DP[5,2,2]) + 6,2格子中对应的数值                                （式二）</code></pre>
<p>4、故，综合上述的（式一），（式二）最后的递推式就是</p>
<p>if(i != j) DP[s, i ,j] = Max(DP[s - 1, i - 1, j - 1], DP[s - 1, i - 1, j], DP[s - 1, i, j - 1], DP[s - 1, i, j]) + W[s,i] + W[s,j] else DP[s, i ,j] = Max(DP[s - 1, i - 1, j - 1], DP[s - 1, i - 1, j], DP[s - 1, i, j]) + W[s,i] 其中W[s,i]表示经过s步后，处于i位置，位置i对应的方格中的数字。下一节我们将根据上述DP方程编码实现。</p>
<h4 id="dp方法实现">2.2、DP方法实现</h4>
<p>为了便于实现，我们认为所有不能达到的状态的得分都是负无穷，参考代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@caopengcs 2013</span>
<span class="dt">const</span> <span class="dt">int</span> N = <span class="dv">202</span>;
<span class="dt">const</span> <span class="dt">int</span> inf = <span class="dv">1000000000</span>;  <span class="co">//无穷大</span>
<span class="dt">int</span> dp[N * <span class="dv">2</span>][N][N];
bool isValid(<span class="dt">int</span> step, <span class="dt">int</span> x1, <span class="dt">int</span> x2, <span class="dt">int</span> n) <span class="co">//判断状态是否合法</span>
{
    <span class="dt">int</span> y1 = step - x1, y2 = step - x2;
    <span class="kw">return</span> ((x1 &gt;= <span class="dv">0</span>) &amp;&amp; (x1 &lt; n) &amp;&amp; (x2 &gt;= <span class="dv">0</span>) &amp;&amp; (x2 &lt; n) &amp;&amp; (y1 &gt;= <span class="dv">0</span>) &amp;&amp; (y1 &lt; n) &amp;&amp; (y2 &gt;= <span class="dv">0</span>) &amp;&amp; (y2 &lt; n));
}

<span class="dt">int</span> getValue(<span class="dt">int</span> step, <span class="dt">int</span> x1, <span class="dt">int</span> x2, <span class="dt">int</span> n)  <span class="co">//处理越界 不存在的位置 给负无穷的值</span>
{
    <span class="kw">return</span> isValid(step, x1, x2, n) ? dp[step][x1][x2] : (-inf);
}

<span class="co">//状态表示dp[step][i][j] 并且i &lt;= j, 第step步  两个人分别在第i行和第j行的最大得分 时间复杂度O(n^3) 空间复杂度O(n^3)</span>
<span class="dt">int</span> getAnswer(<span class="dt">int</span> a[N][N], <span class="dt">int</span> n)
{
    <span class="dt">int</span> P = n * <span class="dv">2</span> - <span class="dv">2</span>; <span class="co">//最终的步数</span>
    <span class="dt">int</span> i, j, step;

    <span class="co">//不能到达的位置 设置为负无穷大</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i)
    {
        <span class="kw">for</span> (j = i; j &lt; n; ++j)
        {
            dp[<span class="dv">0</span>][i][j] = -inf;
        }
    }
    dp[<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">0</span>] = a[<span class="dv">0</span>][<span class="dv">0</span>];

    <span class="kw">for</span> (step = <span class="dv">1</span>; step &lt;= P; ++step)
    {
        <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i)
        {
            <span class="kw">for</span> (j = i; j &lt; n; ++j)
            {
                dp[step][i][j] = -inf;
                <span class="kw">if</span> (!isValid(step, i, j, n))   <span class="co">//非法位置</span>
                {
                    <span class="kw">continue</span>;
                }
                <span class="co">//对于合法的位置进行dp</span>
                <span class="kw">if</span> (i != j)
                {
                    dp[step][i][j] = max(dp[step][i][j], getValue(step - <span class="dv">1</span>, i - <span class="dv">1</span>, j - <span class="dv">1</span>, n));
                    dp[step][i][j] = max(dp[step][i][j], getValue(step - <span class="dv">1</span>, i - <span class="dv">1</span>, j, n));
                    dp[step][i][j] = max(dp[step][i][j], getValue(step - <span class="dv">1</span>, i, j - <span class="dv">1</span>, n));
                    dp[step][i][j] = max(dp[step][i][j], getValue(step - <span class="dv">1</span>, i, j, n));
                    dp[step][i][j] += a[i][step - i] + a[j][step - j];  <span class="co">//不在同一个格子，加两个数</span>
                }
                <span class="kw">else</span>
                {
                    dp[step][i][j] = max(dp[step][i][j], getValue(step - <span class="dv">1</span>, i - <span class="dv">1</span>, j - <span class="dv">1</span>, n));
                    dp[step][i][j] = max(dp[step][i][j], getValue(step - <span class="dv">1</span>, i - <span class="dv">1</span>, j,  n));
                    dp[step][i][j] = max(dp[step][i][j], getValue(step - <span class="dv">1</span>, i, j,  n));
                    dp[step][i][j] += a[i][step - i]; <span class="co">// 在同一个格子里，只能加一次</span>
                }
            }
        }
    }
    <span class="kw">return</span> dp[P][n - <span class="dv">1</span>][n - <span class="dv">1</span>];
}</code></pre>
<p>复杂度分析：状态转移最多需要统计4个变量的情况，看做是O(1)的，共有O(n<sup>3)个状态，所以总的时间复杂度是O(n</sup>3)的，且dp数组开了N<sup>3大小，故其空间复杂度亦为O(n</sup>3)。</p>
<h4 id="dp实现优化版">2.3、DP实现优化版</h4>
<p>如上节末所说，2.2节实现的代码的复杂度空间复杂度是O(n<sup>3)，事实上，空间上可以利用滚动数组优化，由于每一步的递推只跟上1步的情况有关，因此可以循环利用数组，将空间复杂度降为O(n</sup>2)。</p>
<p>即我们在推算dp[step]的时候，只依靠它上一次的状态dp[step - 1]，所以dp数组的第一维，我们只开到2就可以了。即step为奇数时，我们用dp[1][i][j]表示状态，step为偶数我们用dp[0][i][j]表示状态，这样我们只需要O(n^2)的空间，这就是滚动数组的方法。滚动数组写起来并不复杂，只需要对上面的代码稍作修改即可，优化后的代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@caopengcs 8/24/2013</span>
<span class="dt">int</span> dp[<span class="dv">2</span>][N][N];

bool isValid(<span class="dt">int</span> step, <span class="dt">int</span> x1, <span class="dt">int</span> x2, <span class="dt">int</span> n) <span class="co">//判断状态是否合法</span>
{
    <span class="dt">int</span> y1 = step - x1, y2 = step - x2;
    <span class="kw">return</span> ((x1 &gt;= <span class="dv">0</span>) &amp;&amp; (x1 &lt; n) &amp;&amp; (x2 &gt;= <span class="dv">0</span>) &amp;&amp; (x2 &lt; n) &amp;&amp; (y1 &gt;= <span class="dv">0</span>) &amp;&amp; (y1 &lt; n) &amp;&amp; (y2 &gt;= <span class="dv">0</span>) &amp;&amp; (y2 &lt; n));
}

<span class="dt">int</span> getValue(<span class="dt">int</span> step, <span class="dt">int</span> x1, <span class="dt">int</span> x2, <span class="dt">int</span> n)  <span class="co">//处理越界 不存在的位置 给负无穷的值</span>
{
    <span class="kw">return</span> isValid(step, x1, x2, n) ? dp[step % <span class="dv">2</span>][x1][x2] : (-inf);
}

<span class="co">//状态表示dp[step][i][j] 并且i &lt;= j, 第step步  两个人分别在第i行和第j行的最大得分 时间复杂度O(n^3) 使用滚动数组 空间复杂度O(n^2)</span>
<span class="dt">int</span> getAnswer(<span class="dt">int</span> a[N][N], <span class="dt">int</span> n)
{
    <span class="dt">int</span> P = n * <span class="dv">2</span> - <span class="dv">2</span>; <span class="co">//最终的步数</span>
    <span class="dt">int</span> i, j, step, s;

    <span class="co">//不能到达的位置 设置为负无穷大</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i)
    {
        <span class="kw">for</span> (j = i; j &lt; n; ++j)
        {
          dp[<span class="dv">0</span>][i][j] = -inf;
        }
    }
    dp[<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">0</span>] = a[<span class="dv">0</span>][<span class="dv">0</span>];

    <span class="kw">for</span> (step = <span class="dv">1</span>; step &lt;= P; ++step)
    {
        <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i)
        {
            <span class="kw">for</span> (j = i; j &lt; n; ++j)
            {
                dp[step][i][j] = -inf;
                <span class="kw">if</span> (!isValid(step, i, j, n))   <span class="co">//非法位置</span>
                {
                    <span class="kw">continue</span>;
                }
                s = step % <span class="dv">2</span>;  <span class="co">//状态下表标</span>
                <span class="co">//对于合法的位置进行dp</span>
                <span class="kw">if</span> (i != j)
                {
                    dp[s][i][j] = max(dp[s][i][j], getValue(step - <span class="dv">1</span>, i - <span class="dv">1</span>, j - <span class="dv">1</span>, n));
                    dp[s][i][j] = max(dp[s][i][j], getValue(step - <span class="dv">1</span>, i - <span class="dv">1</span>, j, n));
                    dp[s][i][j] = max(dp[s][i][j], getValue(step - <span class="dv">1</span>, i, j - <span class="dv">1</span>, n));
                    dp[s][i][j] = max(dp[s][i][j], getValue(step - <span class="dv">1</span>, i, j, n));
                    dp[s][i][j] += a[i][step - i] + a[j][step - j];  <span class="co">//不在同一个格子，加两个数</span>
                }
                <span class="kw">else</span>
                {
                    dp[s][i][j] = max(dp[s][i][j], getValue(step - <span class="dv">1</span>, i - <span class="dv">1</span>, j - <span class="dv">1</span>, n));
                    dp[s][i][j] = max(dp[s][i][j], getValue(step - <span class="dv">1</span>, i - <span class="dv">1</span>, j,  n));
                    dp[s][i][j] = max(dp[s][i][j], getValue(step - <span class="dv">1</span>, i, j,  n));
                    dp[s][i][j] += a[i][step - i]; <span class="co">// 在同一个格子里，只能加一次</span>
                }
            }
        }
    }
    <span class="kw">return</span> dp[P % <span class="dv">2</span>][n - <span class="dv">1</span>][n - <span class="dv">1</span>];
}</code></pre>
<p>本第34章分析完毕。</p>
<h1 id="第三十五章完美洗牌算法">第三十五章：完美洗牌算法</h1>
<p>题目详情：有个长度为2n的数组{a1,a2,a3,...,an,b1,b2,b3,...,bn}，希望排序后{a1,b1,a2,b2,....,an,bn}，请考虑有无时间复杂度o(n)，空间复杂度0(1)的解法。</p>
<p><strong>题目来源</strong>：此题是去年2013年UC的校招笔试题，看似简单，按照题目所要排序后的字符串蛮力变化即可，但若要完美的达到题目所要求的时空复杂度，则需要我们花费不小的精力。OK，请看下文详解，一步步优化。</p>
<h2 id="解法一蛮力变换">解法一、蛮力变换</h2>
<p>题目要我们怎么变换，咱们就怎么变换。此题@陈利人也分析过，在此，引用他的思路进行说明。为了便于分析，我们取n=4，那么题目要求我们把</p>
<p>a1，a2，a3，a4，<strong>b1，b2，b3，b4</strong></p>
<p>变成</p>
<p>a1，b1，a2，b2，a3，b3，a4，b4</p>
<h3 id="步步前移">1.1、步步前移</h3>
<p>仔细观察变换前后两个序列的特点，我们可做如下一系列操作：</p>
<p>第①步、确定b1的位置，即让b1跟它前面的a2，a3，a4交换：</p>
<p>a1，b1，a2，a3，a4，<strong>b2，b3，b4</strong></p>
<p>第②步、接着确定b2的位置，即让b2跟它前面的a3，a4交换：</p>
<p>a1，b1，a2，b2，a3，a4，<strong>b3，b4</strong></p>
<p>第③步、b3跟它前面的a4交换位置：</p>
<p>a1，b1，a2，b2，a3，b3，a4，b4</p>
<p>b4已在最后的位置，不需要再交换。如此，经过上述3个步骤后，得到我们最后想要的序列。但此方法的时间复杂度为O（N^2），我们得继续寻找其它方法，看看有无办法能达到题目所预期的O（N）的时间复杂度。</p>
<h3 id="中间交换">1.2、中间交换</h3>
<p>当然，除了如上面所述的让b1，b2，b3，b4步步前移跟它们各自前面的元素进行交换外，我们还可以每次让序列中最中间的元素进行交换达到目的。还是用上面的例子，针对a1，a2，a3，a4，b1，b2，b3，b4</p>
<p>第①步：交换最中间的两个元素a4，b1，序列变成（待交换的元素用粗体表示）：</p>
<p><strong>a1，a2，a3</strong>，b1，a4，<strong>b2，b3，b4</strong></p>
<p>第②步，让最中间的两对元素各自交换：</p>
<p><strong>a1，a2</strong>，b1，a3，b2，a4，<strong>b3，b4</strong></p>
<p>第③步，交换最中间的三对元素，序列变成：</p>
<p>a1，b1，a2，b2，a3，b3，a4，b4</p>
<p>同样，此法同解法1.1、步步前移一样，时间复杂度依然为O（N^2），我们得下点力气了。</p>
<h3 id="解法二完美洗牌算法">解法二、完美洗牌算法</h3>
<p>玩过扑克牌的朋友都知道，在一局完了之后洗牌，洗牌人会习惯性的把整副牌大致分为两半，两手各拿一半对着对着交叉洗牌，如下图所示：</p>
<figure>
<img src="../images/35/35.1.jpg" />
</figure>
<p>如果这副牌用a1 a2 a3 a4 b1 b2 b3 b4表示（为简化问题，假设这副牌只有8张牌），然后一分为二之后，左手上的牌可能是a1 a2 a3 a4，右手上的牌是b1 b2 b3 b4，那么在如上图那样的洗牌之后，得到的牌就可能是b1 a1 b2 a2 b3 a3 b4 a4。</p>
<p>技术来源于生活，2004年，microsoft的Peiyush Jain在他发表一篇名为：“A Simple In-Place Algorithm for In-Shuffle”的论文中提出了完美洗牌算法。</p>
<p>这个算法解决一个什么问题呢？跟本题有什么联系呢？</p>
<p>Yeah，顾名思义，完美洗牌算法解决的就是一个完美洗牌问题。什么是完美洗牌问题呢？即给定一个数组a1,a2,a3,...an,b1,b2,b3..bn,最终把它置换成b1,a1,b2,a2,...bn,an。读者可以看到，这个完美洗牌问题本质上与本题完全一致，只要在完美洗牌问题的基础上对它最后的序列swap两两相邻元素即可。</p>
<p>即：</p>
<pre><code>  a1,a2,a3,...an,b1,b2,b3..bn</code></pre>
<p>通过完美洗牌问题，得到：</p>
<pre><code>  b1,a1,b2,a2,b3,a3...  bn,an</code></pre>
<p>再让上面相邻的元素两两swap，即可达到本题的要求：</p>
<pre><code>  a1,b1,a2,b2,a3,b3....,an,bn</code></pre>
<p>也就是说，如果我们能通过完美洗牌算法（时间复杂度O(N)，空间复杂度O(1)）解决了完美洗牌问题，也就间接解决了本题。</p>
<p>虽然网上已有不少文章对上篇论文或翻译或做解释说明，但对于初学者来说，理解难度实在太大，再者，若直接翻译原文，根本无法看出这个算法怎么一步步得来的，故下文将从完美洗牌算法的最基本的原型开始说起，以让读者能对此算法一目了然。</p>
<h4 id="位置置换pefect_shuffle1算法">2.1、位置置换pefect_shuffle1算法</h4>
<p>为方便讨论，我们设定数组的下标从1开始，下标范围是[1..2n]。 还是通过之前n=4的例子，来看下每个元素最终去了什么地方。</p>
<p>起始序列：a1 a2 a3 a4 b1 b2 b3 b4 数组下标：1 2 3 4 5 6 7 8 最终序列：b1 a1 b2 a2 b3 a3 b4 a4</p>
<p>从上面的例子我们能看到，前n个元素中， &gt; 第1个元素a1到了原第2个元素a2的位置，即1-&gt;2； &gt; 第2个元素a2到了原第4个元素a4的位置，即2-&gt;4； &gt; 第3个元素a3到了原第6个元素b2的位置，即3-&gt;6； &gt; 第4个元素a4到了原第8个元素b4的位置，即4-&gt;8； &gt;</p>
<p>那么推广到一般情况即是：前n个元素中，第i个元素去了 第（2 * i）的位置。</p>
<p>上面是针对前n个元素，那么针对后n个元素，可以看出： &gt; 第5个元素b1到了原第1个元素a1的位置，即5-&gt;1； &gt; 第6个元素b2到了原第3个元素a3的位置，即6-&gt;3； &gt; 第7个元素b3到了原第5个元素b1的位置，即7-&gt;5； &gt; 第8个元素b4到了原第7个元素b3的位置，即8-&gt;7；</p>
<p>推广到一般情况是，后n个元素，第i个元素去了第 (2 * (i - n) ) - 1 = 2 * i - (2 * n + 1) = (2 * i) % (2 * n + 1) 个位置。</p>
<p>再综合到任意情况，任意的第i个元素，我们最终换到了 (2 * i) % (2 * n + 1)的位置。为何呢？因为： &gt; 当0 &lt; i &lt; n时， 原式= (2i) % (2 * n + 1) = 2i； &gt; 当i &gt; n时，原式(2 * i) % (2 * n + 1)保持不变。</p>
<p>因此，如果题目允许我们再用一个数组的话，我们直接把每个元素放到该放得位置就好了。也就产生了最简单的方法pefect_shuffle1，参考代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// 时间O(n)，空间O(n) 数组下标从1开始</span>
<span class="dt">void</span> pefect_shuffle1(<span class="dt">int</span> *a, <span class="dt">int</span> n)
{
    <span class="dt">int</span> n2 = n * <span class="dv">2</span>, i, b[N];
    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt;= n2; ++i)
    {
        b[(i * <span class="dv">2</span>) % (n2 + <span class="dv">1</span>)] = a[i];
    }
    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt;= n2; ++i)
    {
        a[i] = b[i];
    }
}</code></pre>
<p>但很明显，它的时间复杂度虽然是O(n)，但其空间复杂度却是O(n)，仍不符合本题所期待的时间O(n)，空间O(1)。我们继续寻找更优的解法。</p>
<p>与此同时，我也提醒下读者，根据上面变换的节奏，我们可以看出有两个圈， &gt; 一个是1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 7 -&gt; 5 -&gt; 1； &gt; 一个是3 -&gt; 6 -&gt; 3。</p>
<p>下文2.3.1、走圈算法cycle_leader将再次提到这两个圈。</p>
<h4 id="分而治之perfect_shuffle2算法">2.2、分而治之perfect_shuffle2算法</h4>
<p>熟悉分治法的朋友，包括若看了此文的读者肯定知道，当一个问题规模比较大时，则大而化小，分而治之。对于本题，假设n是偶数，我们试着把数组从中间拆分成两半(为了方便描述，只看数组下标就够了)：</p>
<p>原始数组的下标：1....2n，即（1 .. n/2， n/2+1..n）（n+1 .. n+n/2， n+n/2+1 .. 2n）</p>
<p>前半段（1 .. n/2， n/2+1..n）和后半段（n+1 .. n+n/2， n+n/2+1 .. 2n）的长度皆为n。</p>
<p>接下来，我们把前半段的后n/2个元素（n/2+1 .. n）和后半段的前n/2个元素（n+1..n+n/2）交换，得到 &gt; 新的前n个元素A：（1..n/2 n+1.. n+n/2） &gt; 新的后n个元素B：（n/2+1 .. n n+n/2+1 .. 2n）</p>
<p>换言之，当n是偶数的时候，我们把原问题拆分成了A，B两个子问题，继而原n的求解转换成了n‘ = n/2 的求解。</p>
<p>可当n是奇数的时候呢？我们可以把前半段多出来的那个元素a先拿出来放到末尾，后面所有元素前移，于此，新数列的最后两个元素满足已满足要求，只需考虑前2*(n-1)个元素即可，继而转换成了n-1的问题。</p>
<p>针对上述n分别为偶数和奇数的情况，下面举n=4和n=5两个例子来说明下。</p>
<p>①n=4时，原始数组即为</p>
<pre><code>a1 a2 a3 a4 b1 b2 b3 b4</code></pre>
<p>按照之前n为偶数时的思路，把前半段的后2个元素a3 a4同后半段的前2个元素b1 b2交换，可得：</p>
<pre><code>a1 a2 b1 b2 a3 a4 b3 b4</code></pre>
<p>因此，我们只要用pefect_shuffle1算法继续求解A（a1 a2 b1 b2）和B（a3 a4 b3 b4）两个子问题就可以了。</p>
<p>②当n=5时，原始数组则为</p>
<pre><code>a1 a2 a3 a4 a5 b1 b2 b3 b4 b5</code></pre>
<p>还是按照之前n为奇数时的思路，先把a5先单独拎出来放在最后，然后所有剩下的元素全部前移，变为：</p>
<pre><code>a1 a2 a3 a4 b1 b2 b3 b4 b5 a5</code></pre>
<p>此时，最后的两个元素b5 a5已经是我们想要的结果，只要跟之前n=4的情况一样考虑即可。</p>
<p>参考代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@caopengcs 8/23/2013</span>
<span class="co">//时间O(nlogn) 空间O(1) 数组下标从1开始</span>
<span class="dt">void</span> perfect_shuffle2(<span class="dt">int</span> *a, <span class="dt">int</span> n)
{
    <span class="dt">int</span> t, i;
    <span class="kw">if</span> (n == <span class="dv">1</span>)
    {
        t = a[<span class="dv">1</span>];
        a[<span class="dv">1</span>] = a[<span class="dv">2</span>];
        a[<span class="dv">2</span>] = t;
        <span class="kw">return</span>;
    }
    <span class="dt">int</span> n2 = n * <span class="dv">2</span>, n3 = n / <span class="dv">2</span>;
    <span class="kw">if</span> (n % <span class="dv">2</span> == <span class="dv">1</span>)    <span class="co">//奇数的处理</span>
    {
        t = a[n];
        <span class="kw">for</span> (i = n + <span class="dv">1</span>; i &lt;= n2; ++i)
        {
            a[i - <span class="dv">1</span>] = a[i];
        }
        a[n2] = t;
        --n;
    }
    <span class="co">//到此n是偶数</span>

    <span class="kw">for</span> (i = n3 + <span class="dv">1</span>; i &lt;= n; ++i)
    {
        t = a[i];
        a[i] = a[i + n3];
        a[i + n3] = t;
    }

    <span class="co">// [1.. n /2]</span>
    perfect_shuffle2(a, n3);
    perfect_shuffle2(a + n, n3);
}</code></pre>
<p>分析下此算法的复杂度： 每次，我们交换中间的n个元素，需要O(n)的时间，n是奇数的话，我们还需要O(n)的时间先把后两个元素调整好，但这不影响总体时间复杂度。</p>
<p>故事实上，当我们采用分治算法的时候，其时间复杂度的计算公式为： T(n) = 2*T(n / 2) + O(n) ，这个就是跟归并排序一样的复杂度式子，由《算法导论》中文第二版44页的主定理，可最终解得T(n) = O(nlogn)。至于空间，此算法在数组内部折腾的，所以是O(1)（在不考虑递归的栈的空间的前提下）。</p>
<h4 id="完美洗牌算法perfect_shuffle3">2.3、完美洗牌算法perfect_shuffle3</h4>
<h5 id="走圈算法cycle_leader">2.3.1、走圈算法cycle_leader</h5>
<p>因为之前无论是perfect_shuffle1，还是perfect_shuffle2，这两个算法的均未达到时间复杂度O（N）并且空间复杂度O（1）的要求，所以我们必须得再找一种新的方法，以期能完美的解决本节开头提出的完美洗牌问题。</p>
<p>让我们先来回顾一下2.1节位置置换perfect_shuffle1算法，还记得我之前提醒读者的关于当n=4时，通过位置置换让每一个元素到了最后的位置时，所形成的两个圈么？我引用下2.1节的相关内容：</p>
<p>当n=4的情况：</p>
<p>起始序列：a1 a2 a3 a4 b1 b2 b3 b4 数组下标：1 2 3 4 5 6 7 8 最终序列：b1 a1 b2 a2 b3 a3 b4 a4</p>
<p>即通过置换，我们得到如下结论：</p>
<p>“于此同时，我也提醒下读者，根据上面变换的节奏，我们可以看出有两个圈， &gt; 一个是1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 7 -&gt; 5 -&gt; 1； &gt; 一个是3 -&gt; 6 -&gt; 3。”</p>
<p>这两个圈可以表示为（1,2,4,8,7,5）和（3,6），且perfect_shuffle1算法也已经告诉了我们，不管你n是奇数还是偶数，每个位置的元素都将变为第（2*i） % （2n+1）个元素：</p>
<p>因此我们只要知道圈里最小位置编号的元素即圈的头部，顺着圈走一遍就可以达到目的，且因为圈与圈是不想交的，所以这样下来，我们刚好走了O（N）步。</p>
<p>还是举n=4的例子，且假定我们已经知道第一个圈和第二个圈的前提下，要让1 2 3 4 5 6 7 8变换成5 1 2 7 3 8 4：</p>
<p>第一个圈：1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 7 -&gt; 5 -&gt; 1 第二个圈：3 -&gt; 6 -&gt; 3：</p>
<p>原始数组：1 2 3 4 5 6 7 8 数组小标：1 2 3 4 5 6 7 8</p>
<p>走第一圈：5 1 3 2 7 6 8 4 走第二圈：5 1 6 2 7 3 8 4</p>
<p>上面沿着圈走的算法我们给它取名为cycle_leader，这部分代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//数组下标从1开始，from是圈的头部，mod是要取模的数 mod 应该为 2 * n + 1，时间复杂度O(圈长）</span>
<span class="dt">void</span> cycle_leader(<span class="dt">int</span> *a, <span class="dt">int</span> from, <span class="dt">int</span> mod)
{
    <span class="dt">int</span> last = a[from], t, i;

    <span class="kw">for</span> (i = from * <span class="dv">2</span> % mod; i != from; i = i * <span class="dv">2</span> % mod)
    {
        t = a[i];
        a[i] = last;
        last = t;
    }
    a[from] = last;
}</code></pre>
<h5 id="神级结论若2n3k---1则可确定圈的个数及各自头部的起始位置">2.3.2、神级结论：若2*n=（3^k - 1），则可确定圈的个数及各自头部的起始位置</h5>
<p>下面我要引用此论文“A Simple In-Place Algorithm for In-Shuffle”的一个结论了，即 对于2*n = （3<sup>k-1）这种长度的数组，恰好只有k个圈，且每个圈头部的起始位置分别是1,3,9，...3</sup>(k-1)。</p>
<p>论文原文部分为：</p>
<figure>
<img src="../images/35/35.2.jpg" />
</figure>
<p>也就是说，利用上述这个结论，我们可以解决这种特殊长度2*n = （3^k-1）的数组问题，那么若给定的长度n是任意的咋办呢？此时，我们可以借鉴2.2节、分而治之算法的思想，把整个数组一分为二，即拆分成两个部分：</p>
<p>让一部分的长度满足神级结论：若2*m = （3<sup>k-1），则恰好k个圈，且每个圈头部的起始位置分别是1,3,9，...3</sup>(k-1)。其中m &lt; n，m往神级结论所需的值上套；</p>
<p>剩下的n-m部分单独计算；</p>
<p>当把n分解成m和n-m两部分后，原始数组对应的下标如下（为了方便描述，我们依然只需要看数组下标就够了）：</p>
<p>原始数组下标：1..m m+1.. n， n+1 .. n+m, n+m+1,..2*n</p>
<p>参照之前2.2节、分而治之算法的思路，且更为了能让前部分的序列满足神级结论2*m = （3<sup>k-1），我们可以把中间那两段长度为n-m和m的段交换位置，即相当于把m+1..n，n+1..n+m的段循环右移m次（为什么要这么做？因为如此操作后，数组的前部分的长度为2m，而根据神级结论：当2m=3</sup>k-1时，可知这长度2m的部分恰好有k个圈）。</p>
<p>而如果读者看过本系列第一章、左旋转字符串的话，就应该意识到循环位移是有O（N）的算法的，其思想即是把前n-m个元素（m+1.. n）和后m个元素（n+1 .. n+m）先各自翻转一下，再将整个段（m+1.. n， n+1 .. n+m）翻转下。</p>
<p>这个翻转的代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//翻转字符串时间复杂度O(to - from)</span>
<span class="dt">void</span> reverse(<span class="dt">int</span> *a, <span class="dt">int</span> from, <span class="dt">int</span> to)
{
    <span class="dt">int</span> t;
    <span class="kw">for</span> (; from &lt; to; ++from, --to)
    {
        t = a[from];
        a[from] = a[to];
        a[to] = t;
    }
}

<span class="co">//循环右移num位 时间复杂度O(n)</span>
<span class="dt">void</span> right_rotate(<span class="dt">int</span> *a, <span class="dt">int</span> num, <span class="dt">int</span> n)
{
    reverse(a, <span class="dv">1</span>, n - num);
    reverse(a, n - num + <span class="dv">1</span>, n);
    reverse(a, <span class="dv">1</span>, n);
}</code></pre>
<p>翻转后，得到的目标数组的下标为：</p>
<pre><code> 目标数组下标：1..m n+1..n+m    m+1 .. n       n+m+1,..2*n</code></pre>
<p>OK，理论讲清楚了，再举个例子便会更加一目了然。当给定n=7时，若要满足神级结论2*n=3^k-1，k只能取2，继而推得n‘=m=4。</p>
<pre><code> 原始数组：a1 a2 a3 a4       a5 a6 a7     b1 b2 b3 b4   b5 b6 b7</code></pre>
<p>既然m=4，即让上述数组中有下划线的两个部分交换，得到：</p>
<pre><code>目标数组：a1 a2 a3 a4    b1 b2 b3 b4      a5 a6 a7     b5 b6 b7</code></pre>
<p>继而目标数组中的前半部分a1 a2 a3 a4 b1 b2 b3 b4部分可以用2.3.1、走圈算法cycle_leader搞定，于此我们最终求解的n长度变成了n’=3，即n的长度减小了4，单独再解决后半部分a5 a6 a7 b5 b6 b7即可。</p>
<h4 id="完美洗牌算法perfect_shuffle3-1">2.3.3、完美洗牌算法perfect_shuffle3</h4>
<p>从上文的分析过程中也就得出了我们的完美洗牌算法，其算法流程为： &gt; 输入数组　A[1..2 * n] &gt; step 1 找到 2 * m = 3^k - 1 使得 3^k &lt;= 2 * n &lt; 3^(k +1) &gt; step 2 把a[m + 1..n + m]那部分循环移m位 &gt; step 3 对每个i = 0,1,2..k - 1，3^i是个圈的头部，做cycle_leader算法，数组长度为m，所以对2 * m + 1取模。 &gt; step 4 对数组的后面部分A[2 * m + 1.. 2 * n]继续使用本算法, 这相当于n减小了m。</p>
<p>上述算法流程对应的论文原文为：</p>
<p>以上各个步骤对应的时间复杂度分析如下： &gt; 因为循环不断乘3的，所以时间复杂度O(logn) &gt; 循环移位O(n) &gt; 每个圈，每个元素只走了一次，一共2*m个元素，所以复杂度omega(m), 而m &lt; n，所以 也在O(n)内。 T(n - m) &gt; 因此总的时间复杂度为 T(n) = T(n - m) + O(n) ，m = omega(n) ，解得：T(n) = O(n)。</p>
<p>此完美洗牌算法实现的参考代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@caopengcs 8/24/2013</span>
<span class="co">//时间O(n)，空间O(1)</span>
<span class="dt">void</span> perfect_shuffle3(<span class="dt">int</span> *a, <span class="dt">int</span> n)
{
    <span class="dt">int</span> n2, m, i, k, t;
    <span class="kw">for</span> (; n &gt; <span class="dv">1</span>;)
    {
        <span class="co">// step 1</span>
        n2 = n * <span class="dv">2</span>;
        <span class="kw">for</span> (k = <span class="dv">0</span>, m = <span class="dv">1</span>; n2 / m &gt;= <span class="dv">3</span>; ++k, m *= <span class="dv">3</span>)
          ;
        m /= <span class="dv">2</span>;
        <span class="co">// 2m = 3^k - 1 , 3^k &lt;= 2n &lt; 3^(k + 1)</span>

        <span class="co">// step 2</span>
        right_rotate(a + m, m, n);

        <span class="co">// step 3</span>
        <span class="kw">for</span> (i = <span class="dv">0</span>, t = <span class="dv">1</span>; i &lt; k; ++i, t *= <span class="dv">3</span>)
        {
          cycle_leader(a , t, m * <span class="dv">2</span> + <span class="dv">1</span>);
        }

        <span class="co">//step 4</span>
        a += m * <span class="dv">2</span>;
        n -= m;

    }
    <span class="co">// n = 1</span>
    t = a[<span class="dv">1</span>];
    a[<span class="dv">1</span>] = a[<span class="dv">2</span>];
    a[<span class="dv">2</span>] = t;
}</code></pre>
<h5 id="perfect_shuffle3算法解决其变形问题">2.3.4、perfect_shuffle3算法解决其变形问题</h5>
<p>啊哈！以上代码即解决了完美洗牌问题，那么针对本章要解决的其变形问题呢？是的，如本章开头所说，在完美洗牌问题的基础上对它最后的序列swap两两相邻元素即可，代码如下：</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//copyright@caopengcs 8/24/2013</span>
<span class="co">//时间复杂度O(n)，空间复杂度O(1)，数组下标从1开始，调用perfect_shuffle3</span>
<span class="dt">void</span> shuffle(<span class="dt">int</span> *a, <span class="dt">int</span> n)
{
    <span class="dt">int</span> i, t, n2 = n * <span class="dv">2</span>;
    perfect_shuffle3(a, n);
    <span class="kw">for</span> (i = <span class="dv">2</span>; i &lt;= n2; i += <span class="dv">2</span>)
    {
        t = a[i - <span class="dv">1</span>];
        a[i - <span class="dv">1</span>] = a[i];
        a[i] = t;
   }
}</code></pre>
<p>上述的这个“在完美洗牌问题的基础上对它最后的序列swap两两相邻元素”的操作（当然，你也可以让原数组第一个和最后一个不变，中间的2 * (n - 1)项用原始的标准完美洗牌算法做），只是在完美洗牌问题时间复杂度O(N)空间复杂度O(1)的基础上再增加O(N)的时间复杂度，故总的时间复杂度O(N)不变，且理所当然的保持了空间复杂度O(1)。至此，咱们的问题得到了圆满解决！</p>
<h5 id="神级结论是如何来的">2.3.5、神级结论是如何来的？</h5>
<p>我们的问题得到了解决，但本章尚未完，即决定完美洗牌算法的神级结论：若2*n=（3^k - 1），则恰好只有k个圈，且每个圈头部的起始位置分别是1,3,9，...3^(k-1)，是如何来的呢？</p>
<figure>
<img src="../images/35/35.3.jpg" />
</figure>
<p>要证明这个结论的关键就是：这所有的圈合并起来必须包含从1到M之间的所有证书，一个都不能少。这个证明有点麻烦，因为证明过程中会涉及到群论等数论知识，但再远的路一步步走也能到达。</p>
<p>首先，让咱们明确以下相关的概念，定理，及定义（搞清楚了这些东西，咱们便证明了一大半）： &gt; 概念1 mod表示对一个数取余数，比如3 mod 5 =3，5 mod 3 =2； &gt; 定义1 欧拉函数ϕ(m) 表示为不超过m（即小于等于m）的数中，与m互素的正整数个数 &gt; 定义2 若ϕ(m)=Ordm(a) 则称a为m的原根，其中Ordm(a)定义为：a ^d （ mod m），其中d=0,1,2,3…，但取让等式成立的最小的那个d。</p>
<p>结合上述定义1、定义2可知，2是3的原根，因为2^0 mod 3 = 1, 2^1 mod 3 = 2, 2^2 mod 3 = 1, 2^3 mod 3 = 2，{a^0 mod m，a^1 mod m，a^2}得到集合S={1,2}，包含了所有和3互质的数，也即d=ϕ(2)=2，满足原根定义。</p>
<p>而2不是7的原根，这是因为2^0 mod 7 = 1, 2^1 mod 7 = 2, 2^2 mod 7 = 4, 2^3 mod 7 = 1，2^4 mod 7 = 2，2^5 mod 7 = 4，2^6 mod 7 = 1，从而集合S={1,2,4}中始终只有1、2、4三种结果，而没包含全部与7互质的数（3、6、5便不包括）,，即d=3，但ϕ(7)=6，从而d != ϕ(7)，不满足原根定义。</p>
<p>再者，如果说一个数a，是另外一个数m的原根，代表集合S = {a^0 mod m, a^1 mod m, a^2 mod m…… }，得到的集合包含了所有小于m并且与m互质的数，否则a便不是m的原根。而且集合S = {a^0 mod m, a^1 mod m, a^2 mod m…… }中可能会存在重复的余数，但当a与m互质的时候，得到的{a^0 mod m, a^1 mod m, a^2 mod m}集合中，保证了第一个数是a^0 mod m，故第一次发现重复的数时，这个重复的数一定是1，也就是说，出现余数循环一定是从开头开始循环的。 &gt; 定义3 对模指数，a对模m的原根定义为 <img src="../images/35/35.4.jpg" />,st:<img src="../images/35/35.5.jpg" />中最小的正整数d</p>
<p>再比如，2是9的原根，因为<img src="../images/35/35.6.jpg" />，为了让<img src="../images/35/35.7.jpg" />除以9的余数恒等于1，可知最小的正整数d=6，而ϕ(m)=6，满足原根的定义。 &gt; 定理1 同余定理：两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作<img src="../images/35/35.8.jpg" />，读做a与b关于模m同余。 &gt; 定理2 当p为奇素数且a是<img src="../images/35/35.9.jpg" />的原根时⇒ a也是<img src="../images/35/35.10.jpg" />的原根 &gt; 定理3 费马小定理：如果a和m互质，那么a^ϕ(m) mod m = 1 &gt; 定理4 若(a,m)=1 且a为m的原根，那么a是(Z/mZ)*的生成元。</p>
<p>取a = 2, m = 3。</p>
<p>我们知道2是3的原根，2是9的原根，我们定义S(k)表示上述的集合S，并且取x = 3^k（x表示为集合S中的数）。</p>
<p>所以：</p>
<pre><code>  S(1) = {1, 2}
  S(2) = {1, 2, 4, 8, 7, 5}</code></pre>
<p>我们没改变圈元素的顺序，由前面的结论S(k)恰好是一个圈里的元素，且认为从1开始循环的，也就是说从1开始的圈包含了所有与3^k互质的数。</p>
<p>那与3^k不互质的数怎么办？如果0 &lt; i &lt; 3^k与 3^k不互质，那么i 与3<sup>k的最大公约数一定是3</sup>t的形式（只包含约数3)，并且 t &lt; k。即gcd(i , 3^k) = 3^t，等式两边除以个3 ^ t，即得gcd( i/(3<sup>t)，3</sup>(k - t) ) = 1， i/(3^t) 都与3^(k - t) 互质了，并且i / (3^t) &lt; 3^(k - t), 根据S(k)的定义，可见i/(3^t) 在集合S(k - t)中。</p>
<p>同理，任意S(k - t)中的数x，都满足gcd(x , 3^k) = 1,于是gcd(3^k , x* 3^t) = 3 ^ t, 并且x<em>3^t &lt; 3^k。可见S(k - t)中的数x</em>3^t 与 i形成了一一对应的关系。</p>
<p>也就是说S(k - t)里每个数x* 3<sup>t形成的新集合包含了所有与3</sup>k的最大公约数为3<sup>t的数，它也是一个圈,原先圈的头部是1，这个圈的头部是3</sup>t。</p>
<p>于是，对所有的小于 3<sup>k的数，根据它和3</sup>k的最大公约数，我们都把它分配到了一个圈里去了，且k个圈包含了所有的小于3^k的数。</p>
<p>下面，举个例子，如caopengcs所说，当我们取“a = 2, m = 3时，</p>
<p>我们知道2是3的原根，2是9的原根，我们定义S(k)表示上述的集合S，并且x= 3^k。</p>
<p>所以S(1) = {1, 2}</p>
<p>S(2) = {1, 2, 4, 8, 7, 5}</p>
<p>比如k = 3。 我们有：</p>
<p>S(3) = {1, 2 ,4 , 8, 16, 5, 10, 20, 13, 26, 25, 23, 19, 11, 22, 17, 7, 14} 包含了小于27且与27互质的所有数，圈的首部为1，这是原根定义决定的。</p>
<p>那么与27最大公约数为3的数，我们用S(2)中的数乘以3得到。 S(2) * 3 = {3, 6, 12, 24, 21, 15}, 圈中元素的顺序没变化，圈的首部是3。</p>
<p>与27最大公约数为9的数，我们用S(1)中的数乘以9得到。 S(1) * 9 = {9, 18}, 圈中得元素的顺序没变化，圈的首部是9。</p>
<p>因为每个小于27的数和27的最大公约数只有1, 3, 9这3种情况，又由于前面所证的一一对应的关系，所以S(2) * 3包含了所有小于27且与27的最大公约数为3的数，S(1) * 9 包含了所有小于27且和27的最大公约数为9的数。”</p>
<p>换言之，若定义为整数，假设/N定义为整数Z除以N后全部余数的集合，包括{0...N-1}等N个数，而（/N)*则定义为这Z/N中{0...N-1}这N个余数内与N互质的数集合。</p>
<p>则当n=13时，2n+1=27，即得/N =｛0,1,2,3,.....,26}，（/N)*相当于就是｛0,1,2,3,.....,26}中全部与27互素的数的集合；</p>
<p>而2^k(mod 27)可以把（/27)*取遍，故可得这些数分别在以下3个圈内：</p>
<p>取头为1，（/27)*＝｛1,2,4,8,16,5,10,20,13,26,25,23,19,11,22,17,7,14｝，也就是说，与27互素且小于27的正整数集合为{1,2,4,8,16,5,10,20,13,26,25,23,19,11,22,17,7,14}，因此ϕ(m) = ϕ(27)=18, 从而满足<img src="../images/35/35.11.jpg" />的最小d = 18，故得出2为27的原根；</p>
<p>取头为3，就可以得到｛3,6,12,24,21,15｝，这就是以3为头的环，这个圈的特点是所有的数都是3的倍数，且都不是9的倍数。为什么呢？因为2^k和27互素。</p>
<p>具体点则是：如果3×2<sup>k除27的余数能够被9整除，则有一个n使得3<em>2^k=9n(mod 27)，即3</em>2</sup>k－9n能够被27整除，从而3*2<sup>k－9n＝27m，其中n，m为整数，这样一来，式子约掉一个3，我们便能得到2</sup>k＝9m＋3n，也就是说，2<sup>k是3的倍数，这与2</sup>k与27互素是矛盾的，所以，3×2^k除27的余数不可能被9整除。</p>
<p>此外，2<sup>k除以27的余数可以是3的倍数以外的所有数，所以，2</sup>k除以27的余数可以为1,2,4,5,7,8，当余数为1时，即存在一个k使得2^k-1=27m，m为整数。</p>
<p>式子两边同时乘以3得到：3<em>2^k-3=81m是27的倍数，从而3</em>2^k除以27的余数为3；</p>
<p>同理，当余数为2时，2^k - 2 = 27m，=&gt; 3<em>2^k- 6 =81m，从而3</em>2^k除以27的余数为6；</p>
<p>当余数为4时，2^k - 4 = 37m，=&gt; 3<em>2^k - 12 =81m，从而3</em>2^k除以27的余数为12；</p>
<p>同理，可以取到15，21，24。从而也就印证了上面的结论：取头为3，就可以得到｛3,6,12,24,21,15｝。 取9为头，这就很简单了，这个圈就是｛9,18}</p>
<p>你会发现，小于27的所有自然数，要么在第一个圈里面，也就是那些和27互素的数；要么在第二个圈里面，也就是那些是3的倍数，但不是9的倍数的数；要么在第三个圈里面，也就是是9倍数的数，而之所以能够这么做，就是因为2是27的本原根。证明完毕。</p>
<p>最后，咱们也再验证下上述过程：</p>
<p>因为<img src="../images/35/35.12.jpg" />，故：</p>
<p>i = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27</p>
<p>由于n=13，2n+1 = 27，据此<img src="../images/35/35.13.jpg" />公式可知，上面第 i 位置的数将分别变成下述位置的：</p>
<p>i = 2 4 6 8 10 12 14 16 18 20 22 24 26 1 3 5 7 9 11 13 15 17 19 21 23 25 0</p>
<p>根据i 和 i‘ 前后位置的变动，我们将得到3个圈：</p>
<pre><code>   1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;5-&gt;10-&gt;20-&gt;13-&gt;26-&gt;25-&gt;23-&gt;19-&gt;11-&gt;22-&gt;17-&gt;7-&gt;14-&gt;1；
   3-&gt;6-&gt;12-&gt;24-&gt;21-&gt;15-&gt;3
   9-&gt;18-&gt;9</code></pre>
<p>没错，这3个圈的数字与咱们之前得到的3个圈一致吻合，验证完毕。</p>
<h4 id="完美洗牌问题的几个扩展">2.3.6、完美洗牌问题的几个扩展</h4>
<p>至此，本章开头提出的问题解决了，完美洗牌算法的证明也证完了，是否可以止步了呢？OH，NO！读者有无思考过下述问题：</p>
<p>既然完美洗牌问题是给定输入：a1,a2,a3,……aN,b1,b2,b3,……bN，要求输出：b1,a1,b2,a2,……bN,aN；那么有无考虑过它的逆问题：即给定b1,a1,b2,a2,……bN,aN,，要求输出a1,a2,a3,……aN,b1,b2,b3,……bN ？ 完美洗牌问题是两手洗牌，假设有三只手同时洗牌呢？那么问题将变成：输入是a1,a2,……aN, b1,b2,……bN, c1,c2,……cN，要求输出是c1,b1,a1,c2,b2,a2,……cN,bN,aN，这个时候，怎么处理？</p>
<p>以上两个完美洗牌问题的几个扩展请读者思考，具体解答请参看参考链接第15条。</p>
<p>本第35章完。</p>
<h3 id="参考链接">参考链接</h3>
<p><a href="http://blog.csdn.net/huangxy10/article/details/8071242">huangxy10</a></p>
<p><span class="citation" data-cites="绿色夹克衫">[@绿色夹克衫]</span>(http://www.51nod.com/answer/index.html#!answerId=598)</p>
<p><a href="http://wenku.baidu.com/view/681c853b580216fc700afd9a.html">格子取数的蛮力穷举法</a></p>
<p><span class="citation" data-cites="陈立人">[@陈立人]</span>(http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5ODIzNDQ3Mw==&amp;appmsgid=10000141&amp;itemidx=1&amp;sign=4f1aa1a2269a1fac88be49c8cba21042)</p>
<p><a href="http://blog.csdn.net/caopengcs/article/details/10196035">caopengcs</a></p>
<p><a href="http://att.newsmth.net/att.php?p.1032.47005.1743.pdf">完美洗牌算法的原始论文“A Simple In-Place Algorithm for In-Shuffle”</a></p>
<p><a href="http://en.wikipedia.org/wiki/Primitive_root_modulo_n">原始根模</a></p>
<p><a href="http://www.thecodeway.com/blog/?p=680">洗牌的学问</a></p>
<p><a href="http://cs.stackexchange.com/questions/332/in-place-algorithm-for-interleaving-an-array/400#400">关于完美洗牌算法</a></p>
<p><a href="http://www.emis.de/journals/DMTCS/pdfpapers/dm050111.pdf">关于完美洗牌算法中圈的说明</a></p>
<p><a href="http://math.stackexchange.com/questions/477125/how-to-prove-algebraic-structure-of-the-perfect-shuffle">关于神级结论的讨论</a>（左边链接中的讨论中有错误，以在本文2.3.5节进行了相关修正）</p>
<p><a href="http://blog.csdn.net/caopengcs/article/details/10429013">caopengcs关于神级结论的证明</a></p>
<p><a href="http://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98">同余的概念</a></p>
<p>[神奇的费马小定理](http://www.xieguofang.cn/Maths/Number_Theory/Fermat's_Little_Theorem_1.htm)</p>
<p><a href="http://blog.csdn.net/caopengcs/article/details/10521603">完美洗牌问题的几个扩展</a></p>
<p><a href="http://wenku.baidu.com/view/bbb88ffc910ef12d2af9e738">原根与指数的介绍</a></p>
<p>《数论概论》Joseph H. Silverman著，推荐理由：因写上文中的完美洗牌算法遇到了一堆数论定理受了刺激，故推荐此书；</p>
<h3 id="后记-2">后记</h3>
<p>以上第35章可能是整个系列迄今为止我最满意的一篇，不仅仅是因为此章思路清晰，过渡自然，代码风格良好，更因为有了@曹鹏博士 的加入，编程艺术如虎添翼，质量更上一层！</p>
<p>编程艺术通过解决一个个实际的编程面试题，让广大初学者一步步学会分析问题解决问题优化问题的能力，且每个问题的讲解足够通俗，希望后续我(们)做得越来越好！July、二零一三年八月二十四日凌晨零点三十七分。</p>
<h1 id="第三十六三十七章搜索智能提示suggestion附近点搜索">第三十六~三十七章：搜索智能提示suggestion，附近点搜索</h1>
<p>作者：July。致谢：caopengcs、胡果果。</p>
<h2 id="题记-1">题记</h2>
<p>OK，切入正题。上面说整理过很多笔试面试题，但好的笔试面试题真心难求，包括在编程艺术系列每一章的选题，越到后面越难挑，而本文写两个跟实际挂钩的问题，它们来自<a href="http://blog.csdn.net/v_july_v/article/details/7974418">此文</a>的第3.6题，和第87题，即</p>
<ul>
<li>第三十六章、搜索引擎中中的关键词智能提示suggestion；</li>
<li>第三十七章、附近地点的搜索；</li>
</ul>
<h2 id="第三十六章搜索关键词智能提示suggestion">第三十六章、搜索关键词智能提示suggestion</h2>
<p><strong>题目详情：</strong>百度搜索框中，输入“北京”，搜索框下面会以北京为前缀，展示“北京爱情故事”、“北京公交”、“北京医院”等等搜索词，输入“<a href="http://www.baidu.com/s?wd=结构之&amp;rsv_bp=0&amp;ch=&amp;tn=baidu&amp;bar=&amp;rsv_spt=3&amp;ie=utf-8&amp;rsv_sug3=8&amp;rsv_sug=0&amp;rsv_sug4=1075&amp;rsv_sug1=3&amp;inputT=2559">结构之</a>”，会提示“结构之法”，“结构之法 算法之道”等搜索词。 请问，如何设计此系统，使得空间和时间复杂度尽量低。</p>
<figure>
<img src="../images/36~37/36.1.jpg" />
</figure>
<p><strong>题目分析：</strong>本题来源于去年2012年百度的一套实习生笔试题中的系统设计题（<em>为尊重原题，本章主要使用百度搜索引擎展开论述，而不是google等其它搜索引擎，但原理不会差太多。然脱离本题，平时搜的时候，鼓励用...</em>），题目比较开放，考察的目的在于看应聘者解决问题的思路是否清晰明确，其次便是看能考虑到多少细节。</p>
<p>我去年整理此题的时候，曾简单解析过，提出的方法是：</p>
<ul>
<li>直接上<strong>Trie树</strong>「Trie树的介绍见：从Trie树（字典树）谈到后缀树」 + <strong>TOP K</strong>「hashmap+堆，hashmap+堆 统计出如10个近似的热词，也就是说，只存与关键词近似的比如10个热词」</li>
</ul>
<p>方法就是这样子的：Trie树+TOP K算法，但在实际中，真的只要Trie树 + TOP K算法就够了么，有什么需要考虑的细节？OK，请看下文娓娓道来。</p>
<h3 id="解法一trie树-top-k">解法一、Trie树 + TOP K</h3>
<h4 id="步骤一trie树存储前缀后缀">步骤一、trie树存储前缀后缀</h4>
<p>若看过博客内这篇<a href="http://blog.csdn.net/v_july_v/article/details/6897097">介绍Trie树和后缀树的文章</a>的话，应该就能对trie树有个大致的了解，为示本文完整性，引用下原文内容，如下：</p>
<p><strong>1.1、什么是Trie树</strong></p>
<p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p>
<p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>它有3个基本性质：</p>
<ol type="1">
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<p><strong>1.2、树的构建</strong></p>
<p>举个在网上流传颇广的例子，如下：</p>
<p>题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置。</p>
<p>分析：这题当然可以用hash来解决，但是本文重点介绍的是trie树，因为在某些方面它的用途更大。比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不好搞了，而用trie还是很简单。</p>
<p>现在回到例子中，如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是O(n^2)。显然对于100000的范围难以接受。现在我们换个思路想。假设我要查询的单词是abcd，那么在他前面的单词中，以b，c，d，f之类开头的我显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。</p>
<p>好比假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的：</p>
<figure>
<img src="../images/36~37/36.2.jpg" />
</figure>
<p>当时第一次看到这幅图的时候，便立马感到此树之不凡构造了。单单从上幅图便可窥知一二，好比大海搜人，立马就能确定东南西北中的到底哪个方位，如此迅速缩小查找的范围和提高查找的针对性，不失为一创举。</p>
<p>ok，如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。</p>
<p>那么，对于一个单词，我只要顺着他从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。</p>
<p>借用上面的图，当用户输入前缀a的时候，搜索框可能会展示以a为前缀的“abcd”，“abd”等关键词，再当用户输入前缀b的时候，搜索框下面可能会提示以b为前缀的“bcd”等关键词，如此，实现搜索引擎智能提示suggestion的第一个步骤便清晰了，即用trie树存储大量字符串，当前缀固定时，存储相对来说比较热的后缀。那又如何统计热词呢？请看下文步骤二、TOP K算法统计热词。</p>
<h4 id="步骤二top-k算法统计热词">步骤二、TOP K算法统计热词</h4>
<p>当每个搜索引擎输入一个前缀时，下面它只会展示0~10个候选词，但若是碰到那种候选词很多的时候，如何取舍，哪些展示在前面，哪些展示在后面？这就是一个搜索热度的问题。</p>
<p>如本题描述所说，在去年的这个时候，当我在搜索框内搜索“北京”时，它下面会提示以“北京”为前缀的诸如“北京爱情故事”，“北京公交”，“北京医院”，且“ 北京爱情故事”展示在第一个：</p>
<figure>
<img src="../images/36~37/36.3.jpg" />
</figure>
<p>为何输入“北京”，会首先提示“北京爱情故事”呢？因为去年的这个时候，正是《北京爱情故事》这部电视剧上映正火的时候（其上映日期为2012年1月8日，火了至少一年），那个时候大家都一个劲的搜索这部电视剧的相关信息，当10个人中输入“北京”后，其中有8个人会继续敲入“爱情故事”（连起来就是“北京爱情故事”）的时候，搜索引擎对此当然不会无动于衷。</p>
<p>也就是说，搜索引擎知道了这个时间段，大家都在疯狂查找北京爱情故事，故当用户输入以“北京”为前缀的时候，搜索引擎猜测用户有80%的机率是要查找“北京爱情故事”，故把“北京爱情故事”在下面提示出来，并放在第一个位置上。</p>
<p>但为何今年这个时候再次搜索“北京”的时候，它展示出来的词不同了呢？</p>
<p>原因在于随着时间变化，人们对《北京爱情故事》这部电视剧的关注度逐渐下降，与此同时，又出现了新的热词，或新的电影，故现在虽然同样是输入“北京”，后面提示的词也相应跟着起了变化。那解决这个问题的办法是什么呢？如开头所说：定期分析某段时间内的人们搜索的关键词，统计出搜索次数比较多的热词，继而当用户输入某个前缀时，优先展示热词。</p>
<p>故说白了，这个问题的第二个步骤便是统计热词，我们把统计热词的方法称为TOP K算法，此算法的应用场景便是<a href="http://blog.csdn.net/v_july_v/article/details/7382693">此文</a>中的第2个问题，再次原文引用：</p>
<p><strong>寻找热门查询，300万个查询字符串中统计最热门的10个查询</strong></p>
<p>原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>解答：由上面第1题，我们知道，数据大则划为小的，如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结果。</p>
<p>但如果数据规模本身就比较小，能一次性装入内存呢？比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只是需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。</p>
<p>所以我们放弃分而治之/hash映射的步骤，直接上hash统计，然后排序。So，针对此类典型的TOP K问题，采取的对策往往是：hashmap + 堆。如下所示：</p>
<ol type="1">
<li><strong>hashmap统计：</strong>先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；</li>
<li><strong>堆排序：</strong>第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N' * O（logK），（N为1000万，N’为300万）。</li>
</ol>
<p>别忘了这篇文章中所述的堆排序思路：‘维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时O（k），并调整堆(费时O（logk）)后，有k1&gt;k2&gt;...kmin（kmin设为小顶堆中最小元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若x&gt;kmin，则更新堆（x入堆，用时logk），否则不更新堆。这样下来，总费时O（k*logk+（n-k）*logk）=O（n*logk）。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。’--第三章续、Top K算法问题的实现。</p>
<p>当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<p>相信，如此，也就不难理解开头所提出的方法了：Trie树+ TOP K「hashmap+堆，hashmap+堆 统计出如10个近似的热词，也就是说，只存与关键词近似的比如10个热词」。</p>
<p>而且你以后就可以告诉你身边的伙伴们，为何输入“结构之”，会提示出来一堆以“结构之”为前缀的词了：</p>
<figure>
<img src="../images/36~37/36.4.jpg" />
</figure>
<p>方法貌似成型了，但有哪些需要注意的细节呢？如@江申_Johnson所说：“实际工作里，比如当前缀很短的时候，候选词很多的时候，查询和排序性能可能有问题，也许可以加一层索引trie（这层索引可以只索引频率高于某一个阈值的词，很短的时候查这个就可以了。数量不够的话再去查索引了全部词的trie树）；而且有时候不能根据query频率来排，而要引导用户输入信息量更全面的query，或者或不仅仅是前缀匹配这么简单。”</p>
<h3 id="扩展阅读">扩展阅读</h3>
<p>除了上文提到的trie树，三叉树或许也是一个不错的解决方案：<a href="http://igoro.com/archive/efficient-auto-complete-with-a-ternary-search-tree/">点击此处</a>。此外，StackOverflow上也有两个讨论帖子，大家可以看看：<a href="http://stackoverflow.com/questions/2901831/algorithm-for-autocomplete">帖子1</a>，<a href="http://stackoverflow.com/questions/1783652/what-is-the-best-autocomplete-suggest-algorithm-datastructure-c-c">帖子2</a>。</p>
<h2 id="第三十七章附近地点搜索">第三十七章、附近地点搜索</h2>
<p><strong>题目详情：</strong>找一个点集中与给定点距离最近的点，同时，给定的二维点集都是固定的，查询可能有很多次，时间复杂度O(n)无法接受，请设计数据结构和相应的算法。</p>
<p><strong>题目分析：</strong>此题是去年微软的三面题，类似于一朋友@陈利人 出的这题：附近地点搜索，就是搜索用户附近有哪些地点。随着GPS和带有GPS功能的移动设备的普及，附近地点搜索也变得炙手可热。在庞大的地理数据库中搜索地点，索引是很重要的。但是，我们的需求是搜索附近地点，例如，坐标(39.91, 116.37)附近500米内有什么餐馆，那么让你来设计，该怎么做？</p>
<figure>
<img src="../images/36~37/37.1.jpg" />
</figure>
<h3 id="解法一r树二维搜索">解法一、R树二维搜索</h3>
<p>假定只允许你初中数学知识，那么你可能建一个X-Y坐标系，即以坐标(39.91, 116.37)为圆心，以500的长度为半径，画一个园，然后一个一个坐标点的去查找。此法看似可行，但复杂度可想而知，即便你自以为聪明的说把整个平面划分为四个象限，一个一个象限的查找，此举虽然优化程度不够，但也说明你一步步想到点子上去了。</p>
<p>即不一个一个坐标点的查找，而是一个一个区域的查找，相对来说，其平均查找速度和效率会显著提升。如此，便自然而然的想到了有没有一种一次查找定位于一个区域的数据结构呢？</p>
<p>若看过博客内之前介绍R树的<a href="http://blog.csdn.net/v_JULY_v/article/details/6530142#t2">这篇文章</a>的读者立马便能意识到，R树就是解决这个区域查找继而不断缩小规模的问题。特直接引用原文：</p>
<blockquote>
<p><strong>R树的数据结构</strong></p>
<p>R树是B树在高维空间的扩展，是一棵平衡树。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。这种方式使我们不必遍历所有数据即可获得答案，效率显著提高。下图1是R树的一个简单实例：</p>
</blockquote>
<figure>
<img src="../images/36~37/37.2.jpg" />
</figure>
<blockquote>
<p>我们在上面说过，R树运用了空间分割的理念，这种理念是如何实现的呢？R树采用了一种称为MBR(Minimal Bounding Rectangle)的方法，在此我把它译作“最小边界矩形”。从叶子结点开始用矩形（rectangle）将空间框起来，结点越往上，框住的空间就越大，以此对空间进行分割。有点不懂？没关系，继续往下看。在这里我还想提一下，R树中的R应该代表的是Rectangle（此处参考wikipedia上关于<a href="http://en.wikipedia.org/wiki/R-tree">R树</a>的介绍），而不是大多数国内教材中所说的Region（很多书把R树称为区域树，这是有误的）。我们就拿二维空间来举例。下图是Guttman论文中的一幅图：</p>
</blockquote>
<figure>
<img src="../images/36~37/37.3.jpg" />
</figure>
<p>我来详细解释一下这张图。</p>
<ol type="1">
<li>先来看图（b），首先我们假设所有数据都是二维空间下的点，图中仅仅标志了R8区域中的数据，也就是那个shape of data object。别把那一块不规则图形看成一个数据，我们把它看作是多个数据围成的一个区域。为了实现R树结构，我们用一个最小边界矩形恰好框住这个不规则区域，这样，我们就构造出了一个区域：R8。R8的特点很明显，就是正正好好框住所有在此区域中的数据。</li>
<li>其他实线包围住的区域，如R9，R10，R12等都是同样的道理。这样一来，我们一共得到了12个最最基本的最小矩形。这些矩形都将被存储在子结点中。</li>
<li>下一步操作就是进行高一层次的处理。我们发现R8，R9，R10三个矩形距离最为靠近，因此就可以用一个更大的矩形R3恰好框住这3个矩形。</li>
<li>同样道理，R15，R16被R6恰好框住，R11，R12被R4恰好框住，等等。所有最基本的最小边界矩形被框入更大的矩形中之后，再次迭代，用更大的框去框住这些矩形。</li>
</ol>
<p>我想大家都应该理解这个数据结构的特征了。用地图的例子来解释，就是所有的数据都是餐厅所对应的地点，先把相邻的餐厅划分到同一块区域，划分好所有餐厅之后，再把邻近的区域划分到更大的区域，划分完毕后再次进行更高层次的划分，直到划分到只剩下两个最大的区域为止。要查找的时候就方便了。</p>
<p>下面就可以把这些大大小小的矩形存入我们的R树中去了。根结点存放的是两个最大的矩形，这两个最大的矩形框住了所有的剩余的矩形，当然也就框住了所有的数据。下一层的结点存放了次大的矩形，这些矩形缩小了范围。每个叶子结点都是存放的最小的矩形，这些矩形中可能包含有n个数据。</p>
<p><strong>地图查找的实例</strong></p>
<p>讲完了基本的数据结构，我们来讲个实例，如何查询特定的数据。又以餐厅为例，假设我要查询广州市天河区天河城附近一公里的所有餐厅地址怎么办？</p>
<ol type="1">
<li>打开地图（也就是整个R树），先选择国内还是国外（也就是根结点）；</li>
<li>然后选择华南地区（对应第一层结点），选择广州市（对应第二层结点），</li>
<li>再选择天河区（对应第三层结点）；</li>
<li>最后选择天河城所在的那个区域（对应叶子结点，存放有最小矩形）；</li>
</ol>
<p>遍历所有在此区域内的结点，看是否满足我们的要求即可。怎么样，其实R树的查找规则跟查地图很像吧？对应下图：</p>
<figure>
<img src="../images/36~37/37.4.jpg" />
</figure>
<p><strong>一棵R树满足如下的性质：</strong></p>
<ol type="1">
<li>除非它是根结点之外，所有叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。</li>
<li>对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。</li>
<li>每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。</li>
<li>对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。</li>
<li>所有叶子结点都位于同一层，因此R树为平衡树。</li>
</ol>
<p><strong>叶子结点的结构</strong></p>
<p>先来探究一下叶子结点的结构。叶子结点所保存的数据形式为：(I, tuple-identifier)。</p>
<p>其中，tuple-identifier表示的是一个存放于数据库中的tuple，也就是一条记录，它是n维的。I是一个n维空间的矩形，并可以恰好框住这个叶子结点中所有记录代表的n维空间中的点。I=(I0,I1,…,In-1)。其结构如下图所示：</p>
<figure>
<img src="../images/36~37/37.5.jpg" />
</figure>
<p>下图描述的就是在二维空间中的叶子结点所要存储的信息。</p>
<figure>
<img src="../images/36~37/37.6.jpg" />
</figure>
<p>在这张图中，I所代表的就是图中的矩形，其范围是a&lt;=I0&lt;=b，c&lt;=I1&lt;=d。有两个tuple-identifier，在图中即表示为那两个点。这种形式完全可以推广到高维空间。大家简单想想三维空间中的样子就可以了。这样，叶子结点的结构就介绍完了。</p>
<p><strong>非叶子结点</strong></p>
<p>非叶子结点的结构其实与叶子结点非常类似。想象一下B树就知道了，B树的叶子结点存放的是真实存在的数据，而非叶子结点存放的是这些数据的“边界”，或者说也算是一种索引（有疑问的读者可以回顾一下上述第一节中讲解B树的部分）。</p>
<p>同样道理，R树的非叶子结点存放的数据结构为：(I, child-pointer)。</p>
<p>其中，child-pointer是指向孩子结点的指针，I是覆盖所有孩子结点对应矩形的矩形。这边有点拗口，但我想不是很难懂？给张图：</p>
<figure>
<img src="../images/36~37/37.7.jpg" />
</figure>
<p>D,E,F,G为孩子结点所对应的矩形。A为能够覆盖这些矩形的更大的矩形。这个A就是这个非叶子结点所对应的矩形。这时候你应该悟到了吧？无论是叶子结点还是非叶子结点，它们都对应着一个矩形。树形结构上层的结点所对应的矩形能够完全覆盖它的孩子结点所对应的矩形。根结点也唯一对应一个矩形，而这个矩形是可以覆盖所有我们拥有的数据信息在空间中代表的点的。</p>
<p>我个人感觉这张图画的不那么精确，应该是矩形A要恰好覆盖D,E,F,G，而不应该再留出这么多没用的空间了。但为尊重原图的绘制者，特不作修改。</p>
<p>但R树有些什么问题呢？如@宋枭_CD所说：“单纯用R树来作索引，搜索附近的地点，可能会遍历树的很多个分支。而且当全国的地图或者全省的地图时候，树的叶节点数目很多，树的深度也会是一个问题。一般会把地理位置上附近的节点（二维地图中点线面）预处理成page(大小为4K的倍数)，在这些page上建立R树的索引。”</p>
<h3 id="解法二geohash算法索引地理位置信息">解法二、GeoHash算法索引地理位置信息</h3>
<p>我在微博上跟一些朋友讨论这个附近点搜索的问题时，除了谈到R树，有几个朋友都指出GeoHash算法可以解决，故才了解了下GeoHash算法，<a href="http://blog.nosqlfan.com/html/1811.html">此文</a> 清晰阐述了MongoDB借助GeoHash算法实现地理位置索引的原理，特引用其内容加以说明，如下：</p>
<p>支持地理位置索引是MongoDB的一大亮点，这也是全球最流行的LBS服务foursquare 选择MongoDB的原因之一。我们知道，通常的数据库索引结构是B+ Tree，如何将地理位置转化为可建立B+Tree的形式。首先假设我们将需要索引的整个地图分成16×16的方格，如下图（左下角为坐标0,0 右上角为坐标16,16）：</p>
<figure>
<img src="../images/36~37/37.8.png" />
</figure>
<p>单纯的［x，y］的数据是无法建立索引的，所以MongoDB在建立索引的时候，会根据相应字段的坐标计算一个可以用来做索引的hash值，这个值叫做geohash，下面我们以地图上坐标为［4，6］的点（图中红叉位置）为例。我们第一步将整个地图分成等大小的四块，如下图：</p>
<figure>
<img src="../images/36~37/37.9.png" />
</figure>
<p>划分成四块后我们可以定义这四块的值，如下（左下为00，左上为01，右下为10，右上为11）：</p>
<figure>
<img src="../images/36~37/37.10.jpg" />
</figure>
<p>这样［4，6］点的geohash值目前为 00然后再将四个小块每一块进行切割，如下：</p>
<figure>
<img src="../images/36~37/37.11.png" />
</figure>
<p>这时［4，6］点位于右上区域，右上的值为11，这样［4，6］点的geohash值变为：0011继续往下做两次切分：</p>
<figure>
<img src="../images/36~37/37.12.png" />
</figure>
<figure>
<img src="../images/36~37/37.13.png" />
</figure>
<p>最终得到［4，6］点的geohash值为：00110100</p>
<p>这样我们用这个值来做索引，则地图上点相近的点就可以转化成有相同前缀的geohash值了。</p>
<p>我们可以看到，这个geohash值的精确度是与划分地图的次数成正比的，上例对地图划分了四次。而MongoDB默认是进行26次划分，这个值在建立索引时是可控的。具体建立二维地理位置索引的命令如下：</p>
<p>db.map.ensureIndex({point : &quot;2d&quot;}, {min : 0, max : 16, bits : 4})</p>
<p>其中的bits参数就是划分几次，默认为26次。</p>
<p>读者点评@yuotulck：首先多谢博主的文章，不过如果是新手（例如我）看到geohash那里可能会有误解：是否相邻可以靠前缀来比较？其实这是错的，例如边界那一块的相邻区域编码的前缀从第一个就不一样了，也就是说在geohash里相近的点hash值不一定相近。</p>
<p>上面的知识点了解自<a href="http://www.cnblogs.com/step1/archive/2009/04/22/1441689.html">这篇文章</a>，而geohash的进一步用法在<a href="http://tech.idv2.com/2011/07/05/geohash-intro/">这里</a>可以了解到。</p>
<p>本章完。</p>
<h2 id="参考链接及推荐阅读-2">参考链接及推荐阅读</h2>
<ol type="1">
<li><a href="http://blog.csdn.net/v_july_v/article/details/7974418">2012年九月十月笔试面试八十题</a>；</li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6897097">从Trie树（字典树）谈到后缀树</a>；</li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/7382693">教你如何迅速秒杀掉：99%的海量数据处理面试题</a>；</li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6530142">从B树、B+树、B*树谈到R树</a>；</li>
<li><a href="http://blog.nosqlfan.com/html/1811.html">图解 MongoDB 地理位置索引的实现原理</a>；</li>
<li>《Hbase实战》第8章、在HBase上查询地理信息系统；</li>
</ol>
<h1 id="第三十八章hero在线编程判题出题系统的演进与优化">第三十八章：Hero在线编程判题、出题系统的演进与优化</h1>
<h2 id="前言-5">前言</h2>
<p>以前出门在外玩的时候，经常跑去网吧，去网吧也不干啥事，看看博客，改改博客，但若想修改博客上的一段代码，却发觉网吧没有装编译器这个东西，可一想到安装它需要不少时间，所以每次想在网吧写代码都作罢。</p>
<p>当时，便想，如果某一天打开浏览器，便能在网页上直接敲代码，那该有多好，随时随地，不受编译器限制。好事多磨，今年3月终于来CSDN来做这样一个在线编程网站Hero了：<a href="http://hero.csdn.net">http://hero.csdn.net</a>，以项目负责人的身份总体负责它的产品和运营、包括出题。</p>
<p>为何要写此文？本文不谈Hero如何实现，也不谈今年3月至今，它的PV涨了多少倍，不谈每一道题的具体解法、思路、代码是怎样的（日后可能会写），更不谈它的界面是如何一步步优化的，只谈谈它的判题系统、出题系统是如何一步步演进和优化的，即它背后是怎样的一种判题机制（用来判断每天几千个用户提交的程序正确与否），以及如何做到让每一个用户都可以来Hero上出题的。</p>
<p>顺便对很多朋友询问“Hero后台到底是怎样判题的，为何我的程序提交出错？”的一个集中回答，把判题机制开放出来，对每一个Hero的用户做到公平公正。最后年终将至，也算是对自己近一年工作的部分回顾与总结。</p>
<p>OK，本文有何问题，欢迎随时指正，对Hero有任何改进或建议，欢迎随时向我反馈，thanks。</p>
<h2 id="一最初的人工肉眼判题">一、最初的人工肉眼判题</h2>
<p>Hero从头至尾的实现没有借用过任何开源工具，所以它的每一步探索都显得进展缓慢、推动艰难。在今年3月份之前，在Hero上玩的人不多，所以我刚来公司时，是完全人工肉眼去看每一个用户的程序思路是否正确，不确定的便得自己复制用户的代码粘贴到编译器里进行编译，看结果是否正常。也就是说如果我出一道题：求N个字符的全排列。系统后台只做一件事情，就是把用户的代码简单保存起来。</p>
<p>但打开许多用户的答案后，才发觉他并没有实现全排列，他只是写了一个“hello world”：</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> HelloWorld   
{   
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String args[])   
    {  
        System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Hello World&quot;</span>);  
    }   
}   </code></pre>
<p>即用户的程序是否正确，我得人工判断。这样的人工判题持续了整整一个月，后来发觉来Hero上玩的人越来越多，每天从之前只看几份代码到需要看几百份代码，我便立马觉得不对劲了。</p>
<p>是的，必须得让机器实现自动判题。</p>
<h2 id="二写测试代码让机器自动判题">二、写测试代码让机器自动判题</h2>
<h3 id="简单粗暴的一系列if-else判断">2.1、简单粗暴的一系列if else判断</h3>
<p>怎么让机器实现自动判题呢？其实原理也挺简单，可以在出题时写一段测试代码，然后用这段包含了很多组测试数据的测试代码去验证用户的程序是否正确。</p>
<p>比如现在有一道题是这样子的：</p>
<p>“最长有效括号的长度：给定只包含括号字符'('和 ')'的字符串，请找出最长的有效括号内子括号的长度。</p>
<p>举几个例子如下：</p>
<p>例如对于&quot;( ()&quot;，最长的有效的括号中的子字符串是&quot;()&quot; ，有效双括号数1个，故它的长度为 2。 再比如对于字符串&quot;) () () )&quot;，其中最长的有效的括号中的子字符串是&quot;() ()&quot;，有效双括号数2个，故它的长度为4。 再比如对于&quot;( () () )&quot;，它的长度为6。</p>
<p>换言之，便是有效双括号&quot;()&quot;数的两倍。</p>
<p>给定函数原型<code>int longestValidParentheses(string s)</code>，</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">class</span> Solution
{
  <span class="kw">public</span>:
    <span class="dt">int</span> longestValidParentheses(string s) {
        <span class="co">// Start typing your C/C++ solution below</span>
        <span class="co">// DO NOT write int main() function</span>
       <span class="co">//....</span>
        <span class="kw">return</span> length;
    }
};
<span class="co">//start 提示：自动阅卷起始唯一标识，请勿删除或增加。</span>
<span class="dt">int</span> main()
{    
    <span class="co">//write your code</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}
<span class="co">//end //提示：自动阅卷结束唯一标识，请勿删除或增加。        </span>
请完成此函数，实现题目所要求的功能。”
    如此，我可能会写这样一段测试代码来验证每一个用户的程序是否正确，如下：
<span class="co">//start 提示：自动阅卷起始唯一标识，请勿删除或增加。  </span>
<span class="dt">int</span> main()  
{      
    <span class="dt">char</span>* la =<span class="st">&quot;&quot;</span>;  
    <span class="dt">char</span>* b =    <span class="st">&quot;(&quot;</span>;      
    <span class="dt">char</span>* c =    <span class="st">&quot;)&quot;</span>    ;  
    <span class="dt">char</span>* d =    <span class="st">&quot;)(&quot;</span>;      
  
    <span class="dt">char</span>* e =    <span class="st">&quot;()&quot;</span>;      
    <span class="dt">char</span>* f =     <span class="st">&quot;(()&quot;</span>;      
    <span class="dt">char</span>* g =    <span class="st">&quot;())&quot;</span>;      
  
    <span class="dt">char</span>* h    = <span class="st">&quot;()()&quot;</span>;      
    <span class="dt">char</span>* i    = <span class="st">&quot;()(())&quot;</span>;      
    <span class="dt">char</span>* j =    <span class="st">&quot;(()()&quot;</span>;      
    <span class="dt">char</span>* k =    <span class="st">&quot;()(()&quot;</span>;      
    <span class="dt">char</span>* l =    <span class="st">&quot;(()()&quot;</span>;      
    <span class="dt">char</span>* m =    <span class="st">&quot;(()())&quot;</span>;      
    <span class="dt">char</span>* n =    <span class="st">&quot;((()))())&quot;</span>;      
    <span class="dt">char</span>* o =    <span class="st">&quot;)()())()()(&quot;</span>;      
    <span class="dt">char</span>* p =    <span class="st">&quot;)(((((()())()()))()(()))(&quot;</span>;  
  
    Solution a;  
    <span class="kw">if</span> (a.longestValidParentheses(la) == <span class="dv">0</span> &amp;&amp; a.longestValidParentheses(b) == <span class="dv">0</span> &amp;&amp; a.longestValidParentheses(c) == <span class="dv">0</span>  
        &amp;&amp; a.longestValidParentheses(d) == <span class="dv">0</span> &amp;&amp; a.longestValidParentheses(e) == <span class="dv">2</span> &amp;&amp; a.longestValidParentheses(f) == <span class="dv">2</span>  
        &amp;&amp; a.longestValidParentheses(g) == <span class="dv">2</span> &amp;&amp; a.longestValidParentheses(h) == <span class="dv">4</span> &amp;&amp; a.longestValidParentheses(i) == <span class="dv">6</span>  
        &amp;&amp; a.longestValidParentheses(j) == <span class="dv">4</span> &amp;&amp; a.longestValidParentheses(k) == <span class="dv">2</span> &amp;&amp; a.longestValidParentheses(l) == <span class="dv">4</span>  
        &amp;&amp; a.longestValidParentheses(m) == <span class="dv">6</span> &amp;&amp; a.longestValidParentheses(n) == <span class="dv">8</span> &amp;&amp; a.longestValidParentheses(o) == <span class="dv">4</span>  
        &amp;&amp; a.longestValidParentheses(p) == <span class="dv">22</span>  
        )  
    {  
        cout&lt;&lt;<span class="st">&quot;Y!&quot;</span>&lt;&lt;endl;  
    }  
    <span class="kw">else</span>  
    {  
        cout&lt;&lt;<span class="st">&quot;N!&quot;</span>&lt;&lt;endl;  
    }  
  
    <span class="kw">return</span> <span class="dv">0</span>;  
}  
<span class="co">//end //提示：自动阅卷结束唯一标识，请勿删除或增加。然后用上面那段包含测试数据的测试代码，代替用户的main函数进行判断：</span>
<span class="co">//start 提示：自动阅卷起始唯一标识，请勿删除或增加。  </span>
<span class="dt">int</span> main()  
{      
    <span class="co">//write your code  </span>
    <span class="kw">return</span> <span class="dv">0</span>;  
}  
<span class="co">//end //提示：自动阅卷结束唯一标识，请勿删除或增加。    </span></code></pre>
<p>这样，只要在出题时写好测试代码，机器便能实现自动判题了。但很快，我们发现上述这样的测试代码有两个可以优化的地方：</p>
<p>一个for循环代替一系列if else； 不用让机器跑完所有测试数据，而是只要有一组测试数据没有通过，程序立即退出，即只要机器找到用户第一组没有通过的测试数据即可。</p>
<h3 id="for循环代替if-else">2.2、for循环代替if else</h3>
<p>如上节所说，如果测试数据比较少量，还好说，但数据量一大，那么就得写很长很长一段的if else，那对coding的人来说显得非常业余。于是，针对下面这样一道题来看： “合法字符串：用n个不同的字符（编号1 - n），组成一个字符串，有如下2点要求：</p>
<ol type="1">
<li>对于编号为i 的字符，如果2 * i &gt; n，则该字符可以作为最后一个字符，但如果该字符不是作为最后一个字符的话，则该字符后面可以接任意字符；</li>
<li>对于编号为i的字符，如果2 * i &lt;= n，则该字符不可以作为最后一个字符，且该字符后面所紧接着的下一个字符的编号一定要 &gt;= 2 * i。</li>
</ol>
<p>问有多少长度为M且符合条件的字符串。</p>
<p>例如：N = 2，M = 3。则abb, bab, bbb是符合条件的字符串，剩下的均为不符合条件的字符串。 输入：n,m (2&lt;=n,m&lt;=1000000000)； 输出：满足条件的字符串的个数，由于数据很大，输出该数Mod 10^9 + 7的结果。</p>
<p>函数头部</p>
<p><code>int validstring(int n,int m) {}</code> 我们便可以写出如下的测试代码：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//start 提示：自动阅卷起始唯一标识，请勿删除或增加。  </span>
<span class="dt">int</span> main() {  
    <span class="dt">const</span> <span class="dt">int</span> n[] = {<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">66</span>,<span class="dv">123</span>,<span class="dv">31542</span><span class="co">/*因为题目还在Hero线上，故只公开一部分测试数据*/</span>};  
    <span class="dt">const</span> <span class="dt">int</span> m[] = {<span class="dv">2</span>,<span class="dv">1000000000</span>,<span class="dv">634</span>,<span class="dv">10000</span>,<span class="dv">55555535</span> <span class="co">/*只公开一部分测试数据*/</span>};  
    <span class="dt">const</span> <span class="dt">int</span> answer[] = {<span class="dv">2</span>,<span class="dv">999999994</span>,<span class="dv">171104439</span>,<span class="dv">8789556</span>,<span class="dv">605498333</span> <span class="co">/*只公开一部分测试数据*/</span>};  
    <span class="dt">int</span> i;  
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">4</span><span class="co">/*实际上i不止4组*/</span>; ++i) {  
        <span class="kw">if</span> (validstring(n[i],m[i]) != answer[i]) {  
            <span class="kw">break</span>;  
        }  
    }  
    <span class="kw">if</span> (i &gt;= <span class="dv">4</span>) {  
        puts(<span class="st">&quot;Y!&quot;</span>);  
    }  
    <span class="kw">else</span> {  
        printf(<span class="st">&quot;N!&quot;</span>);  
    }  
    <span class="kw">return</span> <span class="dv">0</span>;  
}  
<span class="co">//end //提示：自动阅卷结束唯一标识，请勿删除或增加。</span></code></pre>
<p>如此，上面这样的一段测试代码便能让机器自动判断用户提交的每一个程序是否正确。但就像你现在去做也会体会到，系统光告诉我的程序是对是错，估计还远远不够，即如果用户的程序错了，那系统得告诉他怎么错了呀？是因为超时，还是程序本身的逻辑错了。</p>
<p>于是，系统很快便反馈了用户出错的第一组数据，怎么实现的呢？很简单，只要把上面那段判断出用户的程序是错的那部分加上出错的那一组数据即可：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//start 提示：自动阅卷起始唯一标识，请勿删除或增加。  </span>
<span class="dt">int</span> main() {  
    <span class="dt">const</span> <span class="dt">int</span> n[] = {<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">66</span>,<span class="dv">123</span>,<span class="dv">31542</span><span class="co">/*因为题目还在Hero线上，故只公开一部分测试数据*/</span>};  
    <span class="dt">const</span> <span class="dt">int</span> m[] = {<span class="dv">2</span>,<span class="dv">1000000000</span>,<span class="dv">634</span>,<span class="dv">10000</span>,<span class="dv">55555535</span> <span class="co">/*只公开一部分测试数据*/</span>};  
    <span class="dt">const</span> <span class="dt">int</span> answer[] = {<span class="dv">2</span>,<span class="dv">999999994</span>,<span class="dv">171104439</span>,<span class="dv">8789556</span>,<span class="dv">605498333</span> <span class="co">/*只公开一部分测试数据*/</span>};  
    <span class="dt">int</span> i;  
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">4</span><span class="co">/*实际上i不止4组*/</span>; ++i) {  
        <span class="kw">if</span> (validstring(n[i],m[i]) != answer[i]) {  
            <span class="kw">break</span>;  
        }  
    }  
    <span class="kw">if</span> (i &gt;= <span class="dv">4</span>) {  
        puts(<span class="st">&quot;Y!&quot;</span>);  
    }  
    <span class="kw">else</span> {  
        printf(<span class="st">&quot;N!</span><span class="ch">\n</span><span class="st">%d %d</span><span class="ch">\n</span><span class="st">&quot;</span>,n[i],m[i]);  
    }  
    <span class="kw">return</span> <span class="dv">0</span>;  
}  
<span class="co">//end //提示：自动阅卷结束唯一标识，请勿删除或增加。  </span></code></pre>
<p>很快，我又发现，对于出题本身来说，构造它的完整而全面的测试数据已属不易，现在还要针对每一道题目去写一份测试代码，而且是每一种语言C、C++、Java、C#都写一遍，做一次就意识到这不对劲了。可这样一段要求为每一道题每一种编程语言的写痛苦的测试代码的过程持续了整整半年，直到今年10月份。</p>
<p>那是否可以简化写这个测试代码的工作，让系统本身变得更加智能呢？因为既然关键是测试数据的构造，那么在有了测试数据的前提下，是否只要填测试数据了，而不必再写测试代码呢？请看下面本文第3节部分。</p>
<h2 id="三出题系统本身的持续改进与优化">三、出题系统本身的持续改进与优化</h2>
<h3 id="漫长的写测试代码的过程">3.1、漫长的写测试代码的过程</h3>
<p>如上文所述，直到今年10月份，hero后台的判题机制一直都是，针对每一道题每一种语言单独写一份带main函数的测试代码，用这段测试代码替换掉用户程序里的main函数。如下图所示：右边的start end 代码 替换掉用户程序里的 start end 代码：</p>
<figure>
<img src="../images/38/38.1.jpg" />
</figure>
<p>当然，这个写测试代码的过程中，得到了好友曹鹏的鼎力相助，若不是他的支持，我也坚持不了6个月，thanks。但即便有他的帮助，这个漫长的写测试代码的过程还是令人非常煎熬。</p>
<p>此外，推动自己一定把出题的过程简化，不想写测试代码的重要原因还有一个：即正因为自己要对每一道题每一种编程语言都写一份测试代码，导致这种出题效率异常底下，这对于整个Hero系统是十分不利的。</p>
<p>因此，团队决定，把出题的接口开放，让所有人都可以来Hero上出题，此功能为：社会化出题。在Hero首页的右侧边栏，如下：</p>
<figure>
<img src="../images/38/38.2.jpg" />
</figure>
<p>这个时候，问题就来了，让自己写测试代码也就算了，虽然不轻松，但至少在曹鹏的帮助下还能应对，但怎么可以让用户也去为每一道题每一种语言写测试代码呢？然这一切只是自己的主观判断，并没有太多的实际证据支撑我的判断，于是团队决定，暂时先让社会化出题上线后再说。</p>
<h3 id="出题时只填测试数据不写测试代码">3.2、出题时只填测试数据，不写测试代码</h3>
<h4 id="出题时一个框一个框的填测试数据">3.2.1、出题时一个框一个框的填测试数据</h4>
<p>我最担心的糟糕结果还是出现了。10月初社会化出题上线，直到10月底，尽管有一些热心的朋友在没有任何奖励的情况下来Hero上出题了，但几乎没有任何人愿意写测试代码。</p>
<p>尽管我们走了不少弯路，导致整个进展的过程非常缓慢，但至少还是在一直前进。</p>
<p>得益于整个团队，在11月份的时候，出题终于不用再手写测试代码了，只需要一组一组一个框一个框的去填测试数据了。</p>
<figure>
<img src="../images/38/38.3.jpg" />
</figure>
<h4 id="出题时批量填测试数据">3.2.2、出题时批量填测试数据</h4>
<p>如果一道题目只有不到10组测试数据，那么出题时一个框一个框的去填测试数据是没什么问题的。但问题是，不存在某一道题的测试数据少于10组的情况，多的话几百组，甚至上千组，因此，我们很快发现必须支持批量填测试数据，于是到了今年12月底，出题系统改造成了如下图所示：</p>
<figure>
<img src="../images/38/38.4.jpg" />
</figure>
<p>####.3.3、后续的改进、优化</p>
<p>当然，直到现在，出题系统还有很多需要改进、优化的地方，如需支持数组，支持多行输入对应多行输出，直到最终的完全OJ模式，这些请待本文后续更新。团队还有很多事情要做，但我们一直在努力，在整个团队的推动下，Hero也一直在前进，从未退步。</p>
<p><strong>相关链接</strong></p>
<ul>
<li>Hero在线编程网站：http://hero.csdn.net/</li>
<li>本文2.1节问题的在线挑战地址：http://hero.csdn.net/Question/Details?ID=54&amp;ExamID=52</li>
<li>本文2.2节问题的在线编程地址：http://hero.csdn.net/Question/Details?ID=74&amp;ExamID=72</li>
</ul>
</body>
</html>
