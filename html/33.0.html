<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title></title><link rel="stylesheet" href="style_cache/github-ce7ab9b7dbd81fa8f2eeff348bc97553a3eaf80c.css" />
  <link rel="stylesheet" href="style_cache/github2-729e3ebdf8b0ec6ed54532c398dc8bd48d25ea1f.css" />
  <style>
    .file-box {
      margin: 64px auto;
      width: 920px;
    }
	body {
		font-size: 14px;
		line-height: 22px;
		<!--font-family: "adelle",Georgia,"Times New Roman",serif;-->
		color: #4e443c;
		background: #f0efe7;
	}

	.book-toc {

	}
	a {
		color: #0388a6;
		text-decoration: none;
	}
	a:hover {
		color: #04b1d8;
		text-decoration: none;
	}
	ol.book-toc li.chapter{
		margin-bottom:0.6em
	}
	ol.book-toc, ol{
		list-style-type: disc
	}
	ol.book-toc{
		margin:30px 36px
	}
	ol.book-toc a{
		padding-left:4px
	}
	li {
		line-height: 22px;
	}
	h1, h2, h3, h4, h5, h6, li, p, a, ol, div{
		margin: 0;
		padding: 0;
		border: 0;
		vertical-align: baseline;
	}
	ul, ol {
		padding: 0;
		margin: 0 0 11px 25px;
	}
	h1 {
		font-size: 36px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	h2 {
		font-size: 18px;
		color: #f14e32;
		font-weight: bold;
	}
	h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h1{
		font-size: 22px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	ol.book-toc h2 {
		font-size: 16px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	p {
		margin: 0 0 11px;
		font-size: 14px;
		line-height: 22px;
	}
	div {
		display: block;
	}
	div#nav{
		padding: 30px
	}
  </style>
</head>
<body>
  <div class="page">
    <div class="file-box">
	<div class="file">
		<div id="readme" class="blob instapaper_body announce md">
		  <article class="markdown-body entry-content" itemprop="mainContentOfPage">
			<h1>
<a name="%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E7%AB%A0%E6%9C%A8%E5%9D%97%E7%A0%8C%E5%A2%99" class="anchor" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E7%AB%A0%E6%9C%A8%E5%9D%97%E7%A0%8C%E5%A2%99"><span class="octicon octicon-link"></span></a>第三十三章：木块砌墙</h1>

<p>作者：July、caopengcs、红色标记。致谢：fuwutu、demo。</p>

<p>时间：二零一三年八月十二日</p>

<p><strong>题目</strong>：用 1×1×1, 1× 2×1以及2×1×1的三种木块（横绿竖蓝，且绿蓝长度均为2），</p>

<p><a href="../images/32%7E33/33.1.png" target="_blank"><img src="../images/32%7E33/33.1.png" alt="" style="max-width:100%;"></a></p>

<p>搭建高长宽分别为K × 2^N × 1的墙，不能翻转、旋转（其中，0&lt;=N&lt;=1024，1&lt;=K&lt;=4）</p>

<p><a href="../images/32%7E33/33.2.png" target="_blank"><img src="../images/32%7E33/33.2.png" alt="" style="max-width:100%;"></a></p>

<p>有多少种方案，输出结果</p>

<p>对1000000007取模。</p>

<p>举个例子如给定高度和长度：N=1 K=2，则答案是7，即有7种搭法，如下图所示：</p>

<p><a href="../images/32%7E33/33.3.png" target="_blank"><img src="../images/32%7E33/33.3.png" alt="" style="max-width:100%;"></a></p>

<p><strong>详解</strong>：此题很有意思，涉及的知识点也比较多，包括动态规划，快速矩阵幂，状态压缩，排列组合等等都一一考察了个遍。而且跟一个比较经典的矩阵乘法问题类似：即用1 x 2的多米诺骨牌填满M x N的矩形有多少种方案，M&lt;=5，N&lt;2^31，输出答案mod p的结果</p>

<p><a href="../images/32%7E33/33.4.gif" target="_blank"><img src="../images/32%7E33/33.4.gif" alt="" style="max-width:100%;"></a></p>

<p>OK，回到正题。下文使用的图示说明(所有看到的都是横切面)：</p>

<p><a href="../images/32%7E33/33.5.jpg" target="_blank"><img src="../images/32%7E33/33.5.jpg" alt="" style="max-width:100%;"></a></p>

<p>首先说明“？方块”的作用</p>

<p><a href="../images/32%7E33/33.6.jpg" target="_blank"><img src="../images/32%7E33/33.6.jpg" alt="" style="max-width:100%;"></a></p>

<p>“？方块”，表示这个位置是空位置，可以任意摆放。</p>

<p>上图的意思就是，当右上角被绿色木块占用，此位置固定不变，其他位置任意摆放，在这种情况下的堆放方案数。</p>

<h3>
<a name="%E8%A7%A3%E6%B3%95%E4%B8%80%E7%A9%B7%E4%B8%BE%E9%81%8D%E5%8E%86" class="anchor" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%E7%A9%B7%E4%B8%BE%E9%81%8D%E5%8E%86"><span class="octicon octicon-link"></span></a>解法一、穷举遍历</h3>

<p>初看此题，你可能最先想到的思路便是穷举：用二维数组模拟墙，从左下角开始摆放，从左往右，从下往上，最后一个格子是右上角那个位置；每个格子把每种可以摆放木块都摆放一次，每堆满一次算一种用摆放方法。为了便于描述，为木块的每个格子进行编号：</p>

<p><a href="../images/32%7E33/33.7.jpg" target="_blank"><img src="../images/32%7E33/33.7.jpg" alt="" style="max-width:100%;"></a></p>

<p>下面演示当n=1,k=2的算法过程（7种情况）：</p>

<p><a href="../images/32%7E33/33.8.jpg" target="_blank"><img src="../images/32%7E33/33.8.jpg" alt="" style="max-width:100%;"></a></p>

<p>穷举遍历在数据规模比较小的情况下还撑得住，但在0&lt;=N&lt;=1024这样的数据规模下，此方法则立刻变得有心无力，因此我们得寻找更优化的解法。</p>

<h3>
<a name="%E8%A7%A3%E6%B3%95%E4%BA%8C%E9%80%92%E5%BD%92%E5%88%86%E8%A7%A3" class="anchor" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%E9%80%92%E5%BD%92%E5%88%86%E8%A7%A3"><span class="octicon octicon-link"></span></a>解法二、递归分解</h3>

<p>递归求解就是把一个大问题，分解成小问题，逐个求解，然后再解决大问题。</p>

<h4>
<a name="21%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA" class="anchor" href="#21%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA"><span class="octicon octicon-link"></span></a>2.1、算法演示</h4>

<p>假如有墙规模为(n,k)，如果从中间切开，被分为规模问(n-1,k)的两堵墙，那么被分开的墙和原墙有什么关系呢？我们首先来看一下几组演示。</p>

<h5>
<a name="211n1k2%E7%9A%84%E6%83%85%E5%86%B5" class="anchor" href="#211n1k2%E7%9A%84%E6%83%85%E5%86%B5"><span class="octicon octicon-link"></span></a>2.1.1、n=1，k=2的情况</h5>

<p>首先演示，<strong>n=1,k=2</strong>时的情况，如下图2-1：</p>

<p><a href="../images/32%7E33/33.9.jpg" target="_blank"><img src="../images/32%7E33/33.9.jpg" alt="" style="max-width:100%;"></a></p>

<p>图 2-1</p>

<p>上图2-1中：</p>

<p><a href="../images/32%7E33/33.10.jpg" target="_blank"><img src="../images/32%7E33/33.10.jpg" alt="" style="max-width:100%;"></a>
表示，左边墙的所有堆放方案数 * 右边墙所有堆放方案数 = 2 * 2 = 4</p>

<p><a href="../images/32%7E33/33.11.jpg" target="_blank"><img src="../images/32%7E33/33.11.jpg" alt="" style="max-width:100%;"></a>
表示，当切开处有一个横条的时候，空位置存在的堆放方案数。左边<em>右边 = 1</em>1 = 2；剩余两组以此类推。</p>

<p>这个是排列组合的知识。</p>

<h5>
<a name="212n2k3%E7%9A%84%E6%83%85%E5%86%B5" class="anchor" href="#212n2k3%E7%9A%84%E6%83%85%E5%86%B5"><span class="octicon octicon-link"></span></a>2.1.2、n=2，k=3的情况</h5>

<p>其次，我们再来演示下面更具一般性的计算分解，即当<strong>n=2,k=3</strong>的情况，如下图2-2：</p>

<p><a href="../images/32%7E33/33.12.jpg" target="_blank"><img src="../images/32%7E33/33.12.jpg" alt="" style="max-width:100%;"></a></p>

<p>图 2-2</p>

<p>再从分解的结果中，挑选一组进行分解演示：</p>

<p><a href="../images/32%7E33/33.13.jpg" target="_blank"><img src="../images/32%7E33/33.13.jpg" alt="" style="max-width:100%;"></a></p>

<p>图 2-3</p>

<p>通过图2-2和图2-3的分解演示，可以说明，最终都是分解成一列求解。在逐级向上汇总。</p>

<h5>
<a name="213n4k3%E7%9A%84%E6%83%85%E5%86%B5" class="anchor" href="#213n4k3%E7%9A%84%E6%83%85%E5%86%B5"><span class="octicon octicon-link"></span></a>2.1.3、n=4，k=3的情况</h5>

<p>我们再假设一堵墙n=4，k=3，也就是说，宽度是16，高度是3时，会有以下分解：</p>

<p><a href="../images/32%7E33/33.14.jpg" target="_blank"><img src="../images/32%7E33/33.14.jpg" alt="" style="max-width:100%;"></a></p>

<p>图2-4</p>

<p>根据上面的分解的一个中间结果，再进行分解，如下：</p>

<p><a href="../images/32%7E33/33.15.jpg" target="_blank"><img src="../images/32%7E33/33.15.jpg" alt="" style="max-width:100%;"></a></p>

<p>图2-5</p>

<p>通过上面图2-1~图2-5的演示可以明确如下几点：</p>

<p>1.假设f(n)用于计算问题，那么f(n)依赖于f(n-1)的多种情况。</p>

<p>2.切开处有什么特殊的地方呢？通过上面的演示，我们得知被切开的两堵墙从没有互相嵌入的木块（绿色木块）到全是互相连接的木块，相当于切口绿色木块的全排列（即有绿色或者没有绿色的所有排列），即有2^k种状态（比如k=2，且有绿色用1表示，没有绿色用0表示，那么就有00、01、10、11这4种状态）。根据排列组合的性质，把每一种状态下左右木墙堆放方案数相乘，再把所有乘积求和，就得到木墙的堆放结果数。以此类推，将问题逐步往下分解即可。</p>

<p>3.此外，从图2-5中可以看出，除了需要考虑切口绿色木块的状态，还需要考虑最左边一列和最右边一列的绿色木块状态。我们把这两种边界状态称为左边界状态和右边界状态，分别用leftState和rightState表示。 </p>

<p>且在观察图2-5被切分后，所有左边的墙，他们的左边界ls状态始终保持不变，右边界rs状态从0~maxState, maxState = 2^k-1（有绿色方块表示1，没有表示0；ls表示左边界状态，rs表示右边状态）：</p>

<p><a href="../images/32%7E33/33.16.jpg" target="_blank"><img src="../images/32%7E33/33.16.jpg" alt="" style="max-width:100%;"></a></p>

<p>图2-6</p>

<p>同样可以看出右边的墙的右边界状态保持不变，而左边界状态从0~maxState。要堆砌的木墙可以看做是左边界状态=0，和右边界状态=0的一堵墙。</p>

<p>有一点可能要特别说明下，即上文中说，有绿色方块的状态表示标为1，无绿色方块的状态表示标为0，特意又拿上图2-6标记了一些数字，以让绝大部分读者能看得一目了然，如下所示：</p>

<p><a href="../images/32%7E33/33.17.jpg" target="_blank"><img src="../images/32%7E33/33.17.jpg" alt="" style="max-width:100%;"></a></p>

<p>图2-7</p>

<p>这下，你应该很清楚的看到，在上图中，左边木块的状态表示一律为010，右边木块的状态表示则是000~111（即从下至上开始计数，右边木块rs的状态用二进制表示为：000 001 010 011 100 101 110 111，它们各自分别对应整数则是：0 1 2 3 4 5 6 7）。</p>

<h4>
<a name="22%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F" class="anchor" href="#22%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F"><span class="octicon octicon-link"></span></a>2.2、计算公式</h4>

<p>通过图2-4、图2-5、图2-6的分解过程，我们可以总结出下面公式（leftState=最左边边界状态，rightState=最右边边界状态）：</p>

<p><a href="../images/32%7E33/33.18.jpg" target="_blank"><img src="../images/32%7E33/33.18.jpg" alt="" style="max-width:100%;"></a></p>

<p>即：</p>

<p><a href="../images/32%7E33/33.19.jpg" target="_blank"><img src="../images/32%7E33/33.19.jpg" alt="" style="max-width:100%;"></a></p>

<p>接下来，分3点解释下上述公式：</p>

<p><strong>1</strong>、上述函数返回结果是当左边状态为=leftState，右边状态=rightState时木墙的堆砌方案数，相当于直接分解的左右状态都为0的情况，即直接分解f(n,k,0,0)即可。看到这，读者可能便有疑问了，既然直接分解f(n,k,0,0)即可，为何还要加leftstate和leftstate两个变量呢？回顾下2.1.3节中n=4，k=3的演示例子，即当n=4，k=3时，其分解过程即如下图（上文2.1.3节中的图2-4）</p>

<p><a href="../images/32%7E33/33.20.jpg" target="_blank"><img src="../images/32%7E33/33.20.jpg" alt="" style="max-width:100%;"></a></p>

<p>也就是说，刚开始直接分解f(4,3,0,0)，即n=4，k=3，leftstate=0，rightstate=0，但分解过程中leftstate和rightstate皆从0变化到了maxstate，故才让函数的第3和第4个参数采用leftstate和rightstate这两个变量的形式，公式也就理所当然的写成了f(n,k,leftstate,rightstate)。</p>

<p><strong>2</strong>、然后我们再看下当n=4，k=3分解的一个中间结果，即给定如上图最下面部分中红色框框所框住的木块时：</p>

<p><a href="../images/32%7E33/33.21.jpg" target="_blank"><img src="../images/32%7E33/33.21.jpg" alt="" style="max-width:100%;"></a></p>

<p>它用方程表示即为 f(2,3,2,5)，怎么得来的呢？其实还是又回到了上文2.1.3节中，当n=2，k=3 时（下图即为上文2.1.3节中的图2-5和图2-6）</p>

<p><a href="../images/32%7E33/33.22.jpg" target="_blank"><img src="../images/32%7E33/33.22.jpg" alt="" style="max-width:100%;"></a></p>

<p><a href="../images/32%7E33/33.23.jpg" target="_blank"><img src="../images/32%7E33/33.23.jpg" alt="" style="max-width:100%;"></a></p>

<p>左边界ls状态始终保持不变时，右边界rs状态从0~maxState；右边界状态保持不变时，而左边界状态从0~maxState。</p>

<p>故上述分解过程用方程式可表示为：</p>

<p><strong>f(2,3,2,5)  = f(1,3,2,0) * f(1,3,0,5)</strong></p>

<p><strong>+ f(1,3,2,1) * f(1,3,1,5)</strong></p>

<p><strong>+ f(1,3,2,2) * f(1,3,2,5)</strong></p>

<p><strong>+ f(1,3,2,3) * f(1,3,3,5)</strong></p>

<p><strong>+ f(1,3,2,4) * f(1,3,4,5)</strong></p>

<p><strong>+ f(1,3,2,5) * f(1,3,5,5)</strong></p>

<p><strong>+ f(1,3,2,6) * f(1,3,6,5)</strong></p>

<p><strong>+ f(1,3,2,7) * f(1,3,7,5)</strong></p>

<p>说白了，我们曾在2.1节中从图2-2到图2-6正推推导出了公式，然上述过程中，则又再倒推推了一遍公式进行了说明。</p>

<p><strong>3</strong>、最后，作者是怎么想到引入 leftstate 和rightstate 这两个变量的呢？如红色标记所说："因为切开后，发现绿色条，在分开出不断的变化，当时也进入了死胡同，我就在想，蓝色的怎么办。后来才想明白，与蓝色无关。每一种变化就是一种状态，所以就想到了引入leftstate 和rightstate这两个变量。"</p>

<h4>
<a name="23%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81" class="anchor" href="#23%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81"><span class="octicon octicon-link"></span></a>2.3、参考代码</h4>

<p>下面代码就是根据上面函数原理编写的。最终执行效率，n=1024,k=4 时，用时0.2800160秒（之前代码用的是字典作为缓存，用时在1.3秒左右，后来改为数组结果，性能大增）。""</p>

<div class="highlight highlight-cs"><pre><span class="c1">//copyright@红色标记 12/8/2013    </span>
<span class="c1">//updated@July 13/8/2013  </span>
<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>    
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>    
<span class="k">using</span> <span class="nn">System.Text</span><span class="p">;</span>    
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>    

<span class="k">namespace</span> <span class="nn">HeapBlock</span>    
<span class="p">{</span>    
    <span class="k">public</span> <span class="k">class</span> <span class="nc">WoolWall</span>    
    <span class="p">{</span>            
        <span class="k">private</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>    
        <span class="k">private</span> <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>    
        <span class="k">private</span> <span class="kt">int</span> <span class="n">maxState</span><span class="p">;</span>    
        <span class="k">private</span> <span class="kt">int</span><span class="p">[,</span> <span class="p">,]</span> <span class="n">resultCache</span><span class="p">;</span>   <span class="c1">//结果缓存数组    </span>

        <span class="k">public</span> <span class="nf">WoolWall</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>    
        <span class="p">{</span>    
            <span class="k">this</span><span class="p">.</span><span class="n">n</span> <span class="p">=</span> <span class="n">n</span><span class="p">;</span>    
            <span class="k">this</span><span class="p">.</span><span class="n">height</span> <span class="p">=</span> <span class="n">height</span><span class="p">;</span>    
            <span class="n">maxState</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>    
            <span class="n">resultCache</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">maxState</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">maxState</span> <span class="p">+</span> <span class="m">1</span><span class="p">];</span>   <span class="c1">//构建缓存数组，每个值默认为0；    </span>
        <span class="p">}</span>    

        <span class="c1">/// &lt;summary&gt;    </span>
        <span class="c1">/// 静态入口。计算堆放方案数。    </span>
        <span class="c1">/// &lt;/summary&gt;    </span>
        <span class="c1">/// &lt;param name="n"&gt;&lt;/param&gt;    </span>
        <span class="c1">/// &lt;param name="k"&gt;&lt;/param&gt;    </span>
        <span class="c1">/// &lt;returns&gt;&lt;/returns&gt;    </span>
        <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Heap</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>    
        <span class="p">{</span>    
            <span class="k">return</span> <span class="k">new</span> <span class="nf">WoolWall</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">).</span><span class="n">Heap</span><span class="p">();</span>    
        <span class="p">}</span>    

        <span class="c1">/// &lt;summary&gt;    </span>
        <span class="c1">/// 计算堆放方案数。    </span>
        <span class="c1">/// &lt;/summary&gt;    </span>
        <span class="c1">/// &lt;returns&gt;&lt;/returns&gt;    </span>
        <span class="k">public</span> <span class="kt">int</span> <span class="nf">Heap</span><span class="p">()</span>    
        <span class="p">{</span>    
            <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Heap</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>    
        <span class="p">}</span>    

        <span class="k">private</span> <span class="kt">long</span> <span class="nf">Heap</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lState</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rState</span><span class="p">)</span>    
        <span class="p">{</span>    
            <span class="c1">//如果缓存数组中的值不为0，则表示该结果已经存在缓存中。    </span>
            <span class="c1">//直接返回缓存结果。    </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">resultCache</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">lState</span><span class="p">,</span> <span class="n">rState</span><span class="p">]</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>    
            <span class="p">{</span>    
                <span class="k">return</span> <span class="n">resultCache</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">lState</span><span class="p">,</span> <span class="n">rState</span><span class="p">];</span>    
            <span class="p">}</span>    

            <span class="c1">//在只有一列的情况，无法再进行切分    </span>
            <span class="c1">//根据列状态计算一列的堆放方案    </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>    
            <span class="p">{</span>    
                <span class="k">return</span> <span class="nf">CalcOneColumnHeapCount</span><span class="p">(</span><span class="n">lState</span><span class="p">);</span>    
            <span class="p">}</span>    

            <span class="kt">long</span> <span class="n">result</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>    
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">state</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">state</span> <span class="p">&lt;=</span> <span class="n">maxState</span><span class="p">;</span> <span class="n">state</span><span class="p">++)</span>    
            <span class="p">{</span>    
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span>    
                <span class="p">{</span>    
                    <span class="c1">//在只有两列的情况，判断当前状态在切分之后是否有效    </span>
                    <span class="k">if</span> <span class="p">(!</span><span class="n">StateIsAvailable</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">lState</span><span class="p">,</span> <span class="n">rState</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>    
                    <span class="p">{</span>    
                        <span class="k">continue</span><span class="p">;</span>    
                    <span class="p">}</span>    
                    <span class="n">result</span> <span class="p">+=</span> <span class="n">Heap</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">state</span> <span class="p">|</span> <span class="n">lState</span><span class="p">,</span> <span class="n">state</span> <span class="p">|</span> <span class="n">lState</span><span class="p">)</span>  <span class="c1">//合并状态。因为只有一列，所以lState和rState相同。    </span>
                        <span class="p">*</span> <span class="n">Heap</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">state</span> <span class="p">|</span> <span class="n">rState</span><span class="p">,</span> <span class="n">state</span> <span class="p">|</span> <span class="n">rState</span><span class="p">);</span>    
                <span class="p">}</span>    
                <span class="k">else</span>    
                <span class="p">{</span>    
                    <span class="n">result</span> <span class="p">+=</span> <span class="n">Heap</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">lState</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="p">*</span> <span class="n">Heap</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">rState</span><span class="p">);</span>     
                <span class="p">}</span>    
                <span class="n">result</span> <span class="p">%=</span> <span class="m">1000000007</span><span class="p">;</span><span class="c1">//为了防止结果溢出，根据题目要求求模。    </span>
            <span class="p">}</span>    

            <span class="n">resultCache</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">lState</span><span class="p">,</span> <span class="n">rState</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>   <span class="c1">//将结果写入缓存数组中    </span>
            <span class="n">resultCache</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">rState</span><span class="p">,</span> <span class="n">lState</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>   <span class="c1">//对称的墙结果相同，所以直接写入缓存。    </span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>    
        <span class="p">}</span>    

        <span class="c1">/// &lt;summary&gt;    </span>
        <span class="c1">/// 根据一列的状态，计算列的堆放方案数。    </span>
        <span class="c1">/// &lt;/summary&gt;    </span>
        <span class="c1">/// &lt;param name="state"&gt;状态&lt;/param&gt;    </span>
        <span class="c1">/// &lt;returns&gt;&lt;/returns&gt;    </span>
        <span class="k">private</span> <span class="kt">int</span> <span class="nf">CalcOneColumnHeapCount</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">)</span>    
        <span class="p">{</span>    
            <span class="kt">int</span> <span class="n">sn</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="c1">//连续计数    </span>
            <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>    
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>    
            <span class="p">{</span>    
                <span class="k">if</span> <span class="p">((</span><span class="n">state</span> <span class="p">&amp;</span> <span class="m">1</span><span class="p">)</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>    
                <span class="p">{</span>    
                    <span class="n">sn</span><span class="p">++;</span>    
                <span class="p">}</span>    
                <span class="k">else</span>    
                <span class="p">{</span>    
                    <span class="k">if</span> <span class="p">(</span><span class="n">sn</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>    
                    <span class="p">{</span>    
                        <span class="n">result</span> <span class="p">*=</span> <span class="n">CalcAllState</span><span class="p">(</span><span class="n">sn</span><span class="p">);</span>    
                    <span class="p">}</span>    
                    <span class="n">sn</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>    
                <span class="p">}</span>    
                <span class="n">state</span> <span class="p">&gt;&gt;=</span> <span class="m">1</span><span class="p">;</span>    
            <span class="p">}</span>    
            <span class="k">if</span> <span class="p">(</span><span class="n">sn</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>    
            <span class="p">{</span>    
                <span class="n">result</span> <span class="p">*=</span> <span class="n">CalcAllState</span><span class="p">(</span><span class="n">sn</span><span class="p">);</span>    
            <span class="p">}</span>    

            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>    
        <span class="p">}</span>    

        <span class="c1">/// &lt;summary&gt;    </span>
        <span class="c1">/// 类似于斐波那契序列。    </span>
        <span class="c1">/// f(1)=1    </span>
        <span class="c1">/// f(2)=2    </span>
        <span class="c1">/// f(n) = f(n-1)*f(n-2);    </span>
        <span class="c1">/// 只是初始值不同。    </span>
        <span class="c1">/// &lt;/summary&gt;    </span>
        <span class="c1">/// &lt;param name="k"&gt;&lt;/param&gt;    </span>
        <span class="c1">/// &lt;returns&gt;&lt;/returns&gt;    </span>
        <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">CalcAllState</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span>    
        <span class="p">{</span>    
            <span class="k">return</span> <span class="n">k</span> <span class="p">&lt;=</span> <span class="m">2</span> <span class="p">?</span> <span class="n">k</span> <span class="p">:</span> <span class="n">CalcAllState</span><span class="p">(</span><span class="n">k</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="n">CalcAllState</span><span class="p">(</span><span class="n">k</span> <span class="p">-</span> <span class="m">2</span><span class="p">);</span>    
        <span class="p">}</span>    

        <span class="c1">/// &lt;summary&gt;    </span>
        <span class="c1">/// 判断状态是否可用。    </span>
        <span class="c1">/// 当n=1时，分割之后，左墙和右边墙只有一列。    </span>
        <span class="c1">/// 所以state的状态码可能会覆盖原来的边缘状态。    </span>
        <span class="c1">/// 如果有覆盖，则该状态不可用；没有覆盖则可用。    </span>
        <span class="c1">/// 当n&gt;1时，不存在这种情况，都返回状态可用。    </span>
        <span class="c1">/// &lt;/summary&gt;    </span>
        <span class="c1">/// &lt;param name="n"&gt;&lt;/param&gt;    </span>
        <span class="c1">/// &lt;param name="lState"&gt;左边界状态&lt;/param&gt;    </span>
        <span class="c1">/// &lt;param name="rState"&gt;右边界状态&lt;/param&gt;    </span>
        <span class="c1">/// &lt;param name="state"&gt;切开位置的当前状态&lt;/param&gt;    </span>
        <span class="c1">/// &lt;returns&gt;状态有效返回 true,状态不可用返回 false&lt;/returns&gt;    </span>
        <span class="k">private</span> <span class="kt">bool</span> <span class="nf">StateIsAvailable</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lState</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rState</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>    
        <span class="p">{</span>    
            <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">)</span> <span class="p">||</span> <span class="p">((</span><span class="n">lState</span> <span class="p">|</span> <span class="n">state</span><span class="p">)</span> <span class="p">==</span> <span class="n">lState</span> <span class="p">+</span> <span class="n">state</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">rState</span> <span class="p">|</span> <span class="n">state</span><span class="p">)</span> <span class="p">==</span> <span class="n">rState</span> <span class="p">+</span> <span class="n">state</span><span class="p">);</span>    
        <span class="p">}</span>    
    <span class="p">}</span>    
<span class="p">}</span>    
</pre></div>

<p>上述程序中，</p>

<ul>
<li><p>WoolWall.Heap(1024,4); //直接通过静态方法获得结果</p></li>
<li><p>new  WoolWall(n, k).Heap();//通过构造对象获得结果</p></li>
</ul><h5>
<a name="231%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3" class="anchor" href="#231%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3"><span class="octicon octicon-link"></span></a>2.3.1、核心算法讲解</h5>

<p>因为它最终都是分解成一列的情况进行处理，这就会导致很慢。为了提高速度，本文使用了缓存机制来提高性能。缓存原理就是，n,k,leftState,rightState相同的墙，返回的结果肯定相同。利用这个特性，每计算一种结果就放入到缓存中，如果下次计算直接从缓存取出。刚开始缓存用字典类实现，有网友给出了更好的缓存方法——数组。这样性能好了很多，也更加简单。程序结构如下图所示：</p>

<p><a href="../images/32%7E33/33.24.jpg" target="_blank"><img src="../images/32%7E33/33.24.jpg" alt="" style="max-width:100%;"></a></p>

<p>上图反应了Heep调用的主要方法调用，在循环中，result 累加 lResult 和 rResult。</p>

<p>①在实际代码中，首先是从缓存中读取结果，如果没有缓存中读取结果在进行计算。 </p>

<p>分解法分解到一列时，不在分解，直接计算机过</p>

<div class="highlight highlight-cs"><pre><span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>  
<span class="p">{</span>  
     <span class="k">return</span> <span class="nf">CalcOneColumnHeap</span><span class="p">(</span><span class="n">lState</span><span class="p">);</span>  
<span class="p">}</span> 
</pre></div>

<p>②下面是整个程序的核心代码，通过for循环，求和state=0到state=2^k-1的两边木墙乘积：</p>

<div class="highlight highlight-cs"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">state</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">state</span> <span class="p">&lt;=</span> <span class="n">maxState</span><span class="p">;</span> <span class="n">state</span><span class="p">++)</span>  
<span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="k">if</span> <span class="p">(!</span><span class="n">StateIsAvailable</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">lState</span><span class="p">,</span> <span class="n">rState</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>  
        <span class="p">{</span>  
            <span class="k">continue</span><span class="p">;</span>  
        <span class="p">}</span>  
        <span class="n">result</span> <span class="p">+=</span> <span class="n">Heap</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">state</span> <span class="p">|</span> <span class="n">lState</span><span class="p">,</span> <span class="n">state</span> <span class="p">|</span> <span class="n">lState</span><span class="p">)</span> <span class="p">*</span>  
            <span class="n">Heap</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">state</span> <span class="p">|</span> <span class="n">rState</span><span class="p">,</span> <span class="n">state</span> <span class="p">|</span> <span class="n">rState</span><span class="p">);</span>  
    <span class="p">}</span>  
    <span class="k">else</span>  
    <span class="p">{</span>  
        <span class="n">result</span> <span class="p">+=</span> <span class="n">Heap</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">lState</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>  
            <span class="p">*</span> <span class="n">Heap</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">rState</span><span class="p">);</span>  
    <span class="p">}</span>  
    <span class="n">result</span> <span class="p">%=</span> <span class="m">1000000007</span><span class="p">;</span>  
<span class="p">}</span>  
</pre></div>

<p>当n=1切分时，需要特殊考虑。如下图：</p>

<p><a href="../images/32%7E33/33.25.jpg" target="_blank"><img src="../images/32%7E33/33.25.jpg" alt="" style="max-width:100%;"></a></p>

<p>图2-8</p>

<p>看上图中，因为左边墙中间被绿色方块占用，所以在（1,0）-（1,1）这个位置（位置的标记方法同解法一）不能再放绿色方块。所以一些状态需要排除，如state=2需要排除。同时在还需要合并状态，如state=1时，左边墙的状态=3。</p>

<p>特别说明下：依据我们上文2.2节中的公式，如果第i行有这种木块，state对应2^(i-1)，加上所有行的贡献就得到state（0就是没有这种横跨木块，2^k-1就是所有行都是横跨木块），然后遍历state，还记得上文中的图2-7么？</p>

<p><a href="../images/32%7E33/33.26.jpg" target="_blank"><img src="../images/32%7E33/33.26.jpg" alt="" style="max-width:100%;"></a></p>

<p>当第i行被这样的木块<a href="../images/32%7E33/33.27.jpg" target="_blank"><img src="../images/32%7E33/33.27.jpg" alt="" style="max-width:100%;"></a>或这样的木块<a href="../images/32%7E33/33.28.jpg" target="_blank"><img src="../images/32%7E33/33.28.jpg" alt="" style="max-width:100%;"></a>占据时，其各自对应的state值分别为：</p>

<p>1.当第1行被占据，state=1；</p>

<p>2.当第2行被占据，state=2；</p>

<p>3.当第1和第2行都被占据，state=3；</p>

<p>4.当第3行被占据，state=4；</p>

<p>5.当第1和第3行被占据，state=5；</p>

<p>6.当第2和第3行被占据，state=6；</p>

<p>7.当第1、2、3行全部都被占据，state=7。</p>

<p>至于原因，即如2.1.3节节末所说：二进制表示为：000 001 010 011 100 101 110 111，它们各自分别对应整数则是：0 1 2 3 4 5 6 7。</p>

<p>具体来说，下面图中所有框出来的位置，不能有绿色的：</p>

<p><a href="../images/32%7E33/33.29.jpg" target="_blank"><img src="../images/32%7E33/33.29.jpg" alt="" style="max-width:100%;"></a></p>

<p>③CalcOneColumnHeap(int state)函数用于计算一列时摆放方案数。</p>

<p>计算方法是， 求和被绿色木块分割开的每一段连续方格的摆放方案数。每一段连续的方格的摆放方案通过CalcAllState方法求得。经过分析，可以得知CalcAllState是类似斐波那契序列的函数。</p>

<p>举个例子如下（分步骤讲述）：</p>

<p>1.令state = 4546（state=2^k-1，k最大为4，故本题中state最大在15，而这里取state=4546只是为了演示如何计算），二进制是：1000111000010。位置上为1，表示被绿色木块占用，0表示空着，可以自由摆放。</p>

<p>2.1000111000010  被分割后 1  000  111  0000  1  0, 那么就有 000=3个连续位置， 0000=4个连续位置 ， 0=1个连续位置。</p>

<p>3.堆放结果=CalcAllState(3) + CalcAllState(4) + CalcAllState(1) = 3 + 5 + 1 = 9。</p>

<h4>
<a name="24%E5%86%8D%E6%AC%A1%E4%BC%98%E5%8C%96" class="anchor" href="#24%E5%86%8D%E6%AC%A1%E4%BC%98%E5%8C%96"><span class="octicon octicon-link"></span></a>2.4、再次优化</h4>

<p>上面程序因为调用性能的树形结构，形成了大量的函数调用和缓存查找，所以其性能不是很高。 为了得到更高的性能，可以让所有的运算直接依赖于上一次运算的结果，以防止更多的调用。即如果每次运算都算出所有边界状态的结果，那么就能为下一次运算提供足够的信息。后续优化请<a href="http://blog.csdn.net/dw14132124/article/details/9038417#t2">查阅此文第3节</a>。</p>

<h3>
<a name="%E8%A7%A3%E6%B3%95%E4%B8%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor" href="#%E8%A7%A3%E6%B3%95%E4%B8%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="octicon octicon-link"></span></a>解法三、动态规划</h3>

<p>相信读到上文，不少读者都已经意识到这个问题其实就是一个动态规划问题，接下来咱们换一个角度来分析此问题。</p>

<h4>
<a name="31%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%8F%AF%E8%A1%8C" class="anchor" href="#31%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%8F%AF%E8%A1%8C"><span class="octicon octicon-link"></span></a>3.1、暴力搜索不可行</h4>

<p>首先，因为木块的宽度都是1，我们可以想成2维的问题。也就是说三种木板的规格分别为1* 1, 1 * 2, 2 * 1。</p>

<p>通过上文的解法一，我们已经知道这个问题最直接的想法就是暴力搜索，即对每个空格尝试放置哪种木板。但是看看数据规模就知道，这种思路是不可行的。因为有一条边范围长度高达21024，普通的电脑，230左右就到极限了。于是我们得想想别的方法。</p>

<h4>
<a name="32%E5%8F%A6%E8%BE%9F%E8%B9%8A%E5%BE%84" class="anchor" href="#32%E5%8F%A6%E8%BE%9F%E8%B9%8A%E5%BE%84"><span class="octicon octicon-link"></span></a>3.2、另辟蹊径</h4>

<p>为了方便，我们把墙看做有2n行，k列的矩形。这是因为虽然矩形木块不能翻转，但是我们同时拥有1*2和2*1的两种木块。</p>

<p>假设我们从上到下，从左到右考虑每个1*1的格子是如何被覆盖的。显然，我们每个格子都要被覆盖住。木块的特点决定了我们覆盖一个格子最多只会影响到下一行的格子。这就可以让我们暂时只考虑两行。</p>

<p>假设现我们已经完全覆盖了前(i– 1)行。那么由于覆盖前(i-1)行导致第i行也不“完整”了。如下图：</p>

<p>xxxxxxxxx</p>

<p>ooxooxoxo</p>

<p>我们用x表示已经覆盖的格子，o表示没覆盖的格子。为了方便，我们使用9列。</p>

<p>我们考虑第i行的状态，上图中，第1列我们可以用1*1的覆盖掉，也可以用1*2的覆盖前两列。第4、5列的覆盖方式和第1、2列是同样的情况。第7列需要覆盖也有两种方式，即用1*1的覆盖或者用2*1的覆盖，但是这样会导致第（i+1)行第7列也被覆盖。第9列和第7列的情况是一样的。这样把第i行覆盖满了之后，我们再根据第(i+1)行被影响的状态对下一行进行覆盖。</p>

<p>那么每行有多少种状态呢？显然有2k，由于k很小，我们只有大约16种状态。如果我们对于这些状态之间的转换制作一个矩阵，矩阵的第i行第j列的数表示的是我们第m行是状态i，我们把它完整覆盖掉，并且使得第(m + 1)行变成状态j的可能的方法数，这个矩阵我们可以暴力搜索出来，搜索的方式就是枚举第m行的状态，然后尝试放木板，用所有的方法把第m行覆盖掉之后，下一行的状态。当然，我们也可以认为只有两行，并且第一行是2k种状态的一种，第二行起初是空白的，求使得第一行完全覆盖掉，第二行的状态有多少种类型以及每种出现多少次。</p>

<h4>
<a name="33%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor" href="#33%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="octicon octicon-link"></span></a>3.3、动态规划</h4>

<p>这个矩阵作用很大，其实我们覆盖的过程可以认为是这样：第一行是空的，我们看看把它覆盖了，第2行是什么样子的。根据第二行的状态，我们把它覆盖掉，看看第3行是什么样子的。</p>

<p>如果我们知道第i行的状态为s,怎么考虑第i行完全覆盖后，第(i+1)行的状态？那只要看那个矩阵的状态s对应的行就可以了。我们可以考虑一下，把两个这样的方阵相乘得到得结果是什么。这个方阵的第i行第j个元素是这样得到的，是第i行第k个元素与第k行第j个元素的对k的叠加。它的意义是上一行是第m行是状态i，把第m行和第(m+ 1)行同时覆盖住，第(m+2)行的状态是j的方法数。这是因为中间第(m+1)行的所有状态k，我们已经完全遍历了。</p>

<p>于是我们发现，每做一次方阵的乘法，我们相当于把状态推动了一行。那么我们要坐多少次方阵乘法呢？就是题目中墙的长度2<sup>n</sup>,这个数太大了。但是事实上，我们可以不断地平方n次。也就是说我们可以算出A<sup>2</sup>,A<sup>4</sup>, A<sup>8</sup>, A<sup>16</sup>……方法就是不断用结果和自己相乘，这样乘n次就可以了。</p>

<p>因此，我们最关键的问题就是建立矩阵A。我们可以这样表示一行的状态，从左到右分别叫做第0列，第1列……覆盖了我们认为是1，没覆盖我们认为是0，这样一行的状态可以表示维一个整数。某一列的状态我们可以用为运算来表示。例如，状态x第i列是否被覆盖，我们只需要判断x &amp; (1 &lt;&lt; i) 是否非0即可，或者判断(x &gt;&gt; i) &amp; 1， 用右移位的目的是防止溢出，但是本题不需要考虑溢出，因为k很小。 接下来的任务就是递归尝试放置方案了</p>

<h4>
<a name="34%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81" class="anchor" href="#34%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81"><span class="octicon octicon-link"></span></a>3.4、参考代码</h4>

<p>最终结果，我们最初的行是空得，要求最后一行之后也不能被覆盖，所以最终结果是矩阵的第[0][0]位置的元素。另外，本题在乘法过程中会超出32位int的表示范围，需要临时用C/C++的long long，或者java的long。</p>

<p>参考代码如下：</p>

<div class="highlight highlight-c"><pre><span class="c1">//copyright@caopengcs 12/08/2013  </span>
<span class="cp">#ifdef WIN32  </span>
<span class="cp">#define ll __int64   </span>
<span class="cp">#else  </span>
<span class="cp">#define ll long long  </span>
<span class="cp">#endif  </span>

<span class="c1">// 1 covered 0 uncovered  </span>

<span class="kt">void</span> <span class="nf">cal</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">32</span><span class="p">][</span><span class="mi">32</span><span class="p">],</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">col</span><span class="p">,</span><span class="kt">int</span> <span class="n">laststate</span><span class="p">,</span><span class="kt">int</span> <span class="n">nowstate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">++</span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">laststate</span><span class="p">][</span><span class="n">nowstate</span><span class="p">];</span>  
        <span class="k">return</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="c1">//不填 或者用1*1的填  </span>
    <span class="n">cal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">laststate</span><span class="p">,</span> <span class="n">nowstate</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(((</span><span class="n">laststate</span> <span class="o">&gt;&gt;</span> <span class="n">col</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">laststate</span><span class="p">,</span> <span class="n">nowstate</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">col</span><span class="p">));</span>  
        <span class="k">if</span> <span class="p">((</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(((</span><span class="n">laststate</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">cal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">laststate</span><span class="p">,</span> <span class="n">nowstate</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">}</span>  

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mul</span><span class="p">(</span><span class="n">ll</span> <span class="n">x</span><span class="p">,</span> <span class="n">ll</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">%</span> <span class="mi">1000000007</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="kt">void</span> <span class="nf">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">a</span><span class="p">[][</span><span class="mi">32</span><span class="p">],</span><span class="kt">int</span> <span class="n">b</span><span class="p">[][</span><span class="mi">32</span><span class="p">])</span>
<span class="p">{</span> <span class="c1">// b = a * a</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>  
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]))</span> <span class="o">&gt;=</span> <span class="mi">1000000007</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1000000007</span><span class="p">;</span>
                <span class="p">}</span>  
            <span class="p">}</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">}</span>  

<span class="kt">int</span> <span class="nf">calculate</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">32</span><span class="p">][</span><span class="mi">32</span><span class="p">],</span><span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">32</span><span class="p">][</span><span class="mi">32</span><span class="p">];</span>  
    <span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>  
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="n">memcpy</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>  
    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">);</span>  
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="p">;</span> <span class="o">--</span><span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">multiply</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]);</span>  
        <span class="n">i</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>  
<span class="p">}</span>  
</pre></div>

<h2>
<a name="%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5%E5%8F%8A%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB" class="anchor" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5%E5%8F%8A%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="octicon octicon-link"></span></a>参考链接及推荐阅读</h2>

<ol>
<li>caopengcs，<a href="http://blog.csdn.net/caopengcs/article/details/9928061">木块砌墙</a>
</li>
<li>红色标记，<a href="http://blog.csdn.net/dw14132124/article/details/9038417">木块砌墙</a>
</li>
<li>LoveHarvy，<a href="http://blog.csdn.net/wangyan_boy/article/details/9131501">木块砌墙</a>
</li>
<li><a href="http://hero.pongo.cn/Question/Details?ID=36&amp;ExamID=36">在线编译测试木块砌墙问题</a></li>
<li>hero上<a href="http://hero.pongo.cn/Question/Details?ExamID=36&amp;ID=36&amp;bsh_bid=273040296">木块砌墙一题</a>
</li>
</ol>
		  </article>
		  
			<div id="nav">
				
					<a href="32.0.html">prev</a>
					|
				
				
					<a href="34-35.0.html">next</a>
				
				<span style="float: right"><a href="index.html">Back to home</a>
			</div>
		  
		</div>
	</div>
  </div>
  
  <div>&nbsp;</div>
  </div>
  <div style="text-align:center; margin-bottom: 30px">
	  Generated by <a href="https://github.com/marchtea/md_to_github_html">mdtogh</a>
  </div>
</body>
</html>