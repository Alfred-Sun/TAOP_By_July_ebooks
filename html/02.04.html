<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title></title><link rel="stylesheet" href="style_cache/github-6fc7fb2a2ad956975983882a7f95b27577e851a4.css" />
  <link rel="stylesheet" href="style_cache/github2-ade82cf93cc23c0e2691785e7976cc718fe1986f.css" />
  <style>
    .file-box {
      margin: 64px auto;
      width: 920px;
    }
	body {
		font-size: 14px;
		line-height: 22px;
		<!--font-family: "adelle",Georgia,"Times New Roman",serif;-->
		color: #4e443c;
		background: #f0efe7;
	}

	.book-toc {

	}
	a {
		color: #0388a6;
		text-decoration: none;
	}
	a:hover {
		color: #04b1d8;
		text-decoration: none;
	}
	ol.book-toc li.chapter{
		margin-bottom:0.6em
	}
	ol.book-toc, ol{
		list-style-type: disc
	}
	ol.book-toc{
		margin:30px 36px
	}
	ol.book-toc a{
		padding-left:4px
	}
	li {
		line-height: 22px;
	}
	h1, h2, h3, h4, h5, h6, li, p, a, ol, div{
		margin: 0;
		padding: 0;
		border: 0;
		vertical-align: baseline;
	}
	ul, ol {
		padding: 0;
		margin: 0 0 11px 25px;
	}
	h1 {
		font-size: 36px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	h2 {
		font-size: 18px;
		color: #f14e32;
		font-weight: bold;
	}
	h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h1{
		font-size: 22px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	ol.book-toc h2 {
		font-size: 16px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	p {
		margin: 0 0 11px;
		font-size: 14px;
		line-height: 22px;
	}
	div {
		display: block;
	}
	div#nav{
		padding: 30px
	}
  </style>
</head>
<body>
  <div class="page">
    <div class="file-box">
	<div class="file">
		<div id="readme" class="blob instapaper_body announce md">
		  <article class="markdown-body entry-content" itemprop="mainContentOfPage">
			<html>
 <body>
  <h1>
   <a aria-hidden="true" class="anchor" href="#%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C" name="user-content-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C">
    <span class="octicon octicon-link">
    </span>
   </a>
   最大连续子数组和
  </h1>
  <h2>
   <a aria-hidden="true" class="anchor" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" name="user-content-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">
    <span class="octicon octicon-link">
    </span>
   </a>
   题目描述
  </h2>
  <p>
   输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。
求所有子数组的和的最大值，要求时间复杂度为O(n)。
  </p>
  <p>
   例如输入的数组为
   <code>
    1, -2, 3, 10, -4, 7, 2, -5
   </code>
   ，和最大的子数组为
   <code>
    3, 10, -4, 7, 2
   </code>
   ，
因此输出为该子数组的和18。
  </p>
  <h2>
   <a aria-hidden="true" class="anchor" href="#%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E6%B3%95" name="user-content-%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E6%B3%95">
    <span class="octicon octicon-link">
    </span>
   </a>
   分析与解法
  </h2>
  <h3>
   <a aria-hidden="true" class="anchor" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B%E5%BE%AA%E7%8E%AF" name="user-content-%E8%A7%A3%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B%E5%BE%AA%E7%8E%AF">
    <span class="octicon octicon-link">
    </span>
   </a>
   解法一：暴力循环
  </h3>
  <p>
   求一个数组的最大子数组和，如此序列
   <code>
    1, -2, 3, 10, -4, 7, 2, -5
   </code>
   ，我想最最直观也是最野蛮的办法便是，三个for循环三层遍历，求出数组中每一个子数组的和，最终求出这些子数组的最大的一个值。
currSum[i, …, j]为数组A中第i个元素到第j个元素的和（其中0 &lt;= i &lt;= j &lt; n），currSum[i, …, j]，那么时间复杂度为O(N^3)：
  </p>
  <div class="highlight highlight-c">
   <pre><span class="kt">int</span> <span class="nf">MaxSubArray</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="o">-</span><span class="n">INF</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">currSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">currSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">currSum</span> <span class="o">&gt;</span> <span class="n">maxSum</span><span class="p">)</span>
                <span class="n">maxSum</span> <span class="o">=</span> <span class="n">currSum</span><span class="p">;</span>

            <span class="n">currSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//这里要记得清零，否则的话sum最终存放的是所有子数组的和。</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>
  <h3>
   <a aria-hidden="true" class="anchor" href="#%E8%A7%A3%E6%B3%95%E4%BA%8Con%E9%81%8D%E5%8E%86" name="user-content-%E8%A7%A3%E6%B3%95%E4%BA%8Con%E9%81%8D%E5%8E%86">
    <span class="octicon octicon-link">
    </span>
   </a>
   解法二：O(N)遍历
  </h3>
  <p>
   当全是负数的情况时，我们可以让程序返回0，也可以让程序返回最大的那个负数，这里，我们让程序返回最大的那个负数，参考代码如下：
  </p>
  <div class="highlight highlight-c">
   <pre><span class="kt">int</span> <span class="nf">MaxSubArray</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>       <span class="c1">//全负情况，返回最大数</span>
    <span class="kt">int</span> <span class="n">currSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">currSum</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>    <span class="c1">//如果加上某个元素，sum&gt;=0的话，就加</span>
            <span class="n">currSum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="k">else</span>
            <span class="n">currSum</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>  <span class="c1">//如果加上某个元素，sum&lt;0了，就不加</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">currSum</span> <span class="o">&gt;</span> <span class="n">maxSum</span><span class="p">)</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="n">currSum</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>
  <p>
   解释下：
例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，
那么最大的子数组为3, 10, -4, 7, 2，
因此输出为该子数组的和18。
  </p>
  <p>
   所有的东西都在以下俩行，
即：
  </p>
  <ul>
   <li>
    currSum：   0  1 - 1  3  13   9  16  18  13
   </li>
   <li>
    maxSum ：  0  1   1  3  13  13  16  18  18
   </li>
  </ul>
  <p>
   其实算法很简单，当前面的几个数，加起来后，currSum&lt;0后，
把currSum重新赋值，置为下一个元素，currSum = a[i]。
  </p>
  <ul>
   <li>
    当currSum &gt; maxSum，则更新maxSum = currSum;
   </li>
   <li>
    若currSum &lt; maxSum，则maxSum保持原值，不更新。
   </li>
  </ul>
  <h3>
   <a aria-hidden="true" class="anchor" href="#%E8%A7%A3%E6%B3%95%E4%B8%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" name="user-content-%E8%A7%A3%E6%B3%95%E4%B8%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">
    <span class="octicon octicon-link">
    </span>
   </a>
   解法三：动态规划
  </h3>
  <p>
   currSum[i] 为前i个元素中，包含第i个元素且和最大的连续子数组，result 为已找到的子数组中和最大的。
对第i+1个元素有两种选择：
  </p>
  <ul>
   <li>
    做为新子数组的第一个元素；
   </li>
   <li>
    放入前面找到的子数组。
   </li>
  </ul>
  <pre><code>currSum[i+1] = max(a[i+1], currSum[i] + a[i+1])
maxSum = max(maxSum, currSum[i])
</code></pre>
  <p>
   参考代码如下：
  </p>
  <div class="highlight highlight-c">
   <pre><span class="kt">int</span> <span class="nf">MaxSubArray</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">nullptr</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">currSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>       <span class="c1">//全负情况，返回最大数</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">currSum</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">currSum</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">?</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">:</span> <span class="n">currSum</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">maxSum</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxSum</span> <span class="o">&gt;</span> <span class="n">currSum</span><span class="p">)</span> <span class="o">?</span> <span class="nl">maxSum</span> <span class="p">:</span> <span class="n">currSum</span><span class="p">;</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
<span class="p">}</span>
</pre>
  </div>
  <h2>
   <a aria-hidden="true" class="anchor" href="#%E9%97%AE%E9%A2%98%E6%89%A9%E5%B1%95" name="user-content-%E9%97%AE%E9%A2%98%E6%89%A9%E5%B1%95">
    <span class="octicon octicon-link">
    </span>
   </a>
   问题扩展
  </h2>
  <ol>
   <li>
    如果数组是二维数组，同样要你求最大子数组的和列?
   </li>
   <li>
    如果是要你求子数组的最大乘积列?
   </li>
   <li>
    如果同时要求输出子段的开始和结束列?
   </li>
  </ol>
  <h2>
   <a aria-hidden="true" class="anchor" href="#%E4%B8%BE%E4%B8%80%E5%8F%8D%E4%B8%89" name="user-content-%E4%B8%BE%E4%B8%80%E5%8F%8D%E4%B8%89">
    <span class="octicon octicon-link">
    </span>
   </a>
   举一反三
  </h2>
  <p>
   1 给定整型数组，其中每个元素表示木板的高度，木板的宽度都相同，求这些木板拼出的最大矩形的面积。并分析时间复杂度。
  </p>
  <p>
   此题类似leetcode里面关于连通器的题，需要明确的是高度可能为0，长度最长的矩形并不一定是最大矩形，还需要考虑高度很高，但长度较短的矩形。如[5,4,3,2,4,5,0,7,8,4,6]中最大矩形的高度是[7,8,4,6]组成的矩形，面积为16。
  </p>
  <p>
   2、环面上的最大子矩形
  </p>
  <p>
   《算法竞赛入门经典》 P89 页。
  </p>
  <p>
   3、最大子矩阵和
  </p>
  <p>
   一个M*N的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的值。如果所有数都是负数，就输出0。
例如：3*5的矩阵：
  </p>
  <p>
   1 2 0 3 4
  </p>
  <p>
   2 3 4 5 1
  </p>
  <p>
   1 1 5 3 0
  </p>
  <p>
   和最大的子矩阵是：
  </p>
  <p>
   4 5
  </p>
  <p>
   5 3
  </p>
  <p>
   最后输出和的最大值17。
  </p>
  <p>
   4、允许交换两个数的位置 求最大子数组和。
  </p>
  <p>
   来源：
   <a href="https://codility.com/cert/view/certDUMWPM-8RF86G8P9QQ6JC8X/details">
    https://codility.com/cert/view/certDUMWPM-8RF86G8P9QQ6JC8X/details
   </a>
   。
  </p>
 </body>
</html>
		  </article>
		  
			<div id="nav">
				
					<a href="02.03.html">prev</a>
					|
				
				
					<a href="02.05.html">next</a>
				
				<span style="float: right"><a href="index.html">Back to home</a>
			</div>
		  
		</div>
	</div>
  </div>
  
  <div>&nbsp;</div>
  </div>
  <div style="text-align:center; margin-bottom: 30px">
	  Generated by <a href="https://github.com/marchtea/md_to_github_html">mdtogh</a>
  </div>
</body>
</html>